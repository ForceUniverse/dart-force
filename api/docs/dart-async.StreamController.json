{"name":"StreamController","qualifiedName":"dart-async.StreamController","comment":"<p>A controller with the stream it controls.</p>\n<p>This controller allows sending data, error and done events on\nits <a>dart-async.StreamController.stream</a>.\nThis class can be used to create a simple stream that others\ncan listen on, and to push events to that stream.</p>\n<p>It's possible to check whether the stream is paused or not, and whether\nit has subscribers or not, as well as getting a callback when either of\nthese change.</p>\n<p>If the stream starts or stops having listeners (first listener subscribing,\nlast listener unsubscribing), the <code>onSubscriptionStateChange</code> callback\nis notified as soon as possible. If the subscription stat changes during\nan event firing or a callback being executed, the change will not be reported\nuntil the current event or callback has finished.\nIf the pause state has also changed during an event or callback, only the\nsubscription state callback is notified.</p>\n<p>If the subscriber state has not changed, but the pause state has, the\n<code>onPauseStateChange</code> callback is notified as soon as possible, after firing\na current event or completing another callback. This happens if the stream\nis not paused, and a listener pauses it, or if the stream has been resumed\nfrom pause and has no pending events. If the listeners resume a paused stream\nwhile it still has queued events, the controller will still consider the\nstream paused until all queued events have been dispatched.</p>\n<p>Whether to invoke a callback depends only on the state before and after\na stream action, for example firing an event. If the state changes multiple\ntimes during the action, and then ends up in the same state as before, no\ncallback is performed.</p>\n<p>If listeners are added after the stream has completed (sent a \"done\" event),\nthe listeners will be sent a \"done\" event eventually, but they won't affect\nthe stream at all, and won't trigger callbacks. From the controller's point\nof view, the stream is completely inert when has completed.</p>","isAbstract":true,"superclass":"dart-core.Object","implements":["dart-async.StreamSink"],"subclass":[],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{"hasListener":{"name":"hasListener","qualifiedName":"dart-async.StreamController.hasListener","comment":"<p>Whether there is a subscriber on the <a>dart-async.Stream</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isClosed":{"name":"isClosed","qualifiedName":"dart-async.StreamController.isClosed","comment":"<p>Whether the stream is closed for adding more events.</p>\n<p>If true, the \"done\" event might not have fired yet, but it has been\nscheduled, and it is too late to add more events.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isPaused":{"name":"isPaused","qualifiedName":"dart-async.StreamController.isPaused","comment":"<p>Whether the subscription would need to buffer events.</p>\n<p>This is the case if the controller's stream has a listener and it is\npaused, or if it has not received a listener yet. In that case, the\ncontroller is considered paused as well.</p>\n<p>A broadcast stream controller is never considered paused. It always\nforwards its events to all uncanceled listeners, if any, and let them\nhandle their own pausing.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"sink":{"name":"sink","qualifiedName":"dart-async.StreamController.sink","comment":"<p>Returns a view of this object that only exposes the <a>dart-async.StreamSink</a> interface.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.StreamSink","inner":[{"outer":"dart-async.StreamController.T","inner":[]}]}],"parameters":{},"annotations":[]},"stream":{"name":"stream","qualifiedName":"dart-async.StreamController.stream","comment":"<p>The stream that this controller is controlling.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-async.StreamController.T","inner":[]}]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"dart-async.StreamController.StreamController-","comment":"<p>A controller with a <a>dart-async.StreamController.stream</a> that supports only one single subscriber.</p>\n<p>If <a>dart-async.StreamController.StreamController-.sync</a> is true, events may be passed directly to the stream's listener\nduring an add, <a>dart-async.StreamController.addError</a> or close call. If <a>dart-async.StreamController.StreamController-.sync</a> is false, the event\nwill be passed to the listener at a later time, after the code creating\nthe event has returned.</p>\n<p>The controller will buffer all incoming events until the subscriber is\nregistered.</p>\n<p>The <a>dart-async.StreamController.StreamController-.onPause</a> function is called when the stream becomes\npaused. <a>dart-async.StreamController.StreamController-.onResume</a> is called when the stream resumed.</p>\n<p>The <a>dart-async.StreamController.StreamController-.onListen</a> callback is called when the stream\nreceives its listener and <a>dart-async.StreamController.StreamController-.onCancel</a> when the listener ends\nits subscription. If <a>dart-async.StreamController.StreamController-.onCancel</a> needs to perform an asynchronous operation,\n<a>dart-async.StreamController.StreamController-.onCancel</a> should return a future that completes when the cancel operation\nis done.</p>\n<p>If the stream is canceled before the controller needs new data the\n<a>dart-async.StreamController.StreamController-.onResume</a> call might not be executed.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.StreamController","inner":[{"outer":"dart-async.StreamController.T","inner":[]}]}],"parameters":{"onListen":{"name":"onListen","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}},"onPause":{"name":"onPause","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}},"onResume":{"name":"onResume","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}},"onCancel":{"name":"onCancel","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{}}},"sync":{"name":"sync","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"broadcast":{"name":"broadcast","qualifiedName":"dart-async.StreamController.StreamController-broadcast","comment":"<p>A controller where <a>dart-async.StreamController.stream</a> can be listened to more than once.</p>\n<p>The <a>dart-async.Stream</a> returned by <a>dart-async.StreamController.stream</a> is a broadcast stream.\nIt can be listened to more than once.</p>\n<p>The controller distributes any events to all currently subscribed\nlisteners at the time when add, <a>dart-async.StreamController.addError</a> or close is called.\nIt is not allowed to call <code>add</code>, <code>addError</code>, or <code>close</code> before a previous\ncall has returned. The controller does not have any internal queue of\nevents, and if there are no listeners at the time the event is added,\nit will just be dropped, or, if it is an error, be reported as uncaught.</p>\n<p>Each listener subscription is handled independently,\nand if one pauses, only the pausing listener is affected.\nA paused listener will buffer events internally until unpaused or canceled.</p>\n<p>If <a>dart-async.StreamController.StreamController-broadcast.sync</a> is true, events may be fired directly by the stream's\nsubscriptions during an add, <a>dart-async.StreamController.addError</a> or close call.\nIf <a>dart-async.StreamController.StreamController-broadcast.sync</a> is false, the event will be fired at a later time,\nafter the code adding the event has completed.</p>\n<p>When <a>dart-async.StreamController.StreamController-broadcast.sync</a> is false, no guarantees are given with regard to when\nmultiple listeners get the events, except that each listener will get\nall events in the correct order. Each subscription handles the events\nindividually.\nIf two events are sent on an async controller with two listeners,\none of the listeners may get both events\nbefore the other listener gets any.\nA listener must be subscribed both when the event is initiated\n(that is, when add is called)\nand when the event is later delivered,\nin order to receive the event.</p>\n<p>The <a>dart-async.StreamController.StreamController-broadcast.onListen</a> callback is called when the first listener is subscribed,\nand the <a>dart-async.StreamController.StreamController-broadcast.onCancel</a> is called when there are no longer any active listeners.\nIf a listener is added again later, after the <a>dart-async.StreamController.StreamController-broadcast.onCancel</a> was called,\nthe <a>dart-async.StreamController.StreamController-broadcast.onListen</a> will be called again.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.StreamController","inner":[{"outer":"dart-async.StreamController.T","inner":[]}]}],"parameters":{"onListen":{"name":"onListen","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}},"onCancel":{"name":"onCancel","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}},"sync":{"name":"sync","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]}},"operators":{},"methods":{"addError":{"name":"addError","qualifiedName":"dart-async.StreamController.addError","comment":"<p>Send or enqueue an error event.</p>\n<p>Also allows an objection stack trace object, on top of what <a>dart-async.EventSink</a>\nallows.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"error":{"name":"error","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]},"stackTrace":{"name":"stackTrace","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.StackTrace","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"addStream":{"name":"addStream","qualifiedName":"dart-async.StreamController.addStream","comment":"<p>Receives events from <a>dart-async.StreamController.addStream.source</a> and puts them into this controller's stream.</p>\n<p>Returns a future which completes when the source stream is done.</p>\n<p>Events must not be added directly to this controller using add,\n<a>dart-async.StreamController.addError</a>, close or <a>dart-async.StreamController.addStream</a>, until the returned future\nis complete.</p>\n<p>Data and error events are forwarded to this controller's stream. A done\nevent on the source will end the <code>addStream</code> operation and complete the\nreturned future.</p>\n<p>If <a>dart-async.StreamController.addStream.cancelOnError</a> is true, only the first error on <a>dart-async.StreamController.addStream.source</a> is\nforwarded to the controller's stream, and the <code>addStream</code> ends\nafter this. If <a>dart-async.StreamController.addStream.cancelOnError</a> is false, all errors are forwarded\nand only a done event will end the <code>addStream</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{"source":{"name":"source","optional":false,"named":false,"default":false,"type":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-async.StreamController.T","inner":[]}]}],"value":null,"annotations":[]},"cancelOnError":{"name":"cancelOnError","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"done":{"name":"done","qualifiedName":"dart-async.StreamController.done","comment":"<p>The <a>dart-async.StreamController.done</a> Future completes with the same values as <a>dart-async.StreamController.close</a>, except\nfor the following case:</p><ul><li>\n<p>The synchronous methods of <a>dart-async.EventSink</a> were called, resulting in an\n  error. If there is no active future (like from an addStream call), the\n  <a>dart-async.StreamController.done</a> future will complete with that error</p></li></ul>","commentFrom":"","inheritedFrom":"dart-async.StreamSink.done","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"dart-async.StreamController.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-async.StreamController.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-async.StreamController.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-async.StreamController.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart-async.StreamController.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart-async.StreamController.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"add":{"name":"add","qualifiedName":"dart-async.StreamController.add","comment":"<p>Create a data event</p>","commentFrom":"","inheritedFrom":"dart-async.EventSink.add","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"event":{"name":"event","optional":false,"named":false,"default":false,"type":[{"outer":"dart-async.EventSink.T","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"addError":{"name":"addError","qualifiedName":"dart-async.StreamController.addError","comment":"<p>Create an async error.</p>","commentFrom":"","inheritedFrom":"dart-async.EventSink.addError","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"errorEvent":{"name":"errorEvent","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"stackTrace":{"name":"stackTrace","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.StackTrace","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"addStream":{"name":"addStream","qualifiedName":"dart-async.StreamController.addStream","comment":"<p>Consumes the elements of <a>dart-async.StreamController.addStream.stream</a>.</p>\n<p>Listens on <a>dart-async.StreamController.addStream.stream</a> and does something for each event.</p>\n<p>The consumer may stop listening after an error, or it may consume\nall the errors and only stop at a done event.</p>","commentFrom":"","inheritedFrom":"dart-async.StreamConsumer.addStream","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{"stream":{"name":"stream","optional":false,"named":false,"default":false,"type":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-async.StreamConsumer.S","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"close":{"name":"close","qualifiedName":"dart-async.StreamController.close","comment":"<p>Close the <a>dart-async.StreamSink</a>. It'll return the <a>dart-async.StreamController.done</a> Future.</p>","commentFrom":"","inheritedFrom":"dart-async.StreamSink.close","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-async.StreamController.noSuchMethod","comment":"<p><a>dart-async.StreamController.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-async.StreamController.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-async.StreamController.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-async.StreamController.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-async.StreamController.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{"T":{"name":"T","type":"dart.core.Object"}}}