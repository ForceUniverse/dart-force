{"name":"logging","qualifiedName":"logging/logging","comment":"<p>Support for logging.</p>\n<p>For information on installing and importing this library, see the\n<a href=\"http://pub.dartlang.org/packages/logging\">logging package on pub.dartlang.org</a>.</p>\n<h2>Initializing</h2>\n<p>By default, the logging package does not do anything useful with the\nlog messages. You must configure the logging level and add a handler\nfor the log messages.</p>\n<p>Here is a simple logging configuration that logs all messages\nvia <code>print</code>.</p>\n<pre><code>Logger.root.level = Level.ALL;\nLogger.root.onRecord.listen((LogRecord rec) {\n  print('${rec.level.name}: ${rec.time}: ${rec.message}');\n});\n</code></pre>\n<p>First, set the root <a>logging/logging.Level</a>. All messages at or above the level are\nsent to the onRecord stream.</p>\n<p>Then, listen on the onRecord stream for <a>logging/logging.LogRecord</a> events. The\n<a>logging/logging.LogRecord</a> class has various properties for the message, error,\nlogger name, and more.</p>\n<h2>Logging messages</h2>\n<p>Create a <a>logging/logging.Logger</a> with a unique name to easily identify the source\nof the log messages.</p>\n<pre><code>final Logger log = new Logger('MyClassName');\n</code></pre>\n<p>Here is an example of logging a debug message and an error:</p>\n<pre><code>Future future = doSomethingAsync();\nfuture.then((result) {\n  log.fine('Got the result: $result');\n  processResult(result);\n})\n.catchError((e, stackTrace) =&gt; log.severe('Oh noes!', e, stackTrace));\n</code></pre>\n<p>See the <a>logging/logging.Logger</a> class for the different logging methods.</p>","variables":{"hierarchicalLoggingEnabled":{"name":"hierarchicalLoggingEnabled","qualifiedName":"logging/logging.hierarchicalLoggingEnabled","comment":"<p>Whether to allow fine-grain logging and configuration of loggers in a\nhierarchy. When false, all logging is merged in the root logger.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.bool","inner":[]}],"annotations":[]}},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{}},"classes":{"class":[{"name":"Level","qualifiedName":"logging/logging.Level","preview":"<p><a>logging/logging.Level</a>s to control logging output. Logging can be enabled to include all\nlevels above certain <a>logging/logging.Level</a>. <a>logging/logging.Level</a>s are ordered using an integer\nvalue <a>logging/logging.Level.value</a>. The predefined <a>logging/logging.Level</a> constants below are sorted as\nfollows (in descending order): <a>logging/logging.Level.SHOUT</a>, <a>logging/logging.Level.SEVERE</a>,\n<a>logging/logging.Level.WARNING</a>, <a>logging/logging.Level.INFO</a>, <a>logging/logging.Level.CONFIG</a>, <a>logging/logging.Level.FINE</a>, <a>logging/logging.Level.FINER</a>,\n<a>logging/logging.Level.FINEST</a>, and <a>logging/logging.Level.ALL</a>.</p>"},{"name":"LogRecord","qualifiedName":"logging/logging.LogRecord","preview":"<p>A log entry representation used to propagate information from <a>logging/logging.Logger</a> to\nindividual Handlers.</p>"},{"name":"Logger","qualifiedName":"logging/logging.Logger","preview":"<p>Use a <a>logging/logging.Logger</a> to log debug messages. <a>logging/logging.Logger</a>s are named using a\nhierarchical dot-separated name convention.</p>"}],"typedef":{"LoggerHandler":{"name":"LoggerHandler","qualifiedName":"logging/logging.LoggerHandler","comment":"<p>Handler callback to process log entries as they are added to a <a>logging/logging.Logger</a>.</p>","return":"void","parameters":{"LogRecord":{"name":"LogRecord","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[],"generics":{},"preview":"<p>Handler callback to process log entries as they are added to a <a>logging/logging.Logger</a>.</p>"}},"error":[]},"packageName":"logging","packageIntro":""}