{"name":"LinkedHashSet","qualifiedName":"dart-collection.LinkedHashSet","comment":"<p>A <a>dart-collection.LinkedHashSet</a> is a hash-table based <a>dart-core.Set</a> implementation.</p>\n<p>The <code>LinkedHashSet</code> also keep track of the order that elements were inserted\nin, and iteration happens in first-to-last insertion order.</p>\n<p>The elements of a <code>LinkedHashSet</code> must have consistent Object.operator==\nand <a>dart-core.Object.hashCode</a> implementations. This means that the <code>==</code> operator\nmust define a stable equivalence relation on the elements (reflexive,\nanti-symmetric, transitive, and consistent over time), and that <code>hashCode</code>\nmust be the same for objects that are considered equal by <code>==</code>.</p>\n<p>The set allows <code>null</code> as an element.</p>\n<p>Iteration of elements is done in element insertion order.\nAn element that was added after another will occur later in the iteration.\nAdding an element that is already in the set\ndoes not change its position in the iteration order,\nbut removing an element and adding it again,\nwill make it the last element of an iteration.</p>\n<p>Most simple operations on <code>HashSet</code> are done in (potentially amortized)\nconstant time: add, contains, remove, and length, provided the hash\ncodes of objects are well distributed..</p>","isAbstract":true,"superclass":"dart-core.Object","implements":["dart-collection.HashSet"],"subclass":[],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{"iterator":{"name":"iterator","qualifiedName":"dart-collection.LinkedHashSet.iterator","comment":"<p>Provides an iterator that iterates over the elements in insertion order.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Iterator","inner":[{"outer":"dart-collection.LinkedHashSet.E","inner":[]}]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"dart-collection.LinkedHashSet.LinkedHashSet-","comment":"<p>Create an insertion-ordered hash set using the provided\n<a>dart-collection.LinkedHashSet.LinkedHashSet-.equals</a> and <a>dart-collection.LinkedHashSet.LinkedHashSet-.hashCode</a>.</p>\n<p>The provided <a>dart-collection.LinkedHashSet.LinkedHashSet-.equals</a> must define a stable equivalence relation, and\n<a>dart-collection.LinkedHashSet.LinkedHashSet-.hashCode</a> must be consistent with <a>dart-collection.LinkedHashSet.LinkedHashSet-.equals</a>. If the <a>dart-collection.LinkedHashSet.LinkedHashSet-.equals</a> or <a>dart-collection.LinkedHashSet.LinkedHashSet-.hashCode</a>\nmethods won't work on all objects, but only to instances of E, the\n<a>dart-collection.LinkedHashSet.LinkedHashSet-.isValidKey</a> predicate can be used to restrict the keys that they are\napplied to. Any key for which <a>dart-collection.LinkedHashSet.LinkedHashSet-.isValidKey</a> returns false is automatically\nassumed to not be in the set.</p>\n<p>If <a>dart-collection.LinkedHashSet.LinkedHashSet-.equals</a> or <a>dart-collection.LinkedHashSet.LinkedHashSet-.hashCode</a> are omitted, the set uses\nthe objects' intrinsic Object.operator== and <a>dart-collection.LinkedHashSet.hashCode</a>,</p>\n<p>If <a>dart-collection.LinkedHashSet.LinkedHashSet-.isValidKey</a> is omitted, it defaults to testing if the object is an\n<a>dart-collection.LinkedHashSet.E</a> instance.</p>\n<p>If you supply one of <a>dart-collection.LinkedHashSet.LinkedHashSet-.equals</a> and <a>dart-collection.LinkedHashSet.LinkedHashSet-.hashCode</a>,\nyou should generally also to supply the other.\nAn example would be using <a>dart-core.identical</a> and <a>dart-core.identityHashCode</a>,\nwhich is equivalent to using the shorthand LinkedSet.identity).</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-collection.LinkedHashSet","inner":[{"outer":"dart-collection.LinkedHashSet.E","inner":[]}]}],"parameters":{"equals":{"name":"equals","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"e1":{"name":"e1","optional":false,"named":false,"default":false,"type":[{"outer":"dart-collection.LinkedHashSet.E","inner":[]}],"value":null,"annotations":[]},"e2":{"name":"e2","optional":false,"named":false,"default":false,"type":[{"outer":"dart-collection.LinkedHashSet.E","inner":[]}],"value":null,"annotations":[]}}}},"hashCode":{"name":"hashCode","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"e":{"name":"e","optional":false,"named":false,"default":false,"type":[{"outer":"dart-collection.LinkedHashSet.E","inner":[]}],"value":null,"annotations":[]}}}},"isValidKey":{"name":"isValidKey","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"potentialKey":{"name":"potentialKey","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"from":{"name":"from","qualifiedName":"dart-collection.LinkedHashSet.LinkedHashSet-from","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-collection.LinkedHashSet","inner":[{"outer":"dart-collection.LinkedHashSet.E","inner":[]}]}],"parameters":{"iterable":{"name":"iterable","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-collection.LinkedHashSet.E","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"identity":{"name":"identity","qualifiedName":"dart-collection.LinkedHashSet.LinkedHashSet-identity","comment":"<p>Creates an insertion-ordered identity-based set.</p>\n<p>Effectively a shorthand for:</p>\n<pre><code>new LinkedHashSet(equals: identical, hashCode: identityHashCodeOf)\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-collection.LinkedHashSet","inner":[{"outer":"dart-collection.LinkedHashSet.E","inner":[]}]}],"parameters":{},"annotations":[]}},"operators":{},"methods":{"forEach":{"name":"forEach","qualifiedName":"dart-collection.LinkedHashSet.forEach","comment":"<p>Executes a function on each element of the set.</p>\n<p>The elements are iterated in insertion order.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"action":{"name":"action","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart-collection.LinkedHashSet.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"first":{"name":"first","qualifiedName":"dart-collection.LinkedHashSet.first","comment":"<p>Returns the first element.</p>\n<p>If <code>this</code> is empty throws a <a>dart-core.StateError</a>. Otherwise this method is\nequivalent to <code>this.elementAt(0)</code></p>","commentFrom":"dart-core.Iterable.first","inheritedFrom":"dart-core.IterableBase.first","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"dart-collection.LinkedHashSet.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-collection.LinkedHashSet.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"isEmpty":{"name":"isEmpty","qualifiedName":"dart-collection.LinkedHashSet.isEmpty","comment":"<p>Returns true if there is no element in this collection.</p>","commentFrom":"dart-core.Iterable.isEmpty","inheritedFrom":"dart-core.IterableBase.isEmpty","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isNotEmpty":{"name":"isNotEmpty","qualifiedName":"dart-collection.LinkedHashSet.isNotEmpty","comment":"<p>Returns true if there is at least one element in this collection.</p>","commentFrom":"dart-core.Iterable.isNotEmpty","inheritedFrom":"dart-core.IterableBase.isNotEmpty","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"iterator":{"name":"iterator","qualifiedName":"dart-collection.LinkedHashSet.iterator","comment":"<p>Provides an iterator that iterates over the elements of this set.</p>\n<p>The order of iteration is unspecified,\nbut consistent between changes to the set.</p>","commentFrom":"","inheritedFrom":"dart-collection.HashSet.iterator","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Iterator","inner":[{"outer":"dart-collection.HashSet.E","inner":[]}]}],"parameters":{},"annotations":[]},"last":{"name":"last","qualifiedName":"dart-collection.LinkedHashSet.last","comment":"<p>Returns the last element.</p>\n<p>If <code>this</code> is empty throws a <a>dart-core.StateError</a>.</p>","commentFrom":"dart-core.Iterable.last","inheritedFrom":"dart-core.IterableBase.last","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"length":{"name":"length","qualifiedName":"dart-collection.LinkedHashSet.length","comment":"<p>Returns the number of elements in the iterable.</p>\n<p>This is an efficient operation that doesn't require iterating through\nthe elements.</p>","commentFrom":"","inheritedFrom":"dart-core.EfficientLength.length","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-collection.LinkedHashSet.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]},"single":{"name":"single","qualifiedName":"dart-collection.LinkedHashSet.single","comment":"<p>Returns the single element in <code>this</code>.</p>\n<p>If <code>this</code> is empty or has more than one element throws a <a>dart-core.StateError</a>.</p>","commentFrom":"dart-core.Iterable.single","inheritedFrom":"dart-core.IterableBase.single","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-collection.LinkedHashSet.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart-collection.LinkedHashSet.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart-collection.LinkedHashSet.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"add":{"name":"add","qualifiedName":"dart-collection.LinkedHashSet.add","comment":"<p>Adds <a>dart-collection.LinkedHashSet.add.value</a> into the set. Returns <code>true</code> if <a>dart-collection.LinkedHashSet.add.value</a> was added to the set.</p>\n<p>If <a>dart-collection.LinkedHashSet.add.value</a> already exists, the set is not changed and <code>false</code> is returned.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.add","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Set.E","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"addAll":{"name":"addAll","qualifiedName":"dart-collection.LinkedHashSet.addAll","comment":"<p>Adds all of <a>dart-collection.LinkedHashSet.addAll.elements</a> to this Set.</p>\n<p>Equivalent to adding each element in <a>dart-collection.LinkedHashSet.addAll.elements</a> using <a>dart-collection.LinkedHashSet.add</a>,\nbut some collections may be able to optimize it.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.addAll","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"elements":{"name":"elements","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.Set.E","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"any":{"name":"any","qualifiedName":"dart-collection.LinkedHashSet.any","comment":"<p>Returns true if one element of this collection satisfies the\npredicate test. Returns false otherwise.</p>","commentFrom":"dart-core.Iterable.any","inheritedFrom":"dart-core.IterableBase.any","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"clear":{"name":"clear","qualifiedName":"dart-collection.LinkedHashSet.clear","comment":"<p>Removes all elements in the set.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.clear","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"contains":{"name":"contains","qualifiedName":"dart-collection.LinkedHashSet.contains","comment":"<p>Returns true if <a>dart-collection.LinkedHashSet.contains.value</a> is in the set.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.contains","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"containsAll":{"name":"containsAll","qualifiedName":"dart-collection.LinkedHashSet.containsAll","comment":"<p>Returns whether this Set contains all the elements of <a>dart-collection.LinkedHashSet.containsAll.other</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.containsAll","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.Object","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"difference":{"name":"difference","qualifiedName":"dart-collection.LinkedHashSet.difference","comment":"<p>Returns a new set with the the elements of this that are not in <a>dart-collection.LinkedHashSet.difference.other</a>.</p>\n<p>That is, the returned set contains all the elements of this <a>dart-core.Set</a> that\nare not elements of <a>dart-collection.LinkedHashSet.difference.other</a> according to <code>other.contains</code>.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.difference","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Set","inner":[{"outer":"dart-core.Set.E","inner":[]}]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Set","inner":[{"outer":"dart-core.Set.E","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"elementAt":{"name":"elementAt","qualifiedName":"dart-collection.LinkedHashSet.elementAt","comment":"<p>Returns the <a>dart-collection.LinkedHashSet.elementAt.index</a>th element.</p>\n<p>The <a>dart-collection.LinkedHashSet.elementAt.index</a> must be non-negative and less than <a>dart-core.IterableBase.length</a>.</p>\n<p>Note: if <code>this</code> does not have a deterministic iteration order then the\nfunction may simply return any element without any iteration if there are\nat least <a>dart-collection.LinkedHashSet.elementAt.index</a> elements in <code>this</code>.</p>","commentFrom":"dart-core.Iterable.elementAt","inheritedFrom":"dart-core.IterableBase.elementAt","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"index":{"name":"index","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"every":{"name":"every","qualifiedName":"dart-collection.LinkedHashSet.every","comment":"<p>Returns true if every elements of this collection satisify the\npredicate test. Returns <code>false</code> otherwise.</p>","commentFrom":"dart-core.Iterable.every","inheritedFrom":"dart-core.IterableBase.every","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"expand":{"name":"expand","qualifiedName":"dart-collection.LinkedHashSet.expand","comment":"<p>Expands each element of this <a>dart-core.Iterable</a> into zero or more elements.</p>\n<p>The resulting Iterable runs through the elements returned\nby <a>dart-collection.LinkedHashSet.expand.f</a> for each element of this, in order.</p>\n<p>The returned <a>dart-core.Iterable</a> is lazy, and calls <a>dart-collection.LinkedHashSet.expand.f</a> for each element\nof this every time it's iterated.</p>","commentFrom":"dart-core.Iterable.expand","inheritedFrom":"dart-core.IterableBase.expand","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Iterable","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.Iterable","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"firstWhere":{"name":"firstWhere","qualifiedName":"dart-collection.LinkedHashSet.firstWhere","comment":"<p>Returns the first element that satisfies the given predicate <a>dart-collection.LinkedHashSet.firstWhere.test</a>.</p>\n<p>If none matches, the result of invoking the <a>dart-collection.LinkedHashSet.firstWhere.orElse</a> function is\nreturned. By default, when <a>dart-collection.LinkedHashSet.firstWhere.orElse</a> is <code>null</code>, a <a>dart-core.StateError</a> is\nthrown.</p>","commentFrom":"dart-core.Iterable.firstWhere","inheritedFrom":"dart-core.IterableBase.firstWhere","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}},"orElse":{"name":"orElse","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.Object","inner":[]}],"parameters":{}}}},"annotations":[]},"fold":{"name":"fold","qualifiedName":"dart-collection.LinkedHashSet.fold","comment":"<p>Reduces a collection to a single value by iteratively combining each\nelement of the collection with an existing value using the provided\nfunction.</p>\n<p>Use <a>dart-collection.LinkedHashSet.fold.initialValue</a> as the initial value, and the function <a>dart-collection.LinkedHashSet.fold.combine</a> to\ncreate a new value from the previous one and an element.</p>\n<p>Example of calculating the sum of an iterable:</p>\n<pre><code>iterable.fold(0, (prev, element) =&gt; prev + element);\n</code></pre>","commentFrom":"dart-core.Iterable.fold","inheritedFrom":"dart-core.IterableBase.fold","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"initialValue":{"name":"initialValue","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"combine":{"name":"combine","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{"previousValue":{"name":"previousValue","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"forEach":{"name":"forEach","qualifiedName":"dart-collection.LinkedHashSet.forEach","comment":"<p>Applies the function <a>dart-collection.LinkedHashSet.forEach.f</a> to each element of this collection.</p>","commentFrom":"dart-core.Iterable.forEach","inheritedFrom":"dart-core.IterableBase.forEach","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"intersection":{"name":"intersection","qualifiedName":"dart-collection.LinkedHashSet.intersection","comment":"<p>Returns a new set which is the intersection between this set and <a>dart-collection.LinkedHashSet.intersection.other</a>.</p>\n<p>That is, the returned set contains all the elements of this <a>dart-core.Set</a> that\nare also elements of <a>dart-collection.LinkedHashSet.intersection.other</a> according to <code>other.contains</code>.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.intersection","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Set","inner":[{"outer":"dart-core.Set.E","inner":[]}]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Set","inner":[{"outer":"dart-core.Object","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"join":{"name":"join","qualifiedName":"dart-collection.LinkedHashSet.join","comment":"<p>Converts each element to a <a>dart-core.String</a> and concatenates the strings.</p>\n<p>Converts each element to a <a>dart-core.String</a> by calling <a>dart-collection.LinkedHashSet.toString</a> on it.\nThen concatenates the strings, optionally separated by the <a>dart-collection.LinkedHashSet.join.separator</a>\nstring.</p>","commentFrom":"dart-core.Iterable.join","inheritedFrom":"dart-core.IterableBase.join","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"separator":{"name":"separator","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.String","inner":[]}],"value":"\"\"","annotations":[]}},"annotations":[]},"lastWhere":{"name":"lastWhere","qualifiedName":"dart-collection.LinkedHashSet.lastWhere","comment":"<p>Returns the last element that satisfies the given predicate <a>dart-collection.LinkedHashSet.lastWhere.test</a>.</p>\n<p>If none matches, the result of invoking the <a>dart-collection.LinkedHashSet.lastWhere.orElse</a> function is\nreturned. By default, when <a>dart-collection.LinkedHashSet.lastWhere.orElse</a> is <code>null</code>, a <a>dart-core.StateError</a> is\nthrown.</p>","commentFrom":"dart-core.Iterable.lastWhere","inheritedFrom":"dart-core.IterableBase.lastWhere","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}},"orElse":{"name":"orElse","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.Object","inner":[]}],"parameters":{}}}},"annotations":[]},"lookup":{"name":"lookup","qualifiedName":"dart-collection.LinkedHashSet.lookup","comment":"<p>If an object equal to <a>dart-collection.LinkedHashSet.lookup.object</a> is in the set, return it.</p>\n<p>Checks if there is an object in the set that is equal to <a>dart-collection.LinkedHashSet.lookup.object</a>.\nIf so, that object is returned, otherwise returns null.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.lookup","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Set.E","inner":[]}],"parameters":{"object":{"name":"object","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"map":{"name":"map","qualifiedName":"dart-collection.LinkedHashSet.map","comment":"<p>Returns a lazy <a>dart-core.Iterable</a> where each element <code>e</code> of <code>this</code> is replaced\nby the result of <code>f(e)</code>.</p>\n<p>This method returns a view of the mapped elements. As long as the\nreturned <a>dart-core.Iterable</a> is not iterated over, the supplied function <a>dart-collection.LinkedHashSet.map.f</a> will\nnot be invoked. The transformed elements will not be cached. Iterating\nmultiple times over the the returned <a>dart-core.Iterable</a> will invoke the supplied\nfunction <a>dart-collection.LinkedHashSet.map.f</a> multiple times on the same element.</p>","commentFrom":"dart-core.Iterable.map","inheritedFrom":"dart-core.IterableBase.map","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Iterable","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dynamic","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-collection.LinkedHashSet.noSuchMethod","comment":"<p><a>dart-collection.LinkedHashSet.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-collection.LinkedHashSet.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-collection.LinkedHashSet.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-collection.LinkedHashSet.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"reduce":{"name":"reduce","qualifiedName":"dart-collection.LinkedHashSet.reduce","comment":"<p>Reduces a collection to a single value by iteratively combining elements\nof the collection using the provided function.</p>\n<p>Example of calculating the sum of an iterable:</p>\n<pre><code>iterable.reduce((value, element) =&gt; value + element);\n</code></pre>","commentFrom":"dart-core.Iterable.reduce","inheritedFrom":"dart-core.IterableBase.reduce","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"combine":{"name":"combine","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.IterableBase.E","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]},"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"remove":{"name":"remove","qualifiedName":"dart-collection.LinkedHashSet.remove","comment":"<p>Removes <a>dart-collection.LinkedHashSet.remove.value</a> from the set. Returns true if <a>dart-collection.LinkedHashSet.remove.value</a> was\nin the set. Returns false otherwise. The method has no effect\nif <a>dart-collection.LinkedHashSet.remove.value</a> value was not in the set.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.remove","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"removeAll":{"name":"removeAll","qualifiedName":"dart-collection.LinkedHashSet.removeAll","comment":"<p>Removes each element of <a>dart-collection.LinkedHashSet.removeAll.elements</a> from this set.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.removeAll","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"elements":{"name":"elements","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.Object","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"removeWhere":{"name":"removeWhere","qualifiedName":"dart-collection.LinkedHashSet.removeWhere","comment":"<p>Removes all elements of this set that satisfy <a>dart-collection.LinkedHashSet.removeWhere.test</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.removeWhere","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Set.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"retainAll":{"name":"retainAll","qualifiedName":"dart-collection.LinkedHashSet.retainAll","comment":"<p>Removes all elements of this set that are not elements in <a>dart-collection.LinkedHashSet.retainAll.elements</a>.</p>\n<p>Checks for each element of <a>dart-collection.LinkedHashSet.retainAll.elements</a> whether there is an element in this\nset that is equal to it (according to <code>this.contains</code>), and if so, the\nequal element in this set is retained, and elements that are not equal\nto any element in <code>elements</code> are removed.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.retainAll","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"elements":{"name":"elements","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.Object","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"retainWhere":{"name":"retainWhere","qualifiedName":"dart-collection.LinkedHashSet.retainWhere","comment":"<p>Removes all elements of this set that fail to satisfy <a>dart-collection.LinkedHashSet.retainWhere.test</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.retainWhere","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Set.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"singleWhere":{"name":"singleWhere","qualifiedName":"dart-collection.LinkedHashSet.singleWhere","comment":"<p>Returns the single element that satisfies <a>dart-collection.LinkedHashSet.singleWhere.test</a>. If no or more than one\nelement match then a <a>dart-core.StateError</a> is thrown.</p>","commentFrom":"dart-core.Iterable.singleWhere","inheritedFrom":"dart-core.IterableBase.singleWhere","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"skip":{"name":"skip","qualifiedName":"dart-collection.LinkedHashSet.skip","comment":"<p>Returns an Iterable that skips the first <a>dart-collection.LinkedHashSet.skip.n</a> elements.</p>\n<p>If <code>this</code> has fewer than <a>dart-collection.LinkedHashSet.skip.n</a> elements, then the resulting Iterable is\nempty.</p>\n<p>It is an error if <a>dart-collection.LinkedHashSet.skip.n</a> is negative.</p>","commentFrom":"dart-core.Iterable.skip","inheritedFrom":"dart-core.IterableBase.skip","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.int","inner":[]}]}],"parameters":{"n":{"name":"n","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"skipWhile":{"name":"skipWhile","qualifiedName":"dart-collection.LinkedHashSet.skipWhile","comment":"<p>Returns an Iterable that skips elements while <a>dart-collection.LinkedHashSet.skipWhile.test</a> is satisfied.</p>\n<p>The filtering happens lazily. Every new Iterator of the returned\nIterable iterates over all elements of <code>this</code>.</p>\n<p>As long as the iterator's elements satisfy <a>dart-collection.LinkedHashSet.skipWhile.test</a> they are\ndiscarded. Once an element does not satisfy the <a>dart-collection.LinkedHashSet.skipWhile.test</a> the iterator stops\ntesting and uses every later element unconditionally. That is, the elements\nof the returned Iterable are the elements of <code>this</code> starting from the\nfirst element that does not satisfy <a>dart-collection.LinkedHashSet.skipWhile.test</a>.</p>","commentFrom":"dart-core.Iterable.skipWhile","inheritedFrom":"dart-core.IterableBase.skipWhile","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.int","inner":[]}]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"take":{"name":"take","qualifiedName":"dart-collection.LinkedHashSet.take","comment":"<p>Returns an <a>dart-core.Iterable</a> with at most <a>dart-collection.LinkedHashSet.take.n</a> elements.</p>\n<p>The returned <a>dart-core.Iterable</a> may contain fewer than <a>dart-collection.LinkedHashSet.take.n</a> elements, if <code>this</code>\ncontains fewer than <a>dart-collection.LinkedHashSet.take.n</a> elements.</p>\n<p>It is an error if <a>dart-collection.LinkedHashSet.take.n</a> is negative.</p>","commentFrom":"dart-core.Iterable.take","inheritedFrom":"dart-core.IterableBase.take","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.int","inner":[]}]}],"parameters":{"n":{"name":"n","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"takeWhile":{"name":"takeWhile","qualifiedName":"dart-collection.LinkedHashSet.takeWhile","comment":"<p>Returns an Iterable that stops once <a>dart-collection.LinkedHashSet.takeWhile.test</a> is not satisfied anymore.</p>\n<p>The filtering happens lazily. Every new Iterator of the returned\nIterable starts iterating over the elements of <code>this</code>.</p>\n<p>When the iterator encounters an element <code>e</code> that does not satisfy <a>dart-collection.LinkedHashSet.takeWhile.test</a>,\nit discards <code>e</code> and moves into the finished state. That is, it does not\nget or provide any more elements.</p>","commentFrom":"dart-core.Iterable.takeWhile","inheritedFrom":"dart-core.IterableBase.takeWhile","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.int","inner":[]}]}],"parameters":{"test":{"name":"test","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"toList":{"name":"toList","qualifiedName":"dart-collection.LinkedHashSet.toList","comment":"<p>Creates a <a>dart-core.List</a> containing the elements of this <a>dart-core.Iterable</a>.</p>\n<p>The elements are in iteration order. The list is fixed-length\nif <a>dart-collection.LinkedHashSet.toList.growable</a> is false.</p>","commentFrom":"dart-core.Iterable.toList","inheritedFrom":"dart-core.IterableBase.toList","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"parameters":{"growable":{"name":"growable","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]}},"annotations":[]},"toSet":{"name":"toSet","qualifiedName":"dart-collection.LinkedHashSet.toSet","comment":"<p>Creates a <a>dart-core.Set</a> containing the elements of this <a>dart-core.Iterable</a>.</p>","commentFrom":"dart-core.Iterable.toSet","inheritedFrom":"dart-core.IterableBase.toSet","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Set","inner":[{"outer":"dart-core.int","inner":[]}]}],"parameters":{},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-collection.LinkedHashSet.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"union":{"name":"union","qualifiedName":"dart-collection.LinkedHashSet.union","comment":"<p>Returns a new set which contains all the elements of this set and <a>dart-collection.LinkedHashSet.union.other</a>.</p>\n<p>That is, the returned set contains all the elements of this <a>dart-core.Set</a> and\nall the elements of <a>dart-collection.LinkedHashSet.union.other</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Set.union","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Set","inner":[{"outer":"dart-core.Set.E","inner":[]}]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Set","inner":[{"outer":"dart-core.Set.E","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"where":{"name":"where","qualifiedName":"dart-collection.LinkedHashSet.where","comment":"<p>Returns a lazy <a>dart-core.Iterable</a> with all elements that satisfy the\npredicate test.</p>\n<p>This method returns a view of the mapped elements. As long as the\nreturned <a>dart-core.Iterable</a> is not iterated over, the supplied function test will\nnot be invoked. Iterating will not cache results, and thus iterating\nmultiple times over the returned <a>dart-core.Iterable</a> will invoke the supplied\nfunction test multiple times on the same element.</p>","commentFrom":"dart-core.Iterable.where","inheritedFrom":"dart-core.IterableBase.where","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.int","inner":[]}]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"element":{"name":"element","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.IterableBase.E","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]}}},"annotations":[],"generics":{"E":{"name":"E","type":"dart.core.Object"}}}