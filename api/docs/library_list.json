{"libraries":[{"packageName":"","name":"dart-async","qualifiedName":"dart-async","preview":"<p>Support for asynchronous programming,\nwith classes such as Future and Stream.</p>"},{"packageName":"","name":"dart-collection","qualifiedName":"dart-collection","preview":"<p>Classes and utilities that supplement the collection support in dart:core.</p>"},{"packageName":"","name":"dart-convert","qualifiedName":"dart-convert","preview":"<p>Encoders and decoders for converting between different data representations,\nincluding JSON and UTF-8.</p>"},{"packageName":"","name":"dart-core","qualifiedName":"dart-core","preview":"<p>Built-in types, collections,\nand other core functionality for every Dart program.</p>"},{"packageName":"","name":"dart-dom-html","qualifiedName":"dart-dom-html","preview":"<p>HTML elements and other resources for web-based applications that need to\ninteract with the browser and the DOM (Document Object Model).</p>"},{"packageName":"","name":"dart-dom-indexed_db","qualifiedName":"dart-dom-indexed_db","preview":"<p>A client-side key-value store with support for indexes.</p>"},{"packageName":"","name":"dart-dom-svg","qualifiedName":"dart-dom-svg","preview":"<p>Scalable Vector Graphics:\nTwo-dimensional vector graphics with support for events and animation.</p>"},{"packageName":"","name":"dart-dom-web_audio","qualifiedName":"dart-dom-web_audio","preview":"<p>High-fidelity audio programming in the browser.</p>"},{"packageName":"","name":"dart-dom-web_gl","qualifiedName":"dart-dom-web_gl","preview":"<p>3D programming in the browser.</p>"},{"packageName":"","name":"dart-dom-web_sql","qualifiedName":"dart-dom-web_sql","preview":"<p>An API for storing data in the browser that can be queried with SQL.</p>"},{"packageName":"","name":"dart-io","qualifiedName":"dart-io","preview":"<p>File, socket, HTTP, and other I/O support for server applications.</p>"},{"packageName":"","name":"dart-isolate","qualifiedName":"dart-isolate","preview":"<p>Concurrent programming using <em>isolates</em>:\nindependent workers that are similar to threads\nbut don't share memory,\ncommunicating only via messages.</p>"},{"packageName":"","name":"dart-js","qualifiedName":"dart-js","preview":"<p>Support for interoperating with JavaScript.</p>"},{"packageName":"","name":"dart-math","qualifiedName":"dart-math","preview":"<p>Mathematical constants and functions, plus a random number generator.</p>"},{"packageName":"","name":"dart-mirrors","qualifiedName":"dart-mirrors","preview":"<p>Basic reflection in Dart,\nwith support for introspection and dynamic evaluation.</p>"},{"packageName":"","name":"dart-profiler","qualifiedName":"dart-profiler"},{"packageName":"","name":"dart-typed_data","qualifiedName":"dart-typed_data","preview":"<p>Specialized integers and floating point numbers,\nwith SIMD support and efficient lists.</p>"},{"packageName":"bignum","name":"bignum","qualifiedName":"bignum/bignum","packageIntro":"<h1>dart-bignum</h1>\n<p>BigInteger is under construction. </p>\n<h2>Getting Started</h2>\n<p>Create a Dart project and add a <strong>pubspec.yaml</strong> file to it</p>\n<h4>pub.dartlang.org</h4>\n<pre><code>dependencies:\n  bignum: any\n</code></pre>\n<h4>git</h4>\n<pre><code>dependencies:\n  bignum:\n    git: git://github.com/Dartist/dart-bignum.git\n</code></pre>\n<p>and run <strong>pub install</strong> to install <strong>bignum</strong> (including its dependencies). Now add import</p>\n<pre><code>import 'package:bignum/bignum.dart';\n</code></pre>\n<h3>Example</h3>\n<h4>Code</h4>\n<pre><code>import 'package:bignum/bignum.dart';\nvoid main() {\n  BigInteger x = new BigInteger(\"12341234123412341234\");\n  BigInteger y = new BigInteger(\"100\");\n  var z = x * y * x;\n  print(\"base 10: z = ${z.toString()}\");\n  print(\"base 16: z = ${z.toString(16)}\");\n  print(\"base 2: z = ${z.toString(2)}\");\n}\n</code></pre>\n<h4>Output</h4>\n<pre><code>base 10: z = 15230605968887717854389148085725664275600\nbase 16: z = 2cc23c02bae6a6051a5ce673189c3a6c90\nbase 2: z = 10110011000010001111000000001010111010111001101010011000000101000110100101110011100110011100110001100010011100001110100110110010010000\n</code></pre>\n<h3>Sample</h3>\n<p><a href=\"example/Tobase/tobase.html\">Tobase</a>. The sample currently has known issues with bitwise operators. </p>\n<h3>Caveats</h3>\n<p>Currently few known bugs exist while compiling from dart2js. One is working with bitwise operators, the internal implementation of shift operators with dart2js does not handle the same way as the VM. Most of this code was ported from v8 <a href=\"http://goo.gl/jTEfH\">benchmark suite</a>. <a href=\"http://www-cs-students.stanford.edu/~tjw/jsbn/\">Tom Wu</a> is to thank for the core javascript implementation and the v8 team for optimizations on different javascript virtual machines. </p>\n<h3>Bugs &amp; Testing</h3>\n<p>Please feel free to add <a href=\"https://github.com/financeCoding/dart-bignum/issues\">issues</a> on github issue tracker, we would like to provide a solid library for the community to use. </p>\n<h3>References</h3><ul><li><a href=\"http://biginteger.codeplex.com/\">BigInteger C#</a></li><li><a href=\"http://developer.classpath.org/doc/java/math/BigInteger-source.html\">BigInteger Java</a></li><li><a href=\"http://libtom.org/?page=features&amp;newsitems=5&amp;whatfile=ltm\">LibTomMath</a></li><li><a href=\"https://github.com/jtobey/javascript-bignum\">javascript-bignum</a></li><li><a href=\"http://www.leemon.com/crypto/BigInt.js\">BigInt.js</a></li><li><a href=\"http://www.tc.umn.edu/~ringx004/mapm-main.html\">MAPM</a></li><li><a href=\"http://code.google.com/p/v8/source/browse/branches/bleeding_edge/benchmarks/crypto.js\">crypto.js</a></li></ul>"},{"packageName":"cipher","name":"cipher","qualifiedName":"cipher/cipher","preview":"<p>This is the main entry point to the cipher library API. It includes libraries cipher.api (which comprises the whole API\nspecification) and cipher.impl.parameters (which defines CipherParameters to be used with provided implementations).\n.</p>","packageIntro":"<h1>cipher</h1>\n<p>A Dart library for encryption and decryption. As of today, most of the classes \nare ports of Bouncy Castle from Java to Dart. The porting is almost always \ndirect except for some classes that had been added to ease the use of low level \ndata.</p>\n<p>To make sure nothing fails, tests and benchmarks for every algorithm are \nprovided. The expected results are taken from the Bouncy Castle Java version \nand also from standards, and matched against the results got from cipher.</p>\n<p>As of the last release, the following algorithms are implemented:</p>\n<p><strong>Block ciphers:</strong></p><ul><li>AES</li></ul>\n<p><strong>Asymmetric block ciphers:</strong></p><ul><li>RSA</li></ul>\n<p><strong>Stream ciphers:</strong></p><ul><li>Salsa20</li></ul>\n<p><strong>Block cipher modes of operation:</strong></p><ul><li>CBC (Cipher Block Chaining mode)</li><li>CFB (Cipher Feedback mode)</li><li>ECB (Electronic Code Book mode)</li><li>GCTR (GOST 28147 OFB counter mode)</li><li>OFB (Output FeedBack mode)</li><li>CTR (Counter mode)</li></ul>\n<p><strong>Paddings:</strong></p><ul><li>PKCS7 </li></ul>\n<p><strong>Digests:</strong></p><ul><li>MD2</li><li>MD4</li><li>MD5</li><li>RIPEMD-128</li><li>RIPEMD-160</li><li>RIPEMD-256</li><li>RIPEMD-320</li><li>SHA-1</li><li>SHA-224</li><li>SHA-256</li><li>SHA-3</li><li>SHA-384</li><li>SHA-512</li><li>SHA-512/t</li><li>Tiger</li><li>Whirlpool</li></ul>\n<p><strong>MACs:</strong></p><ul><li>HMAC</li></ul>\n<p><strong>Signatures:</strong></p><ul><li>ECDSA</li><li>RSA</li></ul>\n<p><strong>Password based key derivators:</strong></p><ul><li>PBKDF2</li><li>scrypt</li></ul>\n<p><strong>Asymmetric key generators:</strong></p><ul><li>ECDSA</li><li>RSA</li></ul>\n<p><strong>Entropy sources (true RNGs):</strong></p><ul><li>URL based (can be used, for example, with random.org)</li><li>File based (can be used, for example, with /dev/random)</li></ul>\n<p><strong>Secure PRNGs:</strong></p><ul><li>Based on block cipher in CTR mode</li><li>Based on block cipher in CTR mode with auto reseed (for forward security)</li></ul>"},{"packageName":"cipher","name":"cipher-api","qualifiedName":"cipher/cipher-api","preview":"<p>This is the API specification library for the cipher project.</p>","packageIntro":"<h1>cipher</h1>\n<p>A Dart library for encryption and decryption. As of today, most of the classes \nare ports of Bouncy Castle from Java to Dart. The porting is almost always \ndirect except for some classes that had been added to ease the use of low level \ndata.</p>\n<p>To make sure nothing fails, tests and benchmarks for every algorithm are \nprovided. The expected results are taken from the Bouncy Castle Java version \nand also from standards, and matched against the results got from cipher.</p>\n<p>As of the last release, the following algorithms are implemented:</p>\n<p><strong>Block ciphers:</strong></p><ul><li>AES</li></ul>\n<p><strong>Asymmetric block ciphers:</strong></p><ul><li>RSA</li></ul>\n<p><strong>Stream ciphers:</strong></p><ul><li>Salsa20</li></ul>\n<p><strong>Block cipher modes of operation:</strong></p><ul><li>CBC (Cipher Block Chaining mode)</li><li>CFB (Cipher Feedback mode)</li><li>ECB (Electronic Code Book mode)</li><li>GCTR (GOST 28147 OFB counter mode)</li><li>OFB (Output FeedBack mode)</li><li>CTR (Counter mode)</li></ul>\n<p><strong>Paddings:</strong></p><ul><li>PKCS7 </li></ul>\n<p><strong>Digests:</strong></p><ul><li>MD2</li><li>MD4</li><li>MD5</li><li>RIPEMD-128</li><li>RIPEMD-160</li><li>RIPEMD-256</li><li>RIPEMD-320</li><li>SHA-1</li><li>SHA-224</li><li>SHA-256</li><li>SHA-3</li><li>SHA-384</li><li>SHA-512</li><li>SHA-512/t</li><li>Tiger</li><li>Whirlpool</li></ul>\n<p><strong>MACs:</strong></p><ul><li>HMAC</li></ul>\n<p><strong>Signatures:</strong></p><ul><li>ECDSA</li><li>RSA</li></ul>\n<p><strong>Password based key derivators:</strong></p><ul><li>PBKDF2</li><li>scrypt</li></ul>\n<p><strong>Asymmetric key generators:</strong></p><ul><li>ECDSA</li><li>RSA</li></ul>\n<p><strong>Entropy sources (true RNGs):</strong></p><ul><li>URL based (can be used, for example, with random.org)</li><li>File based (can be used, for example, with /dev/random)</li></ul>\n<p><strong>Secure PRNGs:</strong></p><ul><li>Based on block cipher in CTR mode</li><li>Based on block cipher in CTR mode with auto reseed (for forward security)</li></ul>"},{"packageName":"collection","name":"dart-pkg-collection","qualifiedName":"collection/dart-pkg-collection","preview":"<p>Exports all the individual parts of the collection-helper library.</p>","packageIntro":"<p>Helper libraries for working with collections.</p>\n<p>The <code>collection</code> package contains a number of separate libraries\nwith utility functions and classes that makes working with collections easier.</p>\n<h2>Using</h2>\n<p>The <code>collection</code> package can be imported as separate libraries, or\nin totality:</p>\n<pre><code>import 'package:collection/algorithms.dart';\nimport 'package:collection/equality.dart';\nimport 'package:collection/iterable_zip.dart';\nimport 'package:collection/priority_queue.dart';\nimport 'package:collection/wrappers.dart';\n</code></pre>\n<p>or</p>\n<pre><code>import 'package:collection/collection.dart';\n</code></pre>\n<h2>Algorithms</h2>\n<p>The algorithms library contains functions that operate on lists.</p>\n<p>It contains ways to shuffle a <code>List</code>, do binary search on a sorted <code>List</code>, and\nvarious sorting algorithms.</p>\n<h2>Equality</h2>\n<p>The equality library gives a way to specify equality of elements and\ncollections.</p>\n<p>Collections in Dart have no inherent equality. Two sets are not equal, even\nif they contain exactly the same objects as elements.</p>\n<p>The equality library provides a way to say define such an equality. In this\ncase, for example, <code>const SetEquality(const IdentityEquality())</code> is an equality\nthat considers two sets equal exactly if they contain identical elements.</p>\n<p>The library provides ways to define equalities on <code>Iterable</code>s, <code>List</code>s, <code>Set</code>s,\nand <code>Map</code>s, as well as combinations of these, such as:</p>\n<pre><code>const MapEquality(const IdentityEquality(), const ListEquality());\n</code></pre>\n<p>This equality considers maps equal if they have identical keys, and the\ncorresponding values are lists with equal (<code>operator==</code>) values.</p>\n<h2>Iterable Zip</h2>\n<p>Utilities for \"zipping\" a list of iterables into an iterable of lists.</p>\n<h2>Priority Queue</h2>\n<p>An interface and implemention of a priority queue.</p>\n<h2>Wrappers</h2>\n<p>The wrappers library contains classes that \"wrap\" a collection.</p>\n<p>A wrapper class contains an object of the same type, and it forwards all\nmethods to the wrapped object.</p>\n<p>Wrapper classes can be used in various ways, for example to restrict the type\nof an object to that of a supertype, or to change the behavior of selected\nfunctions on an existing object.</p>"},{"packageName":"collection","name":"dart-pkg-collection-algorithms","qualifiedName":"collection/dart-pkg-collection-algorithms","preview":"<p>Operations on collections.</p>","packageIntro":"<p>Helper libraries for working with collections.</p>\n<p>The <code>collection</code> package contains a number of separate libraries\nwith utility functions and classes that makes working with collections easier.</p>\n<h2>Using</h2>\n<p>The <code>collection</code> package can be imported as separate libraries, or\nin totality:</p>\n<pre><code>import 'package:collection/algorithms.dart';\nimport 'package:collection/equality.dart';\nimport 'package:collection/iterable_zip.dart';\nimport 'package:collection/priority_queue.dart';\nimport 'package:collection/wrappers.dart';\n</code></pre>\n<p>or</p>\n<pre><code>import 'package:collection/collection.dart';\n</code></pre>\n<h2>Algorithms</h2>\n<p>The algorithms library contains functions that operate on lists.</p>\n<p>It contains ways to shuffle a <code>List</code>, do binary search on a sorted <code>List</code>, and\nvarious sorting algorithms.</p>\n<h2>Equality</h2>\n<p>The equality library gives a way to specify equality of elements and\ncollections.</p>\n<p>Collections in Dart have no inherent equality. Two sets are not equal, even\nif they contain exactly the same objects as elements.</p>\n<p>The equality library provides a way to say define such an equality. In this\ncase, for example, <code>const SetEquality(const IdentityEquality())</code> is an equality\nthat considers two sets equal exactly if they contain identical elements.</p>\n<p>The library provides ways to define equalities on <code>Iterable</code>s, <code>List</code>s, <code>Set</code>s,\nand <code>Map</code>s, as well as combinations of these, such as:</p>\n<pre><code>const MapEquality(const IdentityEquality(), const ListEquality());\n</code></pre>\n<p>This equality considers maps equal if they have identical keys, and the\ncorresponding values are lists with equal (<code>operator==</code>) values.</p>\n<h2>Iterable Zip</h2>\n<p>Utilities for \"zipping\" a list of iterables into an iterable of lists.</p>\n<h2>Priority Queue</h2>\n<p>An interface and implemention of a priority queue.</p>\n<h2>Wrappers</h2>\n<p>The wrappers library contains classes that \"wrap\" a collection.</p>\n<p>A wrapper class contains an object of the same type, and it forwards all\nmethods to the wrapped object.</p>\n<p>Wrapper classes can be used in various ways, for example to restrict the type\nof an object to that of a supertype, or to change the behavior of selected\nfunctions on an existing object.</p>"},{"packageName":"collection","name":"dart-pkg-collection-equality","qualifiedName":"collection/dart-pkg-collection-equality","preview":"<p>Defines equality relations on collections.</p>","packageIntro":"<p>Helper libraries for working with collections.</p>\n<p>The <code>collection</code> package contains a number of separate libraries\nwith utility functions and classes that makes working with collections easier.</p>\n<h2>Using</h2>\n<p>The <code>collection</code> package can be imported as separate libraries, or\nin totality:</p>\n<pre><code>import 'package:collection/algorithms.dart';\nimport 'package:collection/equality.dart';\nimport 'package:collection/iterable_zip.dart';\nimport 'package:collection/priority_queue.dart';\nimport 'package:collection/wrappers.dart';\n</code></pre>\n<p>or</p>\n<pre><code>import 'package:collection/collection.dart';\n</code></pre>\n<h2>Algorithms</h2>\n<p>The algorithms library contains functions that operate on lists.</p>\n<p>It contains ways to shuffle a <code>List</code>, do binary search on a sorted <code>List</code>, and\nvarious sorting algorithms.</p>\n<h2>Equality</h2>\n<p>The equality library gives a way to specify equality of elements and\ncollections.</p>\n<p>Collections in Dart have no inherent equality. Two sets are not equal, even\nif they contain exactly the same objects as elements.</p>\n<p>The equality library provides a way to say define such an equality. In this\ncase, for example, <code>const SetEquality(const IdentityEquality())</code> is an equality\nthat considers two sets equal exactly if they contain identical elements.</p>\n<p>The library provides ways to define equalities on <code>Iterable</code>s, <code>List</code>s, <code>Set</code>s,\nand <code>Map</code>s, as well as combinations of these, such as:</p>\n<pre><code>const MapEquality(const IdentityEquality(), const ListEquality());\n</code></pre>\n<p>This equality considers maps equal if they have identical keys, and the\ncorresponding values are lists with equal (<code>operator==</code>) values.</p>\n<h2>Iterable Zip</h2>\n<p>Utilities for \"zipping\" a list of iterables into an iterable of lists.</p>\n<h2>Priority Queue</h2>\n<p>An interface and implemention of a priority queue.</p>\n<h2>Wrappers</h2>\n<p>The wrappers library contains classes that \"wrap\" a collection.</p>\n<p>A wrapper class contains an object of the same type, and it forwards all\nmethods to the wrapped object.</p>\n<p>Wrapper classes can be used in various ways, for example to restrict the type\nof an object to that of a supertype, or to change the behavior of selected\nfunctions on an existing object.</p>"},{"packageName":"collection","name":"dart-pkg-collection-iterable_zip","qualifiedName":"collection/dart-pkg-collection-iterable_zip","preview":"<p>Zipping multiple iterables into one iterable of tuples of values.</p>","packageIntro":"<p>Helper libraries for working with collections.</p>\n<p>The <code>collection</code> package contains a number of separate libraries\nwith utility functions and classes that makes working with collections easier.</p>\n<h2>Using</h2>\n<p>The <code>collection</code> package can be imported as separate libraries, or\nin totality:</p>\n<pre><code>import 'package:collection/algorithms.dart';\nimport 'package:collection/equality.dart';\nimport 'package:collection/iterable_zip.dart';\nimport 'package:collection/priority_queue.dart';\nimport 'package:collection/wrappers.dart';\n</code></pre>\n<p>or</p>\n<pre><code>import 'package:collection/collection.dart';\n</code></pre>\n<h2>Algorithms</h2>\n<p>The algorithms library contains functions that operate on lists.</p>\n<p>It contains ways to shuffle a <code>List</code>, do binary search on a sorted <code>List</code>, and\nvarious sorting algorithms.</p>\n<h2>Equality</h2>\n<p>The equality library gives a way to specify equality of elements and\ncollections.</p>\n<p>Collections in Dart have no inherent equality. Two sets are not equal, even\nif they contain exactly the same objects as elements.</p>\n<p>The equality library provides a way to say define such an equality. In this\ncase, for example, <code>const SetEquality(const IdentityEquality())</code> is an equality\nthat considers two sets equal exactly if they contain identical elements.</p>\n<p>The library provides ways to define equalities on <code>Iterable</code>s, <code>List</code>s, <code>Set</code>s,\nand <code>Map</code>s, as well as combinations of these, such as:</p>\n<pre><code>const MapEquality(const IdentityEquality(), const ListEquality());\n</code></pre>\n<p>This equality considers maps equal if they have identical keys, and the\ncorresponding values are lists with equal (<code>operator==</code>) values.</p>\n<h2>Iterable Zip</h2>\n<p>Utilities for \"zipping\" a list of iterables into an iterable of lists.</p>\n<h2>Priority Queue</h2>\n<p>An interface and implemention of a priority queue.</p>\n<h2>Wrappers</h2>\n<p>The wrappers library contains classes that \"wrap\" a collection.</p>\n<p>A wrapper class contains an object of the same type, and it forwards all\nmethods to the wrapped object.</p>\n<p>Wrapper classes can be used in various ways, for example to restrict the type\nof an object to that of a supertype, or to change the behavior of selected\nfunctions on an existing object.</p>"},{"packageName":"collection","name":"dart-pkg-collection-priority_queue","qualifiedName":"collection/dart-pkg-collection-priority_queue","packageIntro":"<p>Helper libraries for working with collections.</p>\n<p>The <code>collection</code> package contains a number of separate libraries\nwith utility functions and classes that makes working with collections easier.</p>\n<h2>Using</h2>\n<p>The <code>collection</code> package can be imported as separate libraries, or\nin totality:</p>\n<pre><code>import 'package:collection/algorithms.dart';\nimport 'package:collection/equality.dart';\nimport 'package:collection/iterable_zip.dart';\nimport 'package:collection/priority_queue.dart';\nimport 'package:collection/wrappers.dart';\n</code></pre>\n<p>or</p>\n<pre><code>import 'package:collection/collection.dart';\n</code></pre>\n<h2>Algorithms</h2>\n<p>The algorithms library contains functions that operate on lists.</p>\n<p>It contains ways to shuffle a <code>List</code>, do binary search on a sorted <code>List</code>, and\nvarious sorting algorithms.</p>\n<h2>Equality</h2>\n<p>The equality library gives a way to specify equality of elements and\ncollections.</p>\n<p>Collections in Dart have no inherent equality. Two sets are not equal, even\nif they contain exactly the same objects as elements.</p>\n<p>The equality library provides a way to say define such an equality. In this\ncase, for example, <code>const SetEquality(const IdentityEquality())</code> is an equality\nthat considers two sets equal exactly if they contain identical elements.</p>\n<p>The library provides ways to define equalities on <code>Iterable</code>s, <code>List</code>s, <code>Set</code>s,\nand <code>Map</code>s, as well as combinations of these, such as:</p>\n<pre><code>const MapEquality(const IdentityEquality(), const ListEquality());\n</code></pre>\n<p>This equality considers maps equal if they have identical keys, and the\ncorresponding values are lists with equal (<code>operator==</code>) values.</p>\n<h2>Iterable Zip</h2>\n<p>Utilities for \"zipping\" a list of iterables into an iterable of lists.</p>\n<h2>Priority Queue</h2>\n<p>An interface and implemention of a priority queue.</p>\n<h2>Wrappers</h2>\n<p>The wrappers library contains classes that \"wrap\" a collection.</p>\n<p>A wrapper class contains an object of the same type, and it forwards all\nmethods to the wrapped object.</p>\n<p>Wrapper classes can be used in various ways, for example to restrict the type\nof an object to that of a supertype, or to change the behavior of selected\nfunctions on an existing object.</p>"},{"packageName":"collection","name":"dart-pkg-collection-wrappers","qualifiedName":"collection/dart-pkg-collection-wrappers","preview":"<p>Delegating wrappers for <a>dart-core.Iterable</a>, <a>dart-core.List</a>, <a>dart-core.Set</a>, <a>collection/dart-pkg-collection-wrappers.Queue</a> and <a>dart-core.Map</a>.</p>","packageIntro":"<p>Helper libraries for working with collections.</p>\n<p>The <code>collection</code> package contains a number of separate libraries\nwith utility functions and classes that makes working with collections easier.</p>\n<h2>Using</h2>\n<p>The <code>collection</code> package can be imported as separate libraries, or\nin totality:</p>\n<pre><code>import 'package:collection/algorithms.dart';\nimport 'package:collection/equality.dart';\nimport 'package:collection/iterable_zip.dart';\nimport 'package:collection/priority_queue.dart';\nimport 'package:collection/wrappers.dart';\n</code></pre>\n<p>or</p>\n<pre><code>import 'package:collection/collection.dart';\n</code></pre>\n<h2>Algorithms</h2>\n<p>The algorithms library contains functions that operate on lists.</p>\n<p>It contains ways to shuffle a <code>List</code>, do binary search on a sorted <code>List</code>, and\nvarious sorting algorithms.</p>\n<h2>Equality</h2>\n<p>The equality library gives a way to specify equality of elements and\ncollections.</p>\n<p>Collections in Dart have no inherent equality. Two sets are not equal, even\nif they contain exactly the same objects as elements.</p>\n<p>The equality library provides a way to say define such an equality. In this\ncase, for example, <code>const SetEquality(const IdentityEquality())</code> is an equality\nthat considers two sets equal exactly if they contain identical elements.</p>\n<p>The library provides ways to define equalities on <code>Iterable</code>s, <code>List</code>s, <code>Set</code>s,\nand <code>Map</code>s, as well as combinations of these, such as:</p>\n<pre><code>const MapEquality(const IdentityEquality(), const ListEquality());\n</code></pre>\n<p>This equality considers maps equal if they have identical keys, and the\ncorresponding values are lists with equal (<code>operator==</code>) values.</p>\n<h2>Iterable Zip</h2>\n<p>Utilities for \"zipping\" a list of iterables into an iterable of lists.</p>\n<h2>Priority Queue</h2>\n<p>An interface and implemention of a priority queue.</p>\n<h2>Wrappers</h2>\n<p>The wrappers library contains classes that \"wrap\" a collection.</p>\n<p>A wrapper class contains an object of the same type, and it forwards all\nmethods to the wrapped object.</p>\n<p>Wrapper classes can be used in various ways, for example to restrict the type\nof an object to that of a supertype, or to change the behavior of selected\nfunctions on an existing object.</p>"},{"packageName":"crypto","name":"crypto","qualifiedName":"crypto/crypto","preview":"<p>Cryptographic algorithms, with support for hash functions such as\nSHA-1, SHA-256, HMAC, and MD5.</p>","packageIntro":""},{"packageName":"fixnum","name":"fixnum","qualifiedName":"fixnum/fixnum","preview":"<p>Signed 32- and 64-bit integer support.</p>","packageIntro":"<h1>fixnum</h1>\n<p>A fixed-size integer library for Dart.</p>\n<hr />\n<p>The fixnum package provides data types for signed 32- and 64-bit integers.\nThe integer implementations in this library are designed to work identically\nwhether executed on the Dart VM or compiled to JavaScript.</p>\n<h2>Installing</h2>\n<p>Use <a href=\"http://pub.dartlang.org\">pub</a> to install this package. Add the following\nto your <code>pubspec.yaml</code> file:</p>\n<pre><code>dependencies:\n  fixnum: any\n</code></pre>\n<p>Then run <code>pub install</code>.</p>\n<p>For more information, see the\n<a href=\"http://pub.dartlang.org/packages/fixnum\">fixnum package on pub.dartlang.org</a>.</p>"},{"packageName":"force","name":"dart_force_client_lib","qualifiedName":"force/dart_force_client_lib","packageIntro":""},{"packageName":"force","name":"dart_force_common_lib","qualifiedName":"force/dart_force_common_lib","packageIntro":""},{"packageName":"force","name":"dart_force_server_lib","qualifiedName":"force/dart_force_server_lib","packageIntro":""},{"packageName":"force_it","name":"force_it","qualifiedName":"force_it/force_it","packageIntro":""},{"packageName":"forcemirrors","name":"dart_force_mirrors_lib","qualifiedName":"forcemirrors/dart_force_mirrors_lib","packageIntro":""},{"packageName":"forcemvc","name":"dart_force_mvc_lib","qualifiedName":"forcemvc/dart_force_mvc_lib","packageIntro":""},{"packageName":"ghpages_generator","name":"ghpages_generator","qualifiedName":"ghpages_generator/ghpages_generator","packageIntro":"<h1>Dart Gh-Pages Generator</h1>\n<p>This project allows to create/update the <em>gh-pages</em> branch based on <em>examples</em>, <em>dartdoc</em>,\n<em>docs</em>, <em>web</em> and/or custom files.</p>\n<p>Basically a new commit is done in the <em>gh-pages</em> branch with updated files\ngenerated. Then you only need to <em>push</em> this branch on <em>github</em>.</p>\n<h2>Usage</h2><ol><li>Add a <code>dev_dependency</code> in your <code>pubspec.yaml</code> to <em>ghpages</em>generator_.</li><li>Create a Dart script to define how is built you ghpages.</li></ol>\n<h3>create dartdoc</h3>\n<p>Here's how is generated <a href=\"http://a14n.github.io/dart-ghpages-generator\">gh-pages for this package</a> :</p>\n<pre class=\"dart\"><code>import 'package:ghpages_generator/ghpages_generator.dart' as gh;\n\nmain() {\n  new gh.Generator()\n      ..setDartDoc(['lib/ghpages_generator.dart'], includeSdk: false,\n          excludedLibs: ['path'], startPage: 'ghpages_generator')\n      ..generate(doCustomTask: gh.moveDartDocAtRoot);\n}\n</code></pre>\n<h3>publish web build</h3>\n<p>If you simply want to update the gh-pages with the result of <code>pub build web</code> you\ncan run the following program :</p>\n<pre class=\"dart\"><code>import 'package:ghpages_generator/ghpages_generator.dart' as gh;\n\nmain() {\n  gh.updateWithWebOnly();\n}\n</code></pre>\n<h2>Actions</h2>\n<p>Here's the available actions :</p><ul><li>generate the <em>dartdoc</em> with <code>setDartDoc</code></li><li>compile and deploy the <em>examples</em> with <code>setExamples</code></li><li>add the <code>docs</code> directory with <code>withDocs</code></li><li>\n<p>add static files with <code>templateDir</code> : all files in the template directory are\npasted to the <em>gh-pages</em> branch</p></li></ul>\n<h2>License</h2>\n<p>Apache 2.0</p>"},{"packageName":"http","name":"http","qualifiedName":"http/http","preview":"<p>A composable, <a>http/dart-async.Future</a>-based library for making HTTP requests.</p>","packageIntro":"<h1>http</h1>\n<p>A composable, Future-based library for making HTTP requests.</p>\n<p>This package contains a set of high-level functions and classes that make it\neasy to consume HTTP resources.</p>\n<p><strong>NOTE:</strong> This package currently only works for\nserver-side or command-line Dart applications. In other words, if the app\nimports <code>dart:io</code>, it can use this package.</p>\n<h2>Using</h2>\n<p>Please see the <a href=\"https://api.dartlang.org/docs/channels/dev/latest/http.html\">API docs</a> for explanations and examples.</p>\n<h2>Filing issues</h2>\n<p>Please file issues for the http package at <a href=\"http://dartbug.com/new\">http://dartbug.com/new</a>.</p>"},{"packageName":"http","name":"http-testing","qualifiedName":"http/http-testing","preview":"<p>This library contains testing classes for the HTTP library.</p>","packageIntro":"<h1>http</h1>\n<p>A composable, Future-based library for making HTTP requests.</p>\n<p>This package contains a set of high-level functions and classes that make it\neasy to consume HTTP resources.</p>\n<p><strong>NOTE:</strong> This package currently only works for\nserver-side or command-line Dart applications. In other words, if the app\nimports <code>dart:io</code>, it can use this package.</p>\n<h2>Using</h2>\n<p>Please see the <a href=\"https://api.dartlang.org/docs/channels/dev/latest/http.html\">API docs</a> for explanations and examples.</p>\n<h2>Filing issues</h2>\n<p>Please file issues for the http package at <a href=\"http://dartbug.com/new\">http://dartbug.com/new</a>.</p>"},{"packageName":"http_server","name":"http_server","qualifiedName":"http_server/http_server","preview":"<p>A library for serving HTTP requests and resources.</p>","packageIntro":"<h1>http_server</h1>\n<p>This package contains a set of high-level classes that, together with\nHttpServer, makes is easy to provide content through HTTP servers.</p>\n<p><strong>NOTE:</strong> This package currently only works for\nserver-side or command-line Dart applications. In other words, if the app\nimports <code>dart:io</code>, it can use this package.</p>\n<h2>Using</h2>\n<p>Please see the <a href=\"https://api.dartlang.org/docs/channels/stable/latest/http_server.html\">API docs</a> for explanations and examples.</p>\n<h2>Filing issues</h2>\n<p>Please file issues for the http package at <a href=\"http://dartbug.com/new\">http://dartbug.com/new</a>.</p>"},{"packageName":"logging","name":"logging","qualifiedName":"logging/logging","preview":"<p>Support for logging.</p>","packageIntro":""},{"packageName":"mime","name":"mime","qualifiedName":"mime/mime","preview":"<p>Help for working with file format identifiers\nsuch as <code>text/html</code> and <code>image/png</code>.</p>","packageIntro":""},{"packageName":"mustache4dart","name":"mustache4dart","qualifiedName":"mustache4dart/mustache4dart","packageIntro":"<h1>Mustache for the dartlang <a href=\"https://drone.io/github.com/valotas/mustache4dart/latest\"><a href=\"https://drone.io/github.com/valotas/mustache4dart/status.png\"><img alt=\"Build Status\" src=\"https://drone.io/github.com/valotas/mustache4dart/status.png\"></img></a></a></h1>\n<p>A simple implementation of <a href=\"http://mustache.github.com/\">Mustache</a> for the <a href=\"http://www.dartlang.org/\">Dart language</a>,\nwhich passes happily all the <a href=\"http://github.com/mustache/spec\">mustache specs</a>. If you want to \nhave a look at how it works, just check the <a href=\"http://github.com/valotas/mustache4dart/blob/master/test/mustache_tests.dart\">tests</a>. For more info, \njust read further.</p>\n<h2>Using it</h2>\n<p>In order to use the library, just add it to your pubspec.yalm as a dependency</p>\n<pre><code>dependencies:\n  mustache4dart: '&gt;= 1.0.0'\n</code></pre>\n<p>and you are good to go. You can use the render toplevel function to render your template.\nFor example:</p>\n<pre class=\"dart\"><code>var salutation = render('Hello {{name}}!', {'name': 'Bob'});\nprint(salutation); //shoud print Hello Bob!\n</code></pre>\n<h3>Context objects</h3>\n<p>mustache4dart will look at your given object for operators, fields or methods. For example,\nif you give the template <code>{{firstname}}</code> for rendering, mustache4dart will try the followings</p><ol><li>use the <code>[]</code> operator with <code>firstname</code> as the parameter</li><li>search for a field named <code>firstname</code></li><li>search for a getter named <code>firstname</code></li><li>search for a method named <code>firstname</code></li><li>search for a method named <code>getFirstname</code></li></ol>\n<p>in each case the first valid value will be used.</p>\n<h4>@MirrorsUsed</h4>\n<p>In order to do the stuff described above the mirror library is being used which could lead to big js files when compiling the library with dartjs. The implementation does use the <code>@MirrorsUsed</code> annotation but <a href=\"https://api.dartlang.org/apidocs/channels/stable/#dart-mirrors.MirrorsUsed\">as documented</a> this is experimental.</p>\n<p>In order to avoid the use of the mirrors package, make sure that you compile your library with <code>dart2js -DMIRRORS=false </code>. In that case though you must always make sure that your context object have a right implementation of the <code>[]</code> operator as it will be the only check made against them (from the ones described above) in order to define a value.</p>\n<h3>Partials</h3>\n<p>mustache4dart support partials but it needs somehow to know how to find a partial. You can\ndo that by providing a function that returns a template given a name:</p>\n<pre class=\"dart\"><code>String partialProvider(String partialName) =&gt; \"this is the partial with name: ${partialName}\";\nexpect(render('[{{&gt;p}}]', null, partial: partialProvider), '[this is the partial with name: p]'));\n</code></pre>\n<h3>Compiling to functions</h3>\n<p>If you have a template that you are going to reuse with different contextes you can compile\nit to a function using the toplevel function compile:</p>\n<pre class=\"dart\"><code>var salut = compile('Hello {{name}}!');\nprint(salut({'name': 'Alice'})); //should print Hello Alice!\n</code></pre>\n<h2>Running the tests</h2>\n<p>At the moment the project is under heavy development but pass all the <a href=\"http://github.com/mustache/spec\">Mustache specs</a>. \nIf you want to run the tests yourself, just do what <a href=\"https://drone.io/github.com/valotas/mustache4dart/admin\">drone.io does</a>,\nor to put it by another way, do the following:</p>\n<pre class=\"sh\"><code>git clone git://github.com/valotas/mustache4dart.git\ngit submodule init\ngit submodule update \npub install\ntest/run.sh\n</code></pre>\n<h2>Contributing</h2>\n<p>If you found a bug, just create a <a href=\"https://github.com/valotas/mustache4dart/issues/new\">new issue</a> or even better fork and issue a\npull request with you fix.</p>\n<h2>Versioning</h2>\n<p>The library will follow a <a href=\"http://semver.org/\">semantic versioning</a></p>"},{"packageName":"mustache4dart","name":"mustache_context","qualifiedName":"mustache4dart/mustache_context","packageIntro":"<h1>Mustache for the dartlang <a href=\"https://drone.io/github.com/valotas/mustache4dart/latest\"><a href=\"https://drone.io/github.com/valotas/mustache4dart/status.png\"><img alt=\"Build Status\" src=\"https://drone.io/github.com/valotas/mustache4dart/status.png\"></img></a></a></h1>\n<p>A simple implementation of <a href=\"http://mustache.github.com/\">Mustache</a> for the <a href=\"http://www.dartlang.org/\">Dart language</a>,\nwhich passes happily all the <a href=\"http://github.com/mustache/spec\">mustache specs</a>. If you want to \nhave a look at how it works, just check the <a href=\"http://github.com/valotas/mustache4dart/blob/master/test/mustache_tests.dart\">tests</a>. For more info, \njust read further.</p>\n<h2>Using it</h2>\n<p>In order to use the library, just add it to your pubspec.yalm as a dependency</p>\n<pre><code>dependencies:\n  mustache4dart: '&gt;= 1.0.0'\n</code></pre>\n<p>and you are good to go. You can use the render toplevel function to render your template.\nFor example:</p>\n<pre class=\"dart\"><code>var salutation = render('Hello {{name}}!', {'name': 'Bob'});\nprint(salutation); //shoud print Hello Bob!\n</code></pre>\n<h3>Context objects</h3>\n<p>mustache4dart will look at your given object for operators, fields or methods. For example,\nif you give the template <code>{{firstname}}</code> for rendering, mustache4dart will try the followings</p><ol><li>use the <code>[]</code> operator with <code>firstname</code> as the parameter</li><li>search for a field named <code>firstname</code></li><li>search for a getter named <code>firstname</code></li><li>search for a method named <code>firstname</code></li><li>search for a method named <code>getFirstname</code></li></ol>\n<p>in each case the first valid value will be used.</p>\n<h4>@MirrorsUsed</h4>\n<p>In order to do the stuff described above the mirror library is being used which could lead to big js files when compiling the library with dartjs. The implementation does use the <code>@MirrorsUsed</code> annotation but <a href=\"https://api.dartlang.org/apidocs/channels/stable/#dart-mirrors.MirrorsUsed\">as documented</a> this is experimental.</p>\n<p>In order to avoid the use of the mirrors package, make sure that you compile your library with <code>dart2js -DMIRRORS=false </code>. In that case though you must always make sure that your context object have a right implementation of the <code>[]</code> operator as it will be the only check made against them (from the ones described above) in order to define a value.</p>\n<h3>Partials</h3>\n<p>mustache4dart support partials but it needs somehow to know how to find a partial. You can\ndo that by providing a function that returns a template given a name:</p>\n<pre class=\"dart\"><code>String partialProvider(String partialName) =&gt; \"this is the partial with name: ${partialName}\";\nexpect(render('[{{&gt;p}}]', null, partial: partialProvider), '[this is the partial with name: p]'));\n</code></pre>\n<h3>Compiling to functions</h3>\n<p>If you have a template that you are going to reuse with different contextes you can compile\nit to a function using the toplevel function compile:</p>\n<pre class=\"dart\"><code>var salut = compile('Hello {{name}}!');\nprint(salut({'name': 'Alice'})); //should print Hello Alice!\n</code></pre>\n<h2>Running the tests</h2>\n<p>At the moment the project is under heavy development but pass all the <a href=\"http://github.com/mustache/spec\">Mustache specs</a>. \nIf you want to run the tests yourself, just do what <a href=\"https://drone.io/github.com/valotas/mustache4dart/admin\">drone.io does</a>,\nor to put it by another way, do the following:</p>\n<pre class=\"sh\"><code>git clone git://github.com/valotas/mustache4dart.git\ngit submodule init\ngit submodule update \npub install\ntest/run.sh\n</code></pre>\n<h2>Contributing</h2>\n<p>If you found a bug, just create a <a href=\"https://github.com/valotas/mustache4dart/issues/new\">new issue</a> or even better fork and issue a\npull request with you fix.</p>\n<h2>Versioning</h2>\n<p>The library will follow a <a href=\"http://semver.org/\">semantic versioning</a></p>"},{"packageName":"path","name":"path","qualifiedName":"path/path","preview":"<p>A comprehensive, cross-platform path manipulation library.</p>","packageIntro":"<p>A comprehensive, cross-platform path manipulation library for Dart.</p>\n<p>The path package provides common operations for manipulating paths:\njoining, splitting, normalizing, etc.</p>\n<p>We've tried very hard to make this library do the \"right\" thing on whatever\nplatform you run it on, including in the browser. When you use the top-level\nfunctions, it will assume the current platform's path style and work with\nthat. If you want to explicitly work with paths of a specific style, you can\nconstruct a <code>path.Context</code> for that style.</p>\n<h2>Using</h2>\n<p>The path library was designed to be imported with a prefix, though you don't\nhave to if you don't want to:</p>\n<pre><code>import 'package:path/path.dart' as path;\n</code></pre>\n<p>The most common way to use the library is through the top-level functions.\nThese manipulate path strings based on your current working directory and\nthe path style (POSIX, Windows, or URLs) of the host platform. For example:</p>\n<pre><code>path.join(\"directory\", \"file.txt\");\n</code></pre>\n<p>This calls the top-level join function to join \"directory\" and\n\"file.txt\" using the current platform's directory separator.</p>\n<p>If you want to work with paths for a specific platform regardless of the\nunderlying platform that the program is running on, you can create a\nContext and give it an explicit Style:</p>\n<pre><code>var context = new path.Context(style: Style.windows);\ncontext.join(\"directory\", \"file.txt\");\n</code></pre>\n<p>This will join \"directory\" and \"file.txt\" using the Windows path separator,\neven when the program is run on a POSIX machine.</p>\n<h2>FAQ</h2>\n<h3>Where can I use this?</h3>\n<p>Pathos runs on the Dart VM and in the browser under both dart2js and Dartium.\nUnder dart2js, it currently returns \".\" as the current working directory, while\nunder Dartium it returns the current URL.</p>\n<h3>Why doesn't this make paths first-class objects?</h3>\n<p>When you have path <em>objects</em>, then every API that takes a path has to decide if\nit accepts strings, path objects, or both.</p><ul><li>\n<p>Accepting strings is the most convenient, but then it seems weird to have\nthese path objects that aren't actually accepted by anything that needs a\npath. Once you've created a path, you have to always call <code>.toString()</code> on\nit before you can do anything useful with it.</p></li><li>\n<p>Requiring objects forces users to wrap path strings in these objects, which\nis tedious. It also means coupling that API to whatever library defines this\npath class. If there are multiple \"path\" libraries that each define their\nown path types, then any library that works with paths has to pick which one\nit uses.</p></li><li>\n<p>Taking both means you can't type your API. That defeats the purpose of\nhaving a path type: why have a type if your APIs can't annotate that they\nexpect it?</p></li></ul>\n<p>Given that, we've decided this library should simply treat paths as strings.</p>\n<h3>How cross-platform is this?</h3>\n<p>We believe this library handles most of the corner cases of Windows paths\n(POSIX paths are generally pretty straightforward):</p><ul><li>\n<p>It understands that <em>both</em> \"/\" and \"\\\" are valid path separators, not just\n\"\\\".</p></li><li>\n<p>It can accurately tell if a path is absolute based on drive-letters or UNC\nprefix.</p></li><li>\n<p>It understands that \"/foo\" is not an absolute path on Windows.</p></li><li>\n<p>It knows that \"C:\\foo\\one.txt\" and \"c:/foo\\two.txt\" are two files in the\nsame directory.</p></li></ul>\n<h3>What is a \"path\" in the browser?</h3>\n<p>If you use this package in a browser, then it considers the \"platform\" to be\nthe browser itself and uses URL strings to represent \"browser paths\".</p>"},{"packageName":"route","name":"pattern","qualifiedName":"route/pattern","preview":"<p>Pattern utilities for use with server.Router.</p>","packageIntro":"<h1>Route</h1>\n<p>Route is a client + server routing library for Dart that helps make building\nsingle-page web apps and using <code>HttpServer</code> easier.</p>\n<h2>Installation</h2>\n<p>Add this package to your pubspec.yaml file:</p>\n<pre><code>dependencies:\n  route: any\n  \n</code></pre>\n<p>Then, run <code>pub install</code> to download and link in the package.</p>\n<h2>UrlPattern</h2>\n<p>Route is built around <code>UrlPattern</code> a class that matches, parses and produces\nURLs. A <code>UrlPattern</code> is similar to a regex, but constrained so that it is\n<em>reversible</em>, given a <code>UrlPattern</code> and a set of arguments you can produce the\nURL that when parsed returns those same arguments. This is important for keeping\nthe URL space for your app flexible so that you can change a URL for a resource\nin one place and keep your app working.</p>\n<p>Route lets you use the same URL patterns for client-side and server-side\nrouting. Just define a library containing all your URLs.</p>\n<p>As an example, consider a blog with a home page and an article page. The article\nURL has the form /article/1234. We want to show articles without reloading the\npage.</p>\n<p>Example (urls.dart):</p>\n<pre class=\"dart\"><code>library urls;\n\nimport 'package:route/url_pattern.dart';\n\nfinal homeUrl = new UrlPattern(r'/');\nfinal articleUrl = new UrlPattern(r'/article/(\\d+)');\nfinal allUrls = [homeUrl, articleUrl];\n</code></pre>\n<h2>Client Routing</h2>\n<p>On the client, there is a <code>Router</code> class that associates <code>UrlPattern</code>s\nto handlers. Given a URL, the router finds a pattern that matches, and invokes\nit's handler. This is similar to\n<code>HttpServer.addRequestHandler(matcher, handler)</code> on the server. The handlers\nare then responsible for rendering the appropriate changes to the page.</p>\n<p>The <code>Router</code> can listen to <code>Window.onPopState</code> events and invoke the correct\nhandler so that the back button seamlessly works.</p>\n<p>Example (client.dart):</p>\n<pre class=\"dart\"><code>library client;\n\nimport 'package:route/client.dart';\n\nmain() {\n  var router = new Router()\n    ..addHandler(homeUrl, showHome)\n    ..addHandler(articleUrl, showArticle)\n    ..listen();\n}\n\nvoid showHome(String path) {\n  // nothing to parse from path, since there are no groups\n}\n\nvoid showArticle(String path) {\n  var articleId = articleUrl.parse(req.path)[0];\n  // show article page with loading indicator\n  // load article from server, then render article\n}\n</code></pre>\n<h2>Server Routing</h2>\n<p>On the server, route gives you a utility function to match <code>HttpRequest</code>s\nagainst <code>UrlPatterns</code>.</p>\n<pre class=\"dart\"><code>import 'urls.dart';\nimport 'package:route/server.dart';\nimport 'package:route/pattern.dart';\n\nHttpServer.bind().then((server) {\n  var router = new Router(server)\n    ..filter(matchesAny(allUrls), authFilter)\n    ..serve(homeUrl).listen(serverHome)\n    ..serve(articleUrl, method: 'GET').listen(serveArticle)\n    ..defaultStream.listen(serveNotFound);\n});\n\nFuture&lt;bool&gt; authFilter(req) {\n  return getUser(getUserIdCookie(req)).then((user) {\n    if (user != null) {\n      return true;\n    }\n    redirectToLoginPage(req);\n    return false;\n  });\n}\n\nserveArcticle(req) {\n  var articleId = articleUrl.parse(req.uri.path)[0];\n  // retrieve article data and respond\n}\n</code></pre>\n<h2>Further Goals</h2><ul><li>\n<p>Integration with Polymer so that the changing of UI views can happen\n   automatically.</p></li><li>Handling different HTTP methods to help implement REST APIs.</li><li>\n<p>Automatic generation of REST URLs from a single URL pattern, similar to Ruby\n   on Rails</p></li><li>Helpers for nested views and key-value URL schemes common with complex apps.</li><li>Done ~~Server-side routing for the dart:io v2 HttpServer~~</li><li>Done ~~IE 9 support~~</li></ul>"},{"packageName":"route","name":"route-client","qualifiedName":"route/route-client","packageIntro":"<h1>Route</h1>\n<p>Route is a client + server routing library for Dart that helps make building\nsingle-page web apps and using <code>HttpServer</code> easier.</p>\n<h2>Installation</h2>\n<p>Add this package to your pubspec.yaml file:</p>\n<pre><code>dependencies:\n  route: any\n  \n</code></pre>\n<p>Then, run <code>pub install</code> to download and link in the package.</p>\n<h2>UrlPattern</h2>\n<p>Route is built around <code>UrlPattern</code> a class that matches, parses and produces\nURLs. A <code>UrlPattern</code> is similar to a regex, but constrained so that it is\n<em>reversible</em>, given a <code>UrlPattern</code> and a set of arguments you can produce the\nURL that when parsed returns those same arguments. This is important for keeping\nthe URL space for your app flexible so that you can change a URL for a resource\nin one place and keep your app working.</p>\n<p>Route lets you use the same URL patterns for client-side and server-side\nrouting. Just define a library containing all your URLs.</p>\n<p>As an example, consider a blog with a home page and an article page. The article\nURL has the form /article/1234. We want to show articles without reloading the\npage.</p>\n<p>Example (urls.dart):</p>\n<pre class=\"dart\"><code>library urls;\n\nimport 'package:route/url_pattern.dart';\n\nfinal homeUrl = new UrlPattern(r'/');\nfinal articleUrl = new UrlPattern(r'/article/(\\d+)');\nfinal allUrls = [homeUrl, articleUrl];\n</code></pre>\n<h2>Client Routing</h2>\n<p>On the client, there is a <code>Router</code> class that associates <code>UrlPattern</code>s\nto handlers. Given a URL, the router finds a pattern that matches, and invokes\nit's handler. This is similar to\n<code>HttpServer.addRequestHandler(matcher, handler)</code> on the server. The handlers\nare then responsible for rendering the appropriate changes to the page.</p>\n<p>The <code>Router</code> can listen to <code>Window.onPopState</code> events and invoke the correct\nhandler so that the back button seamlessly works.</p>\n<p>Example (client.dart):</p>\n<pre class=\"dart\"><code>library client;\n\nimport 'package:route/client.dart';\n\nmain() {\n  var router = new Router()\n    ..addHandler(homeUrl, showHome)\n    ..addHandler(articleUrl, showArticle)\n    ..listen();\n}\n\nvoid showHome(String path) {\n  // nothing to parse from path, since there are no groups\n}\n\nvoid showArticle(String path) {\n  var articleId = articleUrl.parse(req.path)[0];\n  // show article page with loading indicator\n  // load article from server, then render article\n}\n</code></pre>\n<h2>Server Routing</h2>\n<p>On the server, route gives you a utility function to match <code>HttpRequest</code>s\nagainst <code>UrlPatterns</code>.</p>\n<pre class=\"dart\"><code>import 'urls.dart';\nimport 'package:route/server.dart';\nimport 'package:route/pattern.dart';\n\nHttpServer.bind().then((server) {\n  var router = new Router(server)\n    ..filter(matchesAny(allUrls), authFilter)\n    ..serve(homeUrl).listen(serverHome)\n    ..serve(articleUrl, method: 'GET').listen(serveArticle)\n    ..defaultStream.listen(serveNotFound);\n});\n\nFuture&lt;bool&gt; authFilter(req) {\n  return getUser(getUserIdCookie(req)).then((user) {\n    if (user != null) {\n      return true;\n    }\n    redirectToLoginPage(req);\n    return false;\n  });\n}\n\nserveArcticle(req) {\n  var articleId = articleUrl.parse(req.uri.path)[0];\n  // retrieve article data and respond\n}\n</code></pre>\n<h2>Further Goals</h2><ul><li>\n<p>Integration with Polymer so that the changing of UI views can happen\n   automatically.</p></li><li>Handling different HTTP methods to help implement REST APIs.</li><li>\n<p>Automatic generation of REST URLs from a single URL pattern, similar to Ruby\n   on Rails</p></li><li>Helpers for nested views and key-value URL schemes common with complex apps.</li><li>Done ~~Server-side routing for the dart:io v2 HttpServer~~</li><li>Done ~~IE 9 support~~</li></ul>"},{"packageName":"route","name":"route-server","qualifiedName":"route/route-server","preview":"<p>This library provides a simple API for routing HttpRequests based on thier\nURL.</p>","packageIntro":"<h1>Route</h1>\n<p>Route is a client + server routing library for Dart that helps make building\nsingle-page web apps and using <code>HttpServer</code> easier.</p>\n<h2>Installation</h2>\n<p>Add this package to your pubspec.yaml file:</p>\n<pre><code>dependencies:\n  route: any\n  \n</code></pre>\n<p>Then, run <code>pub install</code> to download and link in the package.</p>\n<h2>UrlPattern</h2>\n<p>Route is built around <code>UrlPattern</code> a class that matches, parses and produces\nURLs. A <code>UrlPattern</code> is similar to a regex, but constrained so that it is\n<em>reversible</em>, given a <code>UrlPattern</code> and a set of arguments you can produce the\nURL that when parsed returns those same arguments. This is important for keeping\nthe URL space for your app flexible so that you can change a URL for a resource\nin one place and keep your app working.</p>\n<p>Route lets you use the same URL patterns for client-side and server-side\nrouting. Just define a library containing all your URLs.</p>\n<p>As an example, consider a blog with a home page and an article page. The article\nURL has the form /article/1234. We want to show articles without reloading the\npage.</p>\n<p>Example (urls.dart):</p>\n<pre class=\"dart\"><code>library urls;\n\nimport 'package:route/url_pattern.dart';\n\nfinal homeUrl = new UrlPattern(r'/');\nfinal articleUrl = new UrlPattern(r'/article/(\\d+)');\nfinal allUrls = [homeUrl, articleUrl];\n</code></pre>\n<h2>Client Routing</h2>\n<p>On the client, there is a <code>Router</code> class that associates <code>UrlPattern</code>s\nto handlers. Given a URL, the router finds a pattern that matches, and invokes\nit's handler. This is similar to\n<code>HttpServer.addRequestHandler(matcher, handler)</code> on the server. The handlers\nare then responsible for rendering the appropriate changes to the page.</p>\n<p>The <code>Router</code> can listen to <code>Window.onPopState</code> events and invoke the correct\nhandler so that the back button seamlessly works.</p>\n<p>Example (client.dart):</p>\n<pre class=\"dart\"><code>library client;\n\nimport 'package:route/client.dart';\n\nmain() {\n  var router = new Router()\n    ..addHandler(homeUrl, showHome)\n    ..addHandler(articleUrl, showArticle)\n    ..listen();\n}\n\nvoid showHome(String path) {\n  // nothing to parse from path, since there are no groups\n}\n\nvoid showArticle(String path) {\n  var articleId = articleUrl.parse(req.path)[0];\n  // show article page with loading indicator\n  // load article from server, then render article\n}\n</code></pre>\n<h2>Server Routing</h2>\n<p>On the server, route gives you a utility function to match <code>HttpRequest</code>s\nagainst <code>UrlPatterns</code>.</p>\n<pre class=\"dart\"><code>import 'urls.dart';\nimport 'package:route/server.dart';\nimport 'package:route/pattern.dart';\n\nHttpServer.bind().then((server) {\n  var router = new Router(server)\n    ..filter(matchesAny(allUrls), authFilter)\n    ..serve(homeUrl).listen(serverHome)\n    ..serve(articleUrl, method: 'GET').listen(serveArticle)\n    ..defaultStream.listen(serveNotFound);\n});\n\nFuture&lt;bool&gt; authFilter(req) {\n  return getUser(getUserIdCookie(req)).then((user) {\n    if (user != null) {\n      return true;\n    }\n    redirectToLoginPage(req);\n    return false;\n  });\n}\n\nserveArcticle(req) {\n  var articleId = articleUrl.parse(req.uri.path)[0];\n  // retrieve article data and respond\n}\n</code></pre>\n<h2>Further Goals</h2><ul><li>\n<p>Integration with Polymer so that the changing of UI views can happen\n   automatically.</p></li><li>Handling different HTTP methods to help implement REST APIs.</li><li>\n<p>Automatic generation of REST URLs from a single URL pattern, similar to Ruby\n   on Rails</p></li><li>Helpers for nested views and key-value URL schemes common with complex apps.</li><li>Done ~~Server-side routing for the dart:io v2 HttpServer~~</li><li>Done ~~IE 9 support~~</li></ul>"},{"packageName":"route","name":"route-url_pattern","qualifiedName":"route/route-url_pattern","packageIntro":"<h1>Route</h1>\n<p>Route is a client + server routing library for Dart that helps make building\nsingle-page web apps and using <code>HttpServer</code> easier.</p>\n<h2>Installation</h2>\n<p>Add this package to your pubspec.yaml file:</p>\n<pre><code>dependencies:\n  route: any\n  \n</code></pre>\n<p>Then, run <code>pub install</code> to download and link in the package.</p>\n<h2>UrlPattern</h2>\n<p>Route is built around <code>UrlPattern</code> a class that matches, parses and produces\nURLs. A <code>UrlPattern</code> is similar to a regex, but constrained so that it is\n<em>reversible</em>, given a <code>UrlPattern</code> and a set of arguments you can produce the\nURL that when parsed returns those same arguments. This is important for keeping\nthe URL space for your app flexible so that you can change a URL for a resource\nin one place and keep your app working.</p>\n<p>Route lets you use the same URL patterns for client-side and server-side\nrouting. Just define a library containing all your URLs.</p>\n<p>As an example, consider a blog with a home page and an article page. The article\nURL has the form /article/1234. We want to show articles without reloading the\npage.</p>\n<p>Example (urls.dart):</p>\n<pre class=\"dart\"><code>library urls;\n\nimport 'package:route/url_pattern.dart';\n\nfinal homeUrl = new UrlPattern(r'/');\nfinal articleUrl = new UrlPattern(r'/article/(\\d+)');\nfinal allUrls = [homeUrl, articleUrl];\n</code></pre>\n<h2>Client Routing</h2>\n<p>On the client, there is a <code>Router</code> class that associates <code>UrlPattern</code>s\nto handlers. Given a URL, the router finds a pattern that matches, and invokes\nit's handler. This is similar to\n<code>HttpServer.addRequestHandler(matcher, handler)</code> on the server. The handlers\nare then responsible for rendering the appropriate changes to the page.</p>\n<p>The <code>Router</code> can listen to <code>Window.onPopState</code> events and invoke the correct\nhandler so that the back button seamlessly works.</p>\n<p>Example (client.dart):</p>\n<pre class=\"dart\"><code>library client;\n\nimport 'package:route/client.dart';\n\nmain() {\n  var router = new Router()\n    ..addHandler(homeUrl, showHome)\n    ..addHandler(articleUrl, showArticle)\n    ..listen();\n}\n\nvoid showHome(String path) {\n  // nothing to parse from path, since there are no groups\n}\n\nvoid showArticle(String path) {\n  var articleId = articleUrl.parse(req.path)[0];\n  // show article page with loading indicator\n  // load article from server, then render article\n}\n</code></pre>\n<h2>Server Routing</h2>\n<p>On the server, route gives you a utility function to match <code>HttpRequest</code>s\nagainst <code>UrlPatterns</code>.</p>\n<pre class=\"dart\"><code>import 'urls.dart';\nimport 'package:route/server.dart';\nimport 'package:route/pattern.dart';\n\nHttpServer.bind().then((server) {\n  var router = new Router(server)\n    ..filter(matchesAny(allUrls), authFilter)\n    ..serve(homeUrl).listen(serverHome)\n    ..serve(articleUrl, method: 'GET').listen(serveArticle)\n    ..defaultStream.listen(serveNotFound);\n});\n\nFuture&lt;bool&gt; authFilter(req) {\n  return getUser(getUserIdCookie(req)).then((user) {\n    if (user != null) {\n      return true;\n    }\n    redirectToLoginPage(req);\n    return false;\n  });\n}\n\nserveArcticle(req) {\n  var articleId = articleUrl.parse(req.uri.path)[0];\n  // retrieve article data and respond\n}\n</code></pre>\n<h2>Further Goals</h2><ul><li>\n<p>Integration with Polymer so that the changing of UI views can happen\n   automatically.</p></li><li>Handling different HTTP methods to help implement REST APIs.</li><li>\n<p>Automatic generation of REST URLs from a single URL pattern, similar to Ruby\n   on Rails</p></li><li>Helpers for nested views and key-value URL schemes common with complex apps.</li><li>Done ~~Server-side routing for the dart:io v2 HttpServer~~</li><li>Done ~~IE 9 support~~</li></ul>"},{"packageName":"stack_trace","name":"stack_trace","qualifiedName":"stack_trace/stack_trace","preview":"<p>Stack trace generation and parsing.</p>","packageIntro":"<p>This library provides the ability to parse, inspect, and manipulate stack traces\nproduced by the underlying Dart implementation. It also provides functions to\nproduce string representations of stack traces in a more readable format than\nthe native <a>dart-core</a> implementation.</p>\n<p><code>Trace</code>s can be parsed from native <a>dart-core</a>s using <code>Trace.from</code>, or captured\nusing <code>Trace.current</code>. Native <a>dart-core</a>s can also be directly converted to\nhuman-readable strings using <code>Trace.format</code>.</p>\n<p>Here's an example native stack trace from debugging this library:</p>\n<pre><code>#0      Object.noSuchMethod (dart:core-patch:1884:25)\n#1      Trace.terse.&lt;anonymous closure&gt; (file:///usr/local/google-old/home/goog/dart/dart/pkg/stack_trace/lib/src/trace.dart:47:21)\n#2      IterableMixinWorkaround.reduce (dart:collection:29:29)\n#3      List.reduce (dart:core-patch:1247:42)\n#4      Trace.terse (file:///usr/local/google-old/home/goog/dart/dart/pkg/stack_trace/lib/src/trace.dart:40:35)\n#5      format (file:///usr/local/google-old/home/goog/dart/dart/pkg/stack_trace/lib/stack_trace.dart:24:28)\n#6      main.&lt;anonymous closure&gt; (file:///usr/local/google-old/home/goog/dart/dart/test.dart:21:29)\n#7      _CatchErrorFuture._sendError (dart:async:525:24)\n#8      _FutureImpl._setErrorWithoutAsyncTrace (dart:async:393:26)\n#9      _FutureImpl._setError (dart:async:378:31)\n#10     _ThenFuture._sendValue (dart:async:490:16)\n#11     _FutureImpl._handleValue.&lt;anonymous closure&gt; (dart:async:349:28)\n#12     Timer.run.&lt;anonymous closure&gt; (dart:async:2402:21)\n#13     Timer.Timer.&lt;anonymous closure&gt; (dart:async-patch:15:15)\n</code></pre>\n<p>and its human-readable representation:</p>\n<pre><code>dart:core-patch                             Object.noSuchMethod\npkg/stack_trace/lib/src/trace.dart 47:21    Trace.terse.&lt;fn&gt;\ndart:collection                             IterableMixinWorkaround.reduce\ndart:core-patch                             List.reduce\npkg/stack_trace/lib/src/trace.dart 40:35    Trace.terse\npkg/stack_trace/lib/stack_trace.dart 24:28  format\ntest.dart 21:29                             main.&lt;fn&gt;\ndart:async                                  _CatchErrorFuture._sendError\ndart:async                                  _FutureImpl._setErrorWithoutAsyncTrace\ndart:async                                  _FutureImpl._setError\ndart:async                                  _ThenFuture._sendValue\ndart:async                                  _FutureImpl._handleValue.&lt;fn&gt;\ndart:async                                  Timer.run.&lt;fn&gt;\ndart:async-patch                            Timer.Timer.&lt;fn&gt;\n</code></pre>\n<p>You can further clean up the stack trace using <code>Trace.terse</code>. This folds\ntogether multiple stack frames from the Dart core libraries, so that only the\ncore library method that was directly called from user code is visible. For\nexample:</p>\n<pre><code>dart:core                                   Object.noSuchMethod\npkg/stack_trace/lib/src/trace.dart 47:21    Trace.terse.&lt;fn&gt;\ndart:core                                   List.reduce\npkg/stack_trace/lib/src/trace.dart 40:35    Trace.terse\npkg/stack_trace/lib/stack_trace.dart 24:28  format\ntest.dart 21:29                             main.&lt;fn&gt;\ndart:async                                  Timer.Timer.&lt;fn&gt;\n</code></pre>\n<h2>Stack Chains</h2>\n<p>This library also provides the ability to capture \"stack chains\" with the\n<code>Chain</code> class. When writing asynchronous code, a single stack trace isn't very\nuseful, since the call stack is unwound every time something async happens. A\nstack chain tracks stack traces through asynchronous calls, so that you can see\nthe full path from <code>main</code> down to the error.</p>\n<p>To use stack chains, just wrap the code that you want to track in\n<code>Chain.capture</code>. This will create a new <a href=\"https://api.dartlang.org/apidocs/channels/stable/#dart-async.Zone\">Zone</a> in which stack traces are\nrecorded and woven into chains every time an asynchronous call occurs. Zones are\nsticky, too, so any asynchronous operations started in the <code>Chain.capture</code>\ncallback will have their chains tracked, as will asynchronous operations they\nstart and so on.</p>\n<p>Here's an example of some code that doesn't capture its stack chains:</p>\n<pre class=\"dart\"><code>import 'dart:async';\n\nvoid main() {\n  scheduleAsync();\n}\n\nvoid scheduleAsync() {\n  return new Future.delayed(new Duration(seconds: 1))\n      .then((_) =&gt; runAsync());\n}\n\nvoid runAsync() {\n  throw 'oh no!';\n}\n</code></pre>\n<p>If we run this, it prints the following:</p>\n<pre><code>Uncaught Error: oh no!\nStack Trace: \n#0      runAsync (file:///usr/local/google-old/home/goog/dart/dart/test.dart:13:3)\n#1      scheduleAsync.&lt;anonymous closure&gt; (file:///usr/local/google-old/home/goog/dart/dart/test.dart:9:28)\n#2      _rootRunUnary (dart:async/zone.dart:717)\n#3      _RootZone.runUnary (dart:async/zone.dart:854)\n#4      _Future._propagateToListeners.handleValueCallback (dart:async/future_impl.dart:488)\n#5      _Future._propagateToListeners (dart:async/future_impl.dart:571)\n#6      _Future._complete (dart:async/future_impl.dart:317)\n#7      _SyncCompleter.complete (dart:async/future_impl.dart:44)\n#8      Future.Future.delayed.&lt;anonymous closure&gt; (dart:async/future.dart:219)\n#9      _createTimer.&lt;anonymous closure&gt; (dart:async-patch/timer_patch.dart:11)\n#10     _handleTimeout (dart:io/timer_impl.dart:292)\n#11     _RawReceivePortImpl._handleMessage (dart:isolate-patch/isolate_patch.dart:115)\n</code></pre>\n<p>Notice how there's no mention of <code>main</code> in that stack trace. All we know is that\nthe error was in <code>runAsync</code>; we don't know why <code>runAsync</code> was called.</p>\n<p>Now let's look at the same code with stack chains captured:</p>\n<pre class=\"dart\"><code>import 'dart:async';\n\nimport 'package:stack_trace/stack_trace.dart';\n\nvoid main() {\n  Chain.capture(() {\n    scheduleAsync();\n  });\n}\n\nvoid scheduleAsync() {\n  new Future.delayed(new Duration(seconds: 1))\n      .then((_) =&gt; runAsync());\n}\n\nvoid runAsync() {\n  throw 'oh no!';\n}\n</code></pre>\n<p>Now if we run it, it prints this:</p>\n<pre><code>Uncaught Error: oh no!\nStack Trace: \ntest.dart 17:3                                                runAsync\ntest.dart 13:28                                               scheduleAsync.&lt;fn&gt;\npackage:stack_trace/src/stack_zone_specification.dart 129:26  registerUnaryCallback.&lt;fn&gt;.&lt;fn&gt;\npackage:stack_trace/src/stack_zone_specification.dart 174:15  StackZoneSpecification._run\npackage:stack_trace/src/stack_zone_specification.dart 177:7   StackZoneSpecification._run\npackage:stack_trace/src/stack_zone_specification.dart 175:7   StackZoneSpecification._run\npackage:stack_trace/src/stack_zone_specification.dart 129:18  registerUnaryCallback.&lt;fn&gt;\ndart:async/zone.dart 717                                      _rootRunUnary\ndart:async/zone.dart 449                                      _ZoneDelegate.runUnary\ndart:async/zone.dart 654                                      _CustomizedZone.runUnary\ndart:async/future_impl.dart 488                               _Future._propagateToListeners.handleValueCallback\ndart:async/future_impl.dart 571                               _Future._propagateToListeners\ndart:async/future_impl.dart 317                               _Future._complete\ndart:async/future_impl.dart 44                                _SyncCompleter.complete\ndart:async/future.dart 219                                    Future.Future.delayed.&lt;fn&gt;\npackage:stack_trace/src/stack_zone_specification.dart 174:15  StackZoneSpecification._run\npackage:stack_trace/src/stack_zone_specification.dart 119:52  registerCallback.&lt;fn&gt;\ndart:async/zone.dart 706                                      _rootRun\ndart:async/zone.dart 440                                      _ZoneDelegate.run\ndart:async/zone.dart 650                                      _CustomizedZone.run\ndart:async/zone.dart 561                                      _BaseZone.runGuarded\ndart:async/zone.dart 586                                      _BaseZone.bindCallback.&lt;fn&gt;\npackage:stack_trace/src/stack_zone_specification.dart 174:15  StackZoneSpecification._run\npackage:stack_trace/src/stack_zone_specification.dart 119:52  registerCallback.&lt;fn&gt;\ndart:async/zone.dart 710                                      _rootRun\ndart:async/zone.dart 440                                      _ZoneDelegate.run\ndart:async/zone.dart 650                                      _CustomizedZone.run\ndart:async/zone.dart 561                                      _BaseZone.runGuarded\ndart:async/zone.dart 586                                      _BaseZone.bindCallback.&lt;fn&gt;\ndart:async-patch/timer_patch.dart 11                          _createTimer.&lt;fn&gt;\ndart:io/timer_impl.dart 292                                   _handleTimeout\ndart:isolate-patch/isolate_patch.dart 115                     _RawReceivePortImpl._handleMessage\n===== asynchronous gap ===========================\ndart:async/zone.dart 476                   _ZoneDelegate.registerUnaryCallback\ndart:async/zone.dart 666                   _CustomizedZone.registerUnaryCallback\ndart:async/future_impl.dart 164            _Future._Future._then\ndart:async/future_impl.dart 187            _Future.then\ntest.dart 13:12                            scheduleAsync\ntest.dart 7:18                             main.&lt;fn&gt;\ndart:async/zone.dart 710                   _rootRun\ndart:async/zone.dart 440                   _ZoneDelegate.run\ndart:async/zone.dart 650                   _CustomizedZone.run\ndart:async/zone.dart 944                   runZoned\npackage:stack_trace/src/chain.dart 93:20   Chain.capture\ntest.dart 6:16                             main\ndart:isolate-patch/isolate_patch.dart 216  _startIsolate.isolateStartHandler\ndart:isolate-patch/isolate_patch.dart 115  _RawReceivePortImpl._handleMessage\n</code></pre>\n<p>That's a lot of text! If you look closely, though, you can see that <code>main</code> is\nlisted in the first trace in the chain.</p>\n<p>Thankfully, you can call <code>Chain.terse</code> just like <code>Trace.terse</code> to get rid of all\nthe frames you don't care about. The terse version of the stack chain above is\nthis:</p>\n<pre><code>test.dart 17:3   runAsync\ntest.dart 13:28  scheduleAsync.&lt;fn&gt;\ndart:isolate     _RawReceivePortImpl._handleMessage\n===== asynchronous gap ===========================\ndart:async                                _Future.then\ntest.dart 13:12                           scheduleAsync\ntest.dart 7:18                            main.&lt;fn&gt;\npackage:stack_trace/src/chain.dart 93:20  Chain.capture\ntest.dart 6:16                            main\ndart:isolate                              _RawReceivePortImpl._handleMessage\n</code></pre>\n<p>That's a lot easier to understand!</p>\n<h3><code>Chain.track</code></h3>\n<p>For the most part <code>Chain.capture</code> will notice when an error is thrown and\nassociate the correct stack chain with it. However, there are some cases where\nexceptions won't be automatically detected: any <code>Future</code> constructor,\n<code>Completer.completeError</code>, <code>Stream.addError</code>, and libraries that use these such\nas <code>dart:io</code> and <code>dart:async</code>. For these, all you need to do is wrap the Future\nor Stream in a call to <code>Chain.track</code> and the errors will be tracked correctly.</p>"},{"packageName":"unittest","name":"compact_vm_config","qualifiedName":"unittest/compact_vm_config","preview":"<p>A test configuration that generates a compact 1-line progress bar. The bar is\nupdated in-place before and after each test is executed. If all test pass,\nyou should only see a couple lines in the terminal. If a test fails, the\nfailure is shown and the progress bar continues to be updated below it.</p>","packageIntro":""},{"packageName":"unittest","name":"matcher","qualifiedName":"unittest/matcher","preview":"<p>Support for specifying test expectations,\nsuch as for unit tests.</p>","packageIntro":""},{"packageName":"unittest","name":"mirror_matchers","qualifiedName":"unittest/mirror_matchers","preview":"<p>The mirror matchers library provides some additional matchers that\nmake use of dart:mirrors.</p>","packageIntro":""},{"packageName":"unittest","name":"mock","qualifiedName":"unittest/mock","preview":"<p>A simple mocking/spy library.</p>","packageIntro":""},{"packageName":"unittest","name":"unittest","qualifiedName":"unittest/unittest","preview":"<p>Support for writing Dart unit tests.</p>","packageIntro":""},{"packageName":"unittest","name":"unittest_html_config","qualifiedName":"unittest/unittest_html_config","preview":"<p>A simple unit test library for running tests in a browser.</p>","packageIntro":""},{"packageName":"unittest","name":"unittest_html_enhanced_config","qualifiedName":"unittest/unittest_html_enhanced_config","preview":"<p>A simple unit test library for running tests in a browser.</p>","packageIntro":""},{"packageName":"unittest","name":"unittest_html_individual_config","qualifiedName":"unittest/unittest_html_individual_config","preview":"<p>A unit test library for running groups of tests in a browser, instead of the\nentire test file. This is especially used for large tests files that have\nmany subtests, so we can mark groups as failing at a finer granularity than\nthe entire test file.</p>","packageIntro":""},{"packageName":"unittest","name":"unittest_interactive_html_config","qualifiedName":"unittest/unittest_interactive_html_config","preview":"<p>This configuration can be used to rerun selected tests, as well\nas see diagnostic output from tests. It runs each test in its own\nIFrame, so the configuration consists of two parts - a 'parent'\nconfig that manages all the tests, and a 'child' config for the\nIFrame that runs the individual tests.</p>","packageIntro":""},{"packageName":"unittest","name":"unittest_vm_config","qualifiedName":"unittest/unittest_vm_config","preview":"<p>A simple unit test library for running tests on the VM.</p>","packageIntro":""},{"packageName":"uuid","name":"Uuid","qualifiedName":"uuid/Uuid","packageIntro":"<p><a href=\"https://drone.io/daegalus/dart-uuid/latest\"><a href=\"https://drone.io/daegalus/dart-uuid/status.png\"><img src=\"https://drone.io/daegalus/dart-uuid/status.png\"></img></a></a></p>\n<h2>v0.3.0 is a big breaking change. Please make sure if you update to this version you are aware of the changes.</h2>\n<h1>dart-uuid</h1>\n<p>Simple, fast generation of <a href=\"http://www.ietf.org/rfc/rfc4122.txt\">RFC4122</a> UUIDs.</p>\n<p>Heavily based on node-uuid by Robert Kieffer (I even copied this readme over and modified it.) \nPrimarily becaue it works, well written, and so on.</p>\n<p>Features:</p><ul><li>Generate RFC4122 version 1, version 4, or version 5 UUIDs</li><li>Runs in dartvm and hopefully browsers too.</li><li>Cryptographically strong random # generation on all platforms</li><li><a href=\"http://daegalus.github.com/annotated/dart-uuid/Uuid/Uuid.html\">Annotated source code</a></li></ul>\n<h2>Getting Started</h2>\n<h3>Instructions</h3><ol><li>Install and configure pub (http://www.dartlang.org/docs/pub-package-manager/#installing-and-configuring-pub)</li><li>Open a command line and cd to your projects root folder</li><li>In your pubspec, add an entry for dart-uuid to your dependencies (example below)</li><li>pub install</li><li>If you wish to run tests, go into packages/dart-uuid/ and run 'dart test/uuid_test.dart'</li></ol>\n<h3>Pubspec</h3>\n<p>There are 2 options. Directly from git, or from pub.dartlang.org</p>\n<p>pub.dartlang.org: (you can use 'any' instead of a version if you just want the latest always)</p>\n<pre class=\"yaml\"><code>dependencies:\n  uuid: 0.3.2\n</code></pre>\n<pre class=\"dart\"><code>import 'package:uuid/uuid_server.dart'; // or uuid/uuid_client.dart for the browser\n\nvar uuid = new Uuid();\n</code></pre>\n<p>Then create some ids ...</p>\n<pre class=\"dart\"><code>// Generate a v1 (time-based) id\nuuid.v1(); // -&gt; '6c84fb90-12c4-11e1-840d-7b25c5ee775a'\n\n// Generate a v4 (random) id\nuuid.v4(); // -&gt; '110ec58a-a0f2-4ac4-8393-c866d813b8d1'\n\n// Generate a v5 (namespace-name-sha1-based) id\nuuid.v5(uuid.NAMESPACE_URL, 'www.google.com'); // -&gt; 'c74a196f-f19d-5ea9-bffd-a2742432fc9c'\n</code></pre>\n<h2>API</h2>\n<h3>uuid.v1({Map options: null, List buffer: null, int offset: 0})</h3>\n<p>Generate and return a RFC4122 v1 (timestamp-based) UUID.</p><ul><li>\n<p><code>options</code> - (Map) Optional uuid state to apply. Properties may include:</p></li><li>\n<p><code>node</code> - (List) Node id as List of 6 bytes (per 4.1.6). Default: Randomnly generated ID.</p></li><li><code>clockseq</code> - (Number between 0 - 0x3fff) RFC clock sequence.  Default: An internally maintained clockseq is used.</li><li><code>msecs</code> - (Number) Time in milliseconds since unix Epoch.  Default: The current time is used.</li><li>\n<p><code>nsecs</code> - (Number between 0-9999) additional time, in 100-nanosecond units. Ignored if <code>msecs</code> is unspecified. Default: internal uuid counter is used, as per 4.2.1.2.</p></li><li>\n<p><code>buffer</code> - (List) Array or buffer where UUID bytes are to be written.</p></li><li><code>offset</code> - (Int) Starting index in <code>buffer</code> at which to begin writing.</li></ul>\n<p>Returns <code>buffer</code>, if specified, otherwise the string form of the UUID</p>\n<p>Example: Generate string UUID with fully-specified options</p>\n<pre class=\"dart\"><code>uuid.v1(options: {\n    'node': [0x01, 0x23, 0x45, 0x67, 0x89, 0xab],\n    'clockSeq': 0x1234,\n    'mSecs': new Date(2011,11,01).millisecondsSinceEpoch,\n    'nSecs': 5678\n})   // -&gt; \"1d6a6e2e-0457-11e1-9234-0123456789ab\"\n</code></pre>\n<p>Example: In-place generation of two binary IDs</p>\n<pre class=\"dart\"><code>// Generate two ids in an array\nvar myBuffer = new List(32); // -&gt; []\nuuid.v1(buffer: myBuffer);   \n// -&gt; [115, 189, 5, 128, 201, 91, 17, 225, 146, 52, 109, 0, 9, 0, 52, 128, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null]\nuuid.v1(buffer: myBuffer, offset: 16);  \n// -&gt; [115, 189, 5, 128, 201, 91, 17, 225, 146, 52, 109, 0, 9, 0, 52, 128, 115, 189, 5, 129, 201, 91, 17, 225, 146, 52, 109, 0, 9, 0, 52, 128]\n\n// Optionally use uuid.unparse() to get stringify the ids\nuuid.unparse(buffer: myBuffer);    // -&gt; '73bd0580-c95b-11e1-9234-6d0009003480'\nuuid.unparse(buffer: myBuffer, offset: 16) // -&gt; '73bd0581-c95b-11e1-9234-6d0009003480'\n</code></pre>\n<h3>uuid.v4({Map options: null, List buffer: null, int offset: 0})</h3>\n<p>Generate and return a RFC4122 v4 UUID.</p><ul><li>\n<p><code>options</code> - (Map) Optional uuid state to apply. Properties may include:</p></li><li>\n<p><code>random</code> - (Number16) List of 16 numbers (0-255) to use in place of randomly generated values</p></li><li>\n<p><code>rng</code> - (Function) Random # generator to use. A Custom function that returns an list16 of byte values or 1 of 2 provided.</p></li><li>\n<p><code>buffer</code> - (List) Array or buffer where UUID bytes are to be written.</p></li><li><code>offset</code> - (Number) Starting index in <code>buffer</code> at which to begin writing.</li></ul>\n<p>Returns <code>buffer</code>, if specified, otherwise the string form of the UUID</p>\n<p>Example: Generate string UUID with fully-specified options</p>\n<pre class=\"dart\"><code>uuid.v4(options: {\n  'random': [\n    0x10, 0x91, 0x56, 0xbe, 0xc4, 0xfb, 0xc1, 0xea,\n    0x71, 0xb4, 0xef, 0xe1, 0x67, 0x1c, 0x58, 0x36\n  ]\n});\n// -&gt; \"109156be-c4fb-41ea-b1b4-efe1671c5836\"\n</code></pre>\n<p>Example: Generate two IDs in a single buffer</p>\n<pre class=\"dart\"><code>var myBuffer = new List(32);\nuuid.v4(buffer: myBuffer);\nuuid.v4(buffer: myBuffer, offset: 16);\n</code></pre>\n<h3>uuid.v5(String namespace, String name, {Map options: null, List buffer: null, int offset: 0})</h3>\n<p>Generate and return a RFC4122 v5 UUID.</p><ul><li>\n<p><code>options</code> - (Map) Optional uuid state to apply. Properties may include:</p></li><li>\n<p><code>randomNamespace</code> - (Boolean) Default True. Returns if you want a v4 generated namespace (true) or NAMESPACE_NIL (false)</p></li><li>\n<p><code>buffer</code> - (List) Array or buffer where UUID bytes are to be written.</p></li><li><code>offset</code> - (Number) Starting index in <code>buffer</code> at which to begin writing.</li></ul>\n<p>Returns <code>buffer</code>, if specified, otherwise the string form of the UUID</p>\n<p>Example: Generate string UUID with fully-specified options</p>\n<pre class=\"dart\"><code>uuid.v5(uuid.NAMESPACE_URL, 'www.google.com');\n// -&gt; \"c74a196f-f19d-5ea9-bffd-a2742432fc9c\"\n</code></pre>\n<p>Example: Generate two IDs in a single buffer</p>\n<pre class=\"dart\"><code>var myBuffer = new List(32);\nuuid.v5(uuid.NAMESPACE_URL, 'www.google.com', buffer: myBuffer);\nuuid.v5(uuid.NAMESPACE_URL, 'www.google.com', buffer: myBuffer, offset: 16);\n</code></pre>\n<h3>uuid.parse(String uuid, {List buffer: null, int offset: 0})</h3>\n<h3>uuid.unparse(List buffer, {int offset: 0})</h3>\n<p>Parse and unparse UUIDs</p><ul><li><code>id</code> - (String) UUID(-like) string</li><li><code>buffer</code> - (List) Array or buffer where UUID bytes are to be written. Default: A new Array or Buffer is used</li><li><code>offset</code> - (Int | Number) Starting index in <code>buffer</code> at which to begin writing. Default: 0</li></ul>\n<p>Example parsing and unparsing a UUID string</p>\n<pre class=\"dart\"><code>var bytes = uuid.parse('797ff043-11eb-11e1-80d6-510998755d10'); // -&gt; [121, 127, 240, 67, 17, 235, 17, 225, 128, 214, 81, 9, 152, 117, 93, 16]\nvar string = uuid.unparse(bytes); // -&gt; '797ff043-11eb-11e1-80d6-510998755d10'\n</code></pre>\n<h2>Testing</h2>\n<p>In dartvm</p>\n<pre><code>dart test\\uuid_test.dart\n</code></pre>\n<p>In Browser</p>\n<p>N/A as I have not used or tested this in the browser. But there are users of this library that do, and reported that it does infact work.</p>\n<h3>Benchmarking</h3>\n<p>Its pretty quick, but no official benchmarking.</p>\n<h2>Release notes</h2>\n<p>See CHANGELOG</p>"},{"packageName":"yaml","name":"yaml","qualifiedName":"yaml/yaml","packageIntro":"<p>A parser for <a href=\"http://www.yaml.org/\">YAML</a>.</p>\n<p>Use <code>loadYaml</code> to load a single document, or <code>loadYamlStream</code> to load a\nstream of documents. For example:</p>\n<pre class=\"dart\"><code>import 'package:yaml/yaml.dart';\n\nmain() {\n  var doc = loadYaml(\"YAML: YAML Ain't Markup Language\");\n  print(doc['YAML']);\n}\n</code></pre>\n<p>This library currently doesn't support dumping to YAML. You should use\n<code>JSON.encode</code> from <code>dart:convert</code> instead:</p>\n<pre class=\"dart\"><code>import 'dart:convert';\nimport 'package:yaml/yaml.dart';\n\nmain() {\n  var doc = loadYaml(\"YAML: YAML Ain't Markup Language\");\n  print(JSON.encode(doc));\n}\n</code></pre>\n<p>The source code for this package is at <a href=\"http://code.google.com/p/dart\">http://code.google.com/p/dart</a>.\nPlease file issues at <a href=\"http://dartbug.com\">http://dartbug.com</a>. Other questions or comments can be\ndirected to the Dart mailing list at &lt;mailto:misc@dartlang.org>.</p>"}],"introduction":"<p>Welcome to the Dart API reference documentation,\ncovering the official Dart API libraries.\nSome of the most fundamental Dart libraries include:</p><ul><li>\n<p><a href=\"#dart:core\">dart:core</a>:\n  Core functionality such as strings, numbers, collections, errors,\n  dates, and URIs.</p></li><li>\n<p><a href=\"#dart:html\">dart:html</a>:\n  DOM manipulation for web apps.</p></li><li>\n<p><a href=\"#dart:io\">dart:io</a>:\n  I/O for command-line apps.</p></li></ul>\n<p>Except for dart:core, you must import a library before you can use it.\nHere's an example of importing dart:html, dart:math, and a\nthird popular library called\n<a href=\"http://www.dartlang.org/polymer-dart/\">polymer.dart</a>:</p>\n<pre><code>import 'dart:html';\nimport 'dart:math';\nimport 'package:polymer/polymer.dart';\n</code></pre>\n<p>Polymer.dart is an example of a library that isn't\nincluded in the Dart download,\nbut is easy to get and update using the <em>pub package manager</em>.\nFor information on finding, using, and publishing libraries (and more)\nwith pub, see\n<a href=\"http://pub.dartlang.org\">pub.dartlang.org</a>.</p>\n<p>The main site for learning and using Dart is\n<a href=\"http://www.dartlang.org\">www.dartlang.org</a>.\nCheck out these pages:</p><ul><li><a href=\"http://www.dartlang.org\">Dart homepage</a></li><li><a href=\"http://www.dartlang.org/docs/tutorials/\">Tutorials</a></li><li><a href=\"http://www.dartlang.org/docs/\">Programmer's Guide</a></li><li><a href=\"http://www.dartlang.org/samples/\">Samples</a></li><li><a href=\"http://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html\">A Tour of the Dart Libraries</a></li></ul>\n<p>This API reference is automatically generated from the source code in the\n<a href=\"https://code.google.com/p/dart/\">Dart project</a>.\nIf you'd like to contribute to this documentation, see\n<a href=\"https://code.google.com/p/dart/wiki/Contributing\">Contributing</a>\nand\n<a href=\"https://code.google.com/p/dart/wiki/WritingApiDocumentation\">Writing API Documentation</a>.</p>","filetype":"json","start-page":"force"}