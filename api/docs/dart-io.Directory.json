{"name":"Directory","qualifiedName":"dart-io.Directory","comment":"<p>A reference to a directory (or <em>folder</em>) on the file system.</p>\n<p>A Directory instance is an object holding a <a>dart-io.Directory.path</a> on which operations can\nbe performed. The path to the directory can be <a>dart-io.Directory.absolute</a> or relative.\nYou can get the parent directory using the getter <a>dart-io.FileSystemEntity.parent</a>,\na property inherited from <a>dart-io.FileSystemEntity</a>.</p>\n<p>In addition to being used as an instance to access the file system,\nDirectory has a number of static properties, such as <a>dart-io.Directory.systemTemp</a>,\nwhich gets the system's temporary directory, and the getter and setter\n<a>dart-io.Directory.current</a>, which you can use to access or change the current directory.</p>\n<p>Create a new Directory object with a pathname to access the specified\ndirectory on the file system from your program.</p>\n<pre><code>var myDir = new Directory('myDir');\n</code></pre>\n<p>Most methods in this class occur in synchronous and asynchronous pairs,\nfor example, <a>dart-io.Directory.create</a> and <a>dart-io.Directory.createSync</a>.\nUnless you have a specific reason for using the synchronous version\nof a method, prefer the asynchronous version to avoid blocking your program.</p>\n<h2>Create a directory</h2>\n<p>The following code sample creates a directory using the <a>dart-io.Directory.create</a> method.\nBy setting the <code>recursive</code> parameter to true, you can create the\nnamed directory and all its necessary parent directories,\nif they do not already exist.</p>\n<pre><code>import 'dart:io';\n\nvoid main() {\n  // Creates dir/ and dir/subdir/.\n  new Directory('dir/subdir').create(recursive: true)\n    // The created directory is returned as a Future.\n    .then((Directory directory) {\n      print(directory.path);\n  });\n}\n</code></pre>\n<h2>List a directory</h2>\n<p>Use the <a>dart-io.Directory.list</a> or <a>dart-io.Directory.listSync</a> methods to get the files and directories\ncontained by a directory.\nSet <code>recursive</code> to true to recursively list all subdirectories.\nSet <code>followLinks</code> to true to follow symbolic links.\nThe list method returns a <a>dart-async.Stream</a> that provides FileSystemEntity\nobjects. Use the listen callback function to process each object\nas it become available.</p>\n<pre><code>import 'dart:io';\n\nvoid main() {\n  // Get the system temp directory.\n  var systemTempDir = Directory.systemTemp;\n\n  // List directory contents, recursing into sub-directories,\n  // but not following symbolic links.\n  systemTempDir.list(recursive: true, followLinks: false)\n    .listen((FileSystemEntity entity) {\n      print(entity.path);\n    });\n}\n</code></pre>\n<h2>The use of Futures</h2>\n<p>I/O operations can block a program for some period of time while it waits for\nthe operation to complete. To avoid this, all\nmethods involving I/O have an asynchronous variant which returns a <a>dart-async.Future</a>.\nThis future completes when the I/O operation finishes. While the I/O\noperation is in progress, the Dart program is not blocked,\nand can perform other operations.</p>\n<p>For example,\nthe <a>dart-io.FileSystemEntity.exists</a> method, which determines whether the directory exists,\nreturns a boolean value using a Future.\nUse <code>then</code> to register a callback function, which is called when\nthe value is ready.</p>\n<pre><code>import 'dart:io';\n\nmain() {\n  final myDir = new Directory('dir');\n  myDir.exists().then((isThere) {\n    isThere ? print('exists') : print('non-existent');\n  });\n}\n</code></pre>\n<p>In addition to exists, the <a>dart-io.FileSystemEntity.stat</a>, <a>dart-io.Directory.rename</a>, and\nother methods, return Futures.</p>\n<h2>Other resources</h2><ul><li>\n<p><a href=\"https://www.dartlang.org/dart-by-example/#files-directories-and-symlinks\">Dart by Example</a>\nprovides additional task-oriented code samples that show how to use \nvarious API from the Directory class and the related <a>dart-io.File</a> class.</p></li><li>\n<p><a href=\"https://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-dartio---file-and-socket-io-for-command-line-apps\">I/O for Command-Line Apps</a>\na section from <em>A Tour of the Dart Libraries</em>\ncovers files and directories.</p></li><li>\n<p><a href=\"https://www.dartlang.org/docs/tutorials/cmdline/\">Write Command-Line Apps</a>,\na tutorial about writing command-line apps, includes information\nabout files and directories.</p></li></ul>","isAbstract":true,"superclass":"dart-io.FileSystemEntity","implements":[],"subclass":[],"variables":{"path":{"name":"path","qualifiedName":"dart-io.Directory.path","comment":"<p>Gets the path of this directory.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]}},"inheritedVariables":{},"methods":{"setters":{"current=":{"name":"current=","qualifiedName":"dart-io.Directory.current=","comment":"<p>Sets the current working directory of the Dart process including\nall running isolates. The new value set can be either a <a>dart-io.Directory</a>\nor a <a>dart-core.String</a>.</p>\n<p>The new value is passed to the OS's system call unchanged, so a\nrelative path passed as the new working directory will be\nresolved by the OS.</p>\n<p>Note that setting the current working directory is a synchronous\noperation and that it changes the the working directory of <em>all</em>\nisolates.</p>\n<p>Use this with care - especially when working with asynchronous\noperations and multiple isolates. Changing the working directory,\nwhile asynchronous operations are pending or when other isolates\nare working with the file system, can lead to unexpected results.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"getters":{"absolute":{"name":"absolute","qualifiedName":"dart-io.Directory.absolute","comment":"<p>Returns a <a>dart-io.Directory</a> instance whose path is the absolute path to this.</p>\n<p>The absolute path is computed by prefixing\na relative path with the current working directory, and returning\nan absolute path unchanged.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.Directory","inner":[]}],"parameters":{},"annotations":[]},"current":{"name":"current","qualifiedName":"dart-io.Directory.current","comment":"<p>Creates a directory object pointing to the current working\ndirectory.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-io.Directory","inner":[]}],"parameters":{},"annotations":[]},"systemTemp":{"name":"systemTemp","qualifiedName":"dart-io.Directory.systemTemp","comment":"<p>Gets the system temp directory.</p>\n<p>Gets the directory provided by the operating system for creating\ntemporary files and directories in.\nThe location of the system temp directory is platform-dependent,\nand may be set by an environment variable.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-io.Directory","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"dart-io.Directory.Directory-","comment":"<p>Creates a directory object. The path is either an absolute path,\nor it is a relative path which is interpreted relative to the directory\nin which the Dart VM was started.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-io.Directory","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"fromUri":{"name":"fromUri","qualifiedName":"dart-io.Directory.Directory-fromUri","comment":"<p>Create a Directory object from a URI.</p>\n<p>If <a>dart-io.Directory.Directory-fromUri.uri</a> cannot reference a directory this throws <a>dart-core.UnsupportedError</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-io.Directory","inner":[]}],"parameters":{"uri":{"name":"uri","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{"create":{"name":"create","qualifiedName":"dart-io.Directory.create","comment":"<p>Creates the directory with this name.</p>\n<p>If <a>dart-io.Directory.create.recursive</a> is false, only the last directory in the path is\ncreated. If <a>dart-io.Directory.create.recursive</a> is true, all non-existing path components\nare created. If the directory already exists nothing is done.</p>\n<p>Returns a <code>Future&lt;Directory&gt;</code> that completes with this\ndirectory once it has been created. If the directory cannot be\ncreated the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.Directory","inner":[]}]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"createSync":{"name":"createSync","qualifiedName":"dart-io.Directory.createSync","comment":"<p>Synchronously creates the directory with this name.</p>\n<p>If <a>dart-io.Directory.createSync.recursive</a> is false, only the last directory in the path is\ncreated. If <a>dart-io.Directory.createSync.recursive</a> is true, all non-existing path components\nare created. If the directory already exists nothing is done.</p>\n<p>If the directory cannot be created an exception is thrown.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"createTemp":{"name":"createTemp","qualifiedName":"dart-io.Directory.createTemp","comment":"<p>Creates a temporary directory in this directory. Additional random\ncharacters are appended to <a>dart-io.Directory.createTemp.prefix</a> to produce a unique directory\nname. If <a>dart-io.Directory.createTemp.prefix</a> is missing or null, the empty string is used\nfor <a>dart-io.Directory.createTemp.prefix</a>.</p>\n<p>Returns a <code>Future&lt;Directory&gt;</code> that completes with the newly\ncreated temporary directory.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.Directory","inner":[]}]}],"parameters":{"prefix":{"name":"prefix","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"createTempSync":{"name":"createTempSync","qualifiedName":"dart-io.Directory.createTempSync","comment":"<p>Synchronously creates a temporary directory in this directory.\nAdditional random characters are appended to <a>dart-io.Directory.createTempSync.prefix</a> to produce\na unique directory name. If <a>dart-io.Directory.createTempSync.prefix</a> is missing or null, the empty\nstring is used for <a>dart-io.Directory.createTempSync.prefix</a>.</p>\n<p>Returns the newly created temporary directory.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.Directory","inner":[]}],"parameters":{"prefix":{"name":"prefix","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"list":{"name":"list","qualifiedName":"dart-io.Directory.list","comment":"<p>Lists the sub-directories and files of this <a>dart-io.Directory</a>.\nOptionally recurses into sub-directories.</p>\n<p>If <a>dart-io.Directory.list.followLinks</a> is false, then any symbolic links found\nare reported as <a>dart-io.Link</a> objects, rather than as directories or files,\nand are not recursed into.</p>\n<p>If <a>dart-io.Directory.list.followLinks</a> is true, then working links are reported as\ndirectories or files, depending on\ntheir type, and links to directories are recursed into.\nBroken links are reported as <a>dart-io.Link</a> objects.\nIf a symbolic link makes a loop in the file system, then a recursive\nlisting will not follow a link twice in the\nsame recursive descent, but will report it as a <a>dart-io.Link</a>\nthe second time it is seen.</p>\n<p>The result is a stream of <a>dart-io.FileSystemEntity</a> objects\nfor the directories, files, and links.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-io.FileSystemEntity","inner":[]}]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]},"followLinks":{"name":"followLinks","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]}},"annotations":[]},"listSync":{"name":"listSync","qualifiedName":"dart-io.Directory.listSync","comment":"<p>Lists the sub-directories and files of this <a>dart-io.Directory</a>.\nOptionally recurses into sub-directories.</p>\n<p>If <a>dart-io.Directory.listSync.followLinks</a> is false, then any symbolic links found\nare reported as <a>dart-io.Link</a> objects, rather than as directories or files,\nand are not recursed into.</p>\n<p>If <a>dart-io.Directory.listSync.followLinks</a> is true, then working links are reported as\ndirectories or files, depending on\ntheir type, and links to directories are recursed into.\nBroken links are reported as <a>dart-io.Link</a> objects.\nIf a link makes a loop in the file system, then a recursive\nlisting will not follow a link twice in the\nsame recursive descent, but will report it as a <a>dart-io.Link</a>\nthe second time it is seen.</p>\n<p>Returns a <a>dart-core.List</a> containing <a>dart-io.FileSystemEntity</a> objects for the\ndirectories, files, and links.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-io.FileSystemEntity","inner":[]}]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]},"followLinks":{"name":"followLinks","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]}},"annotations":[]},"rename":{"name":"rename","qualifiedName":"dart-io.Directory.rename","comment":"<p>Renames this directory. Returns a <code>Future&lt;Directory&gt;</code> that completes\nwith a <a>dart-io.Directory</a> instance for the renamed directory.</p>\n<p>If newPath identifies an existing directory, that directory is\nreplaced. If newPath identifies an existing file, the operation\nfails and the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.Directory","inner":[]}]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"renameSync":{"name":"renameSync","qualifiedName":"dart-io.Directory.renameSync","comment":"<p>Synchronously renames this directory. Returns a <a>dart-io.Directory</a>\ninstance for the renamed directory.</p>\n<p>If newPath identifies an existing directory, that directory is\nreplaced. If newPath identifies an existing file the operation\nfails and an exception is thrown.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.Directory","inner":[]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"resolveSymbolicLinks":{"name":"resolveSymbolicLinks","qualifiedName":"dart-io.Directory.resolveSymbolicLinks","comment":"<p>Resolves the path of a file system object relative to the\ncurrent working directory, resolving all symbolic links on\nthe path and resolving all '..' and '.' path segments.\n<a>dart-io.Directory.resolveSymbolicLinks</a> returns a <code>Future&lt;String&gt;</code></p>\n<p><a>dart-io.Directory.resolveSymbolicLinks</a> uses the operating system's native filesystem api\nto resolve the path, using the realpath function on linux and\nMac OS, and the GetFinalPathNameByHandle function on Windows.\nIf the path does not point to an existing file system object,\n<a>dart-io.Directory.resolveSymbolicLinks</a> completes the returned Future with an FileSystemException.</p>\n<p>On Windows, symbolic links are resolved to their target before applying\na '..' that follows, and on other platforms, the '..' is applied to the\nsymbolic link without resolving it.  The second behavior can be emulated\non Windows by processing any '..' segments before calling\n<a>dart-io.Directory.resolveSymbolicLinks</a>.  One way of doing this is with the URI class:\n:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();,\nsince resolve removes '..' segments.</p>","commentFrom":"dart-io.FileSystemEntity.resolveSymbolicLinks","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{},"annotations":[]},"resolveSymbolicLinksSync":{"name":"resolveSymbolicLinksSync","qualifiedName":"dart-io.Directory.resolveSymbolicLinksSync","comment":"<p>Resolves the path of a file system object relative to the\ncurrent working directory, resolving all symbolic links on\nthe path and resolving all '..' and '.' path segments.</p>\n<p><a>dart-io.Directory.resolveSymbolicLinksSync</a> uses the operating system's native\nfilesystem api to resolve the path, using the realpath function\non linux and Mac OS, and the GetFinalPathNameByHandle function on Windows.\nIf the path does not point to an existing file system object,\n<a>dart-io.Directory.resolveSymbolicLinksSync</a> throws a FileSystemException.</p>\n<p>On Windows, symbolic links are resolved to their target before applying\na '..' that follows, and on other platforms, the '..' is applied to the\nsymbolic link without resolving it.  The second behavior can be emulated\non Windows by processing any '..' segments before calling\n<a>dart-io.Directory.resolveSymbolicLinks</a>.  One way of doing this is with the URI class:\n:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();,\nsince resolve removes '..' segments.</p>","commentFrom":"dart-io.FileSystemEntity.resolveSymbolicLinksSync","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-io.Directory.toString","comment":"<p>Returns a human readable string for this Directory instance.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"absolute":{"name":"absolute","qualifiedName":"dart-io.Directory.absolute","comment":"<p>Returns a <a>dart-io.FileSystemEntity</a> whose path is the absolute path to this.\nThe type of the returned instance is the type of this.</p>\n<p>The absolute path is computed by prefixing\na relative path with the current working directory, and returning\nan absolute path unchanged.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.absolute","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.FileSystemEntity","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"dart-io.Directory.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-io.Directory.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"isAbsolute":{"name":"isAbsolute","qualifiedName":"dart-io.Directory.isAbsolute","comment":"<p>Returns a <a>dart-core.bool</a> indicating whether this object's path is absolute.</p>\n<p>On Windows, a path is absolute if it starts with \\\\ or a drive letter\nbetween a and z (upper or lower case) followed by :\\ or :/.\nOn non-Windows, a path is absolute if it starts with /.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.isAbsolute","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"parent":{"name":"parent","qualifiedName":"dart-io.Directory.parent","comment":"<p>The directory containing this.  If this is a root\ndirectory, returns this.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.parent","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-io.Directory","inner":[]}],"parameters":{},"annotations":[]},"path":{"name":"path","qualifiedName":"dart-io.Directory.path","comment":"","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.path","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-io.Directory.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-io.Directory.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart-io.Directory.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart-io.Directory.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"delete":{"name":"delete","qualifiedName":"dart-io.Directory.delete","comment":"<p>Deletes this <a>dart-io.FileSystemEntity</a>.</p>\n<p>If the <a>dart-io.FileSystemEntity</a> is a directory, and if <a>dart-io.Directory.delete.recursive</a> is false,\nthe directory must be empty. Otherwise, if <a>dart-io.Directory.delete.recursive</a> is true, the\ndirectory and all sub-directories and files in the directories are\ndeleted. Links are not followed when deleting recursively. Only the link\nis deleted, not its target.</p>\n<p>If <a>dart-io.Directory.delete.recursive</a> is true, the <a>dart-io.FileSystemEntity</a> is deleted even if the type\nof the <a>dart-io.FileSystemEntity</a> doesn't match the content of the file system.\nThis behavior allows <a>dart-io.Directory.delete</a> to be used to unconditionally delete any file\nsystem object.</p>\n<p>Returns a <code>Future&lt;FileSystemEntity&gt;</code> that completes with this\n<a>dart-io.FileSystemEntity</a> when the deletion is done. If the <a>dart-io.FileSystemEntity</a>\ncannot be deleted, the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.delete","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileSystemEntity","inner":[]}]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"deleteSync":{"name":"deleteSync","qualifiedName":"dart-io.Directory.deleteSync","comment":"<p>Synchronously deletes this <a>dart-io.FileSystemEntity</a>.</p>\n<p>If the <a>dart-io.FileSystemEntity</a> is a directory, and if <a>dart-io.Directory.deleteSync.recursive</a> is false,\nthe directory must be empty. Otherwise, if <a>dart-io.Directory.deleteSync.recursive</a> is true, the\ndirectory and all sub-directories and files in the directories are\ndeleted. Links are not followed when deleting recursively. Only the link\nis deleted, not its target.</p>\n<p>If <a>dart-io.Directory.deleteSync.recursive</a> is true, the <a>dart-io.FileSystemEntity</a> is deleted even if the type\nof the <a>dart-io.FileSystemEntity</a> doesn't match the content of the file system.\nThis behavior allows <a>dart-io.Directory.deleteSync</a> to be used to unconditionally delete any\nfile system object.</p>\n<p>Throws an exception if the <a>dart-io.FileSystemEntity</a> cannot be deleted.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.deleteSync","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"exists":{"name":"exists","qualifiedName":"dart-io.Directory.exists","comment":"<p>Checks whether the file system entity with this path exists. Returns\na <code>Future&lt;bool&gt;</code> that completes with the result.</p>\n<p>Since FileSystemEntity is abstract, every FileSystemEntity object\nis actually an instance of one of the subclasses <a>dart-io.File</a>,\n<a>dart-io.Directory</a>, and <a>dart-io.Link</a>.  Calling <a>dart-io.Directory.exists</a> on an instance of one\nof these subclasses checks whether the object exists in the file\nsystem object exists and is of the correct type (file, directory,\nor link).  To check whether a path points to an object on the\nfile system, regardless of the object's type, use the <a>dart-io.FileSystemEntity.type</a>\nstatic method.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.exists","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.bool","inner":[]}]}],"parameters":{},"annotations":[]},"existsSync":{"name":"existsSync","qualifiedName":"dart-io.Directory.existsSync","comment":"<p>Synchronously checks whether the file system entity with this path\nexists.</p>\n<p>Since FileSystemEntity is abstract, every FileSystemEntity object\nis actually an instance of one of the subclasses <a>dart-io.File</a>,\n<a>dart-io.Directory</a>, and <a>dart-io.Link</a>.  Calling <a>dart-io.Directory.existsSync</a> on an instance of\none of these subclasses checks whether the object exists in the\nfile system object exists and is of the correct type (file,\ndirectory, or link).  To check whether a path points to an object\non the file system, regardless of the object's type, use the\n<a>dart-io.FileSystemEntity.typeSync</a> static method.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.existsSync","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-io.Directory.noSuchMethod","comment":"<p><a>dart-io.Directory.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-io.Directory.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-io.Directory.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-io.Directory.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"rename":{"name":"rename","qualifiedName":"dart-io.Directory.rename","comment":"<p>Renames this file system entity. Returns a <code>Future&lt;FileSystemEntity&gt;</code>\nthat completes with a <a>dart-io.FileSystemEntity</a> instance for the renamed\nfile system entity.</p>\n<p>If <a>dart-io.Directory.rename.newPath</a> identifies an existing entity of the same type, that entity\nis replaced. If <a>dart-io.Directory.rename.newPath</a> identifies an existing entity of a different\ntype, the operation fails and the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.rename","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileSystemEntity","inner":[]}]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"renameSync":{"name":"renameSync","qualifiedName":"dart-io.Directory.renameSync","comment":"<p>Synchronously renames this file system entity. Returns a <a>dart-io.FileSystemEntity</a>\ninstance for the renamed entity.</p>\n<p>If <a>dart-io.Directory.renameSync.newPath</a> identifies an existing entity of the same type, that entity\nis replaced. If <a>dart-io.Directory.renameSync.newPath</a> identifies an existing entity of a different\ntype, the operation fails and an exception is thrown.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.renameSync","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.FileSystemEntity","inner":[]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"resolveSymbolicLinks":{"name":"resolveSymbolicLinks","qualifiedName":"dart-io.Directory.resolveSymbolicLinks","comment":"<p>Resolves the path of a file system object relative to the\ncurrent working directory, resolving all symbolic links on\nthe path and resolving all '..' and '.' path segments.\n<a>dart-io.Directory.resolveSymbolicLinks</a> returns a <code>Future&lt;String&gt;</code></p>\n<p><a>dart-io.Directory.resolveSymbolicLinks</a> uses the operating system's native filesystem api\nto resolve the path, using the realpath function on linux and\nMac OS, and the GetFinalPathNameByHandle function on Windows.\nIf the path does not point to an existing file system object,\n<a>dart-io.Directory.resolveSymbolicLinks</a> completes the returned Future with an FileSystemException.</p>\n<p>On Windows, symbolic links are resolved to their target before applying\na '..' that follows, and on other platforms, the '..' is applied to the\nsymbolic link without resolving it.  The second behavior can be emulated\non Windows by processing any '..' segments before calling\n<a>dart-io.Directory.resolveSymbolicLinks</a>.  One way of doing this is with the URI class:\n:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();,\nsince resolve removes '..' segments.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.resolveSymbolicLinks","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{},"annotations":[]},"resolveSymbolicLinksSync":{"name":"resolveSymbolicLinksSync","qualifiedName":"dart-io.Directory.resolveSymbolicLinksSync","comment":"<p>Resolves the path of a file system object relative to the\ncurrent working directory, resolving all symbolic links on\nthe path and resolving all '..' and '.' path segments.</p>\n<p><a>dart-io.Directory.resolveSymbolicLinksSync</a> uses the operating system's native\nfilesystem api to resolve the path, using the realpath function\non linux and Mac OS, and the GetFinalPathNameByHandle function on Windows.\nIf the path does not point to an existing file system object,\n<a>dart-io.Directory.resolveSymbolicLinksSync</a> throws a FileSystemException.</p>\n<p>On Windows, symbolic links are resolved to their target before applying\na '..' that follows, and on other platforms, the '..' is applied to the\nsymbolic link without resolving it.  The second behavior can be emulated\non Windows by processing any '..' segments before calling\n<a>dart-io.Directory.resolveSymbolicLinks</a>.  One way of doing this is with the URI class:\n:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();,\nsince resolve removes '..' segments.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.resolveSymbolicLinksSync","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"stat":{"name":"stat","qualifiedName":"dart-io.Directory.stat","comment":"<p>Calls the operating system's stat() function on the <a>dart-io.Directory.path</a> of this\n<a>dart-io.FileSystemEntity</a>.  Identical to <code>FileStat.stat(this.path)</code>.</p>\n<p>Returns a <code>Future&lt;FileStat&gt;</code> object containing the data returned by\nstat().</p>\n<p>If the call fails, completes the future with a <a>dart-io.FileStat</a> object\nwith .type set to\nFileSystemEntityType.NOT_FOUND and the other fields invalid.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.stat","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileStat","inner":[]}]}],"parameters":{},"annotations":[]},"statSync":{"name":"statSync","qualifiedName":"dart-io.Directory.statSync","comment":"<p>Synchronously calls the operating system's stat() function on the\n<a>dart-io.Directory.path</a> of this <a>dart-io.FileSystemEntity</a>.\nIdentical to <code>FileStat.statSync(this.path)</code>.</p>\n<p>Returns a <a>dart-io.FileStat</a> object containing the data returned by stat().</p>\n<p>If the call fails, returns a <a>dart-io.FileStat</a> object with .type set to\nFileSystemEntityType.NOT_FOUND and the other fields invalid.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.statSync","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.FileStat","inner":[]}],"parameters":{},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-io.Directory.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"watch":{"name":"watch","qualifiedName":"dart-io.Directory.watch","comment":"<p>Start watching the <a>dart-io.FileSystemEntity</a> for changes.</p>\n<p>The implementation uses platform-dependent event-based APIs for receiving\nfile-system notifications, thus behavior depends on the platform.</p><ul><li>\n<p><code>Windows</code>: Uses <code>ReadDirectoryChangesW</code>. The implementation only\nsupports watching directories. Recursive watching is supported.</p></li><li>\n<p><code>Linux</code>: Uses <code>inotify</code>. The implementation supports watching both\nfiles and directories. Recursive watching is not supported.\nNote: When watching files directly, delete events might not happen\nas expected.</p></li><li>\n<p><code>Mac OS</code>: Uses <code>FSEvents</code>. The implementation supports watching both\nfiles and directories. Recursive watching is supported.</p></li></ul>\n<p>The system will start listening for events once the returned <a>dart-async.Stream</a> is\nbeing listened to, not when the call to <a>dart-io.Directory.watch</a> is issued.</p>\n<p>The returned value is an endless broadcast <a>dart-async.Stream</a>, that only stops when\none of the following happends:</p><ul><li>\n<p>The <a>dart-async.Stream</a> is canceled, e.g. by calling <code>cancel</code> on the\n <a>dart-async.StreamSubscription</a>.</p></li><li>The <a>dart-io.FileSystemEntity</a> being watches, is deleted.</li></ul>\n<p>Use <code>events</code> to specify what events to listen for. The constants in\n<a>dart-io.FileSystemEvent</a> can be or'ed together to mix events. Default is\n<a>dart-io.FileSystemEvent.ALL</a>.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.watch","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-io.FileSystemEvent","inner":[]}]}],"parameters":{"events":{"name":"events","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"15","annotations":[]},"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]}}},"annotations":[],"generics":{}}