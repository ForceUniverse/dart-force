{"name":"matcher","qualifiedName":"unittest/matcher","comment":"<p>Support for specifying test expectations,\nsuch as for unit tests.</p>\n<p>This library is included in the\n<a href=\"http://pub.dartlang.org/packages/unittest\">unittest package on pub.dartlang.org</a>.\nImport this library into your Dart code with:</p>\n<pre><code>import 'package:unittest/matcher.dart';\n</code></pre>\n<p>The matcher library provides a third-generation assertion mechanism, drawing\ninspiration from <a href=\"http://code.google.com/p/hamcrest/\">Hamcrest</a>.\nFor more information, see\n<a href=\"http://www.dartlang.org/articles/dart-unit-tests/\">Unit Testing with Dart</a>.</p>","variables":{"anything":{"name":"anything","qualifiedName":"unittest/matcher.anything","comment":"<p>A matcher that matches any value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"completes":{"name":"completes","qualifiedName":"unittest/matcher.completes","comment":"<p>Matches a <a>dart-async.Future</a> that completes successfully with a value. Note that this\ncreates an asynchronous expectation. The call to <code>expect()</code> that includes\nthis will return immediately and execution will continue. Later, when the\nfuture completes, the actual expectation will run.</p>\n<p>To test that a Future completes with an exception, you can use <a>unittest/matcher.throws</a> and\n<a>unittest/matcher.throwsA</a>.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isAbstractClassInstantiationError":{"name":"isAbstractClassInstantiationError","qualifiedName":"unittest/matcher.isAbstractClassInstantiationError","comment":"<p>A matcher for AbstractClassInstantiationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isArgumentError":{"name":"isArgumentError","qualifiedName":"unittest/matcher.isArgumentError","comment":"<p>A matcher for ArgumentErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isConcurrentModificationError":{"name":"isConcurrentModificationError","qualifiedName":"unittest/matcher.isConcurrentModificationError","comment":"<p>A matcher for ConcurrentModificationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isCyclicInitializationError":{"name":"isCyclicInitializationError","qualifiedName":"unittest/matcher.isCyclicInitializationError","comment":"<p>A matcher for CyclicInitializationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isEmpty":{"name":"isEmpty","qualifiedName":"unittest/matcher.isEmpty","comment":"<p>Returns a matcher that matches empty strings, maps or iterables\n(including collections).</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isException":{"name":"isException","qualifiedName":"unittest/matcher.isException","comment":"<p>A matcher for Exceptions.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isFallThroughError":{"name":"isFallThroughError","qualifiedName":"unittest/matcher.isFallThroughError","comment":"<p>A matcher for FallThroughError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isFalse":{"name":"isFalse","qualifiedName":"unittest/matcher.isFalse","comment":"<p>A matcher that matches anything except the Boolean value true.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isFormatException":{"name":"isFormatException","qualifiedName":"unittest/matcher.isFormatException","comment":"<p>A matcher for FormatExceptions.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isList":{"name":"isList","qualifiedName":"unittest/matcher.isList","comment":"<p>A matcher for List types.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isMap":{"name":"isMap","qualifiedName":"unittest/matcher.isMap","comment":"<p>A matcher for Map types.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isNegative":{"name":"isNegative","qualifiedName":"unittest/matcher.isNegative","comment":"<p>A matcher which matches if the match argument is negative.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isNoSuchMethodError":{"name":"isNoSuchMethodError","qualifiedName":"unittest/matcher.isNoSuchMethodError","comment":"<p>A matcher for NoSuchMethodErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isNonNegative":{"name":"isNonNegative","qualifiedName":"unittest/matcher.isNonNegative","comment":"<p>A matcher which matches if the match argument is zero or positive.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isNonPositive":{"name":"isNonPositive","qualifiedName":"unittest/matcher.isNonPositive","comment":"<p>A matcher which matches if the match argument is zero or negative.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isNonZero":{"name":"isNonZero","qualifiedName":"unittest/matcher.isNonZero","comment":"<p>A matcher which matches if the match argument is non-zero.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isNotNull":{"name":"isNotNull","qualifiedName":"unittest/matcher.isNotNull","comment":"<p>A matcher that matches any non-null value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isNull":{"name":"isNull","qualifiedName":"unittest/matcher.isNull","comment":"<p>A matcher that matches any null value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isNullThrownError":{"name":"isNullThrownError","qualifiedName":"unittest/matcher.isNullThrownError","comment":"<p>A matcher for NullThrownError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isPositive":{"name":"isPositive","qualifiedName":"unittest/matcher.isPositive","comment":"<p>A matcher which matches if the match argument is positive.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isRangeError":{"name":"isRangeError","qualifiedName":"unittest/matcher.isRangeError","comment":"<p>A matcher for RangeErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isStateError":{"name":"isStateError","qualifiedName":"unittest/matcher.isStateError","comment":"<p>A matcher for StateErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isTrue":{"name":"isTrue","qualifiedName":"unittest/matcher.isTrue","comment":"<p>A matcher that matches the Boolean value true.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isUnimplementedError":{"name":"isUnimplementedError","qualifiedName":"unittest/matcher.isUnimplementedError","comment":"<p>A matcher for UnimplementedErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isUnsupportedError":{"name":"isUnsupportedError","qualifiedName":"unittest/matcher.isUnsupportedError","comment":"<p>A matcher for UnsupportedError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isZero":{"name":"isZero","qualifiedName":"unittest/matcher.isZero","comment":"<p>A matcher which matches if the match argument is zero.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"returnsNormally":{"name":"returnsNormally","qualifiedName":"unittest/matcher.returnsNormally","comment":"<p>A matcher that matches a function call against no exception.\nThe function will be called once. Any exceptions will be silently swallowed.\nThe value passed to expect() should be a reference to the function.\nNote that the function cannot take arguments; to handle this\na wrapper will have to be created.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throws":{"name":"throws","qualifiedName":"unittest/matcher.throws","comment":"<p>This can be used to match two kinds of objects:</p><ul><li>\n<p>A <a>dart-core.Function</a> that throws an exception when called. The function cannot\ntake any arguments. If you want to test that a function expecting\narguments throws, wrap it in another zero-argument function that calls\nthe one you want to test.</p></li><li>\n<p>A <a>dart-async.Future</a> that completes with an exception. Note that this creates an\nasynchronous expectation. The call to <code>expect()</code> that includes this will\nreturn immediately and execution will continue. Later, when the future\ncompletes, the actual expectation will run.</p></li></ul>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsAbstractClassInstantiationError":{"name":"throwsAbstractClassInstantiationError","qualifiedName":"unittest/matcher.throwsAbstractClassInstantiationError","comment":"<p>A matcher for functions that throw AbstractClassInstantiationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsArgumentError":{"name":"throwsArgumentError","qualifiedName":"unittest/matcher.throwsArgumentError","comment":"<p>A matcher for functions that throw ArgumentError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsConcurrentModificationError":{"name":"throwsConcurrentModificationError","qualifiedName":"unittest/matcher.throwsConcurrentModificationError","comment":"<p>A matcher for functions that throw ConcurrentModificationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsCyclicInitializationError":{"name":"throwsCyclicInitializationError","qualifiedName":"unittest/matcher.throwsCyclicInitializationError","comment":"<p>A matcher for functions that throw CyclicInitializationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsException":{"name":"throwsException","qualifiedName":"unittest/matcher.throwsException","comment":"<p>A matcher for functions that throw Exception.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsFallThroughError":{"name":"throwsFallThroughError","qualifiedName":"unittest/matcher.throwsFallThroughError","comment":"<p>A matcher for functions that throw FallThroughError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsFormatException":{"name":"throwsFormatException","qualifiedName":"unittest/matcher.throwsFormatException","comment":"<p>A matcher for functions that throw FormatException.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsNoSuchMethodError":{"name":"throwsNoSuchMethodError","qualifiedName":"unittest/matcher.throwsNoSuchMethodError","comment":"<p>A matcher for functions that throw NoSuchMethodError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsNullThrownError":{"name":"throwsNullThrownError","qualifiedName":"unittest/matcher.throwsNullThrownError","comment":"<p>A matcher for functions that throw NullThrownError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsRangeError":{"name":"throwsRangeError","qualifiedName":"unittest/matcher.throwsRangeError","comment":"<p>A matcher for functions that throw RangeError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsStateError":{"name":"throwsStateError","qualifiedName":"unittest/matcher.throwsStateError","comment":"<p>A matcher for functions that throw StateError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsUnimplementedError":{"name":"throwsUnimplementedError","qualifiedName":"unittest/matcher.throwsUnimplementedError","comment":"<p>A matcher for functions that throw Exception.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsUnsupportedError":{"name":"throwsUnsupportedError","qualifiedName":"unittest/matcher.throwsUnsupportedError","comment":"<p>A matcher for functions that throw UnsupportedError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"wrapAsync":{"name":"wrapAsync","qualifiedName":"unittest/matcher.wrapAsync","comment":"<p>Some matchers, like those for Futures and exception testing,\ncan fail in asynchronous sections, and throw exceptions.\nA user of this library will typically want to catch and handle\nsuch exceptions. The <a>unittest/matcher.wrapAsync</a> property is a function that\ncan wrap callbacks used by these Matchers so that they can be\nused safely. For example, the unittest library will set this\nto be expectAsync1. By default this is an identity function.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.Function","inner":[]}],"annotations":[]}},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"addStateInfo":{"name":"addStateInfo","qualifiedName":"unittest/matcher.addStateInfo","comment":"<p>Useful utility for nesting match states.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"matchState":{"name":"matchState","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]},"values":{"name":"values","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"allOf":{"name":"allOf","qualifiedName":"unittest/matcher.allOf","comment":"<p>This returns a matcher that matches if all of the matchers passed as\narguments (up to 7) match. Instead of passing the matchers separately\nthey can be passed as a single List argument.\nAny argument that is not a matcher is implicitly wrapped in a\nMatcher to check for equality.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"arg0":{"name":"arg0","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"arg1":{"name":"arg1","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg2":{"name":"arg2","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg3":{"name":"arg3","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg4":{"name":"arg4","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg5":{"name":"arg5","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg6":{"name":"arg6","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"anyElement":{"name":"anyElement","qualifiedName":"unittest/matcher.anyElement","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s in which at least one\nelement matches the given <a>unittest/matcher.anyElement.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"anyOf":{"name":"anyOf","qualifiedName":"unittest/matcher.anyOf","comment":"<p>Matches if any of the given matchers evaluate to true. The\narguments can be a set of matchers as separate parameters\n(up to 7), or a List of matchers.</p>\n<p>The matchers are evaluated from left to right using short-circuit\nevaluation, so evaluation stops as soon as a matcher returns true.</p>\n<p>Any argument that is not a matcher is implicitly wrapped in a\nMatcher to check for equality.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"arg0":{"name":"arg0","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"arg1":{"name":"arg1","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg2":{"name":"arg2","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg3":{"name":"arg3","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg4":{"name":"arg4","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg5":{"name":"arg5","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg6":{"name":"arg6","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"closeTo":{"name":"closeTo","qualifiedName":"unittest/matcher.closeTo","comment":"<p>Returns a matcher which matches if the match argument is within <a>unittest/matcher.closeTo.delta</a>\nof some <a>unittest/matcher.closeTo.value</a>; i.e. if the match argument is greater than\nthan or equal <a>unittest/matcher.closeTo.value</a>-<a>unittest/matcher.closeTo.delta</a> and less than or equal to <a>unittest/matcher.closeTo.value</a>+<a>unittest/matcher.closeTo.delta</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"delta":{"name":"delta","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"collapseWhitespace":{"name":"collapseWhitespace","qualifiedName":"unittest/matcher.collapseWhitespace","comment":"<p>Utility function to collapse whitespace runs to single spaces\nand strip leading/trailing whitespace.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"_string":{"name":"_string","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"completion":{"name":"completion","qualifiedName":"unittest/matcher.completion","comment":"<p>Matches a <a>unittest/dart-async.Future</a> that completes succesfully with a value that matches\n<a>unittest/matcher.completion.matcher</a>. Note that this creates an asynchronous expectation. The call to\n<code>expect()</code> that includes this will return immediately and execution will\ncontinue. Later, when the future completes, the actual expectation will run.</p>\n<p>To test that a Future completes with an exception, you can use <a>unittest/matcher.throws</a> and\n<a>unittest/matcher.throwsA</a>.</p>\n<p><a>unittest/matcher.completion.id</a> is an optional tag that can be used to identify the completion matcher\nin error messages.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"id":{"name":"id","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.String","inner":[]}],"value":"\"\"","annotations":[]}},"annotations":[]},"configureExpectFailureHandler":{"name":"configureExpectFailureHandler","qualifiedName":"unittest/matcher.configureExpectFailureHandler","comment":"<p>Changes or resets to the default the failure handler for expect()\n<a>unittest/matcher.configureExpectFailureHandler.handler</a> is a reference to the new handler; if this is omitted\nor null then the failure handler is reset to the default, which\nthrows <a>unittest/matcher.TestFailure</a>s on <a>unittest/matcher.expect</a> assertion failures.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"handler":{"name":"handler","optional":true,"named":false,"default":true,"type":[{"outer":"unittest/matcher.FailureHandler","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"configureExpectFormatter":{"name":"configureExpectFormatter","qualifiedName":"unittest/matcher.configureExpectFormatter","comment":"<p>Changes or resets to default the failure message formatter for expect().\n<a>unittest/matcher.configureExpectFormatter.formatter</a> is a reference to the new formatter; if this is omitted or\nnull then the failure formatter is reset to the default. The new\nformatter is returned; this allows custom expect handlers to easily\nget a reference to the default formatter.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.ErrorFormatter","inner":[]}],"parameters":{"formatter":{"name":"formatter","optional":true,"named":false,"default":true,"type":[{"outer":"unittest/matcher.ErrorFormatter","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"contains":{"name":"contains","qualifiedName":"unittest/matcher.contains","comment":"<p>Returns a matcher that matches if the match argument contains\nthe expected value. For <a>dart-core.String</a>s this means substring matching;\nfor <a>dart-core.Map</a>s it means the map has the key, and for <a>dart-core.Iterable</a>s\n(including <a>dart-core.Iterable</a>s) it means the iterable has a matching\nelement. In the case of iterables, <a>unittest/matcher.contains.expected</a> can itself be a\nmatcher.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"containsPair":{"name":"containsPair","qualifiedName":"unittest/matcher.containsPair","comment":"<p>Returns a matcher which matches maps containing the key-value pair\nwith <a>unittest/matcher.containsPair.key</a> => <a>unittest/matcher.containsPair.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"key":{"name":"key","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"containsValue":{"name":"containsValue","qualifiedName":"unittest/matcher.containsValue","comment":"<p>Returns a matcher which matches maps containing the given <a>unittest/matcher.containsValue.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"endsWith":{"name":"endsWith","qualifiedName":"unittest/matcher.endsWith","comment":"<p>Returns a matcher that matches if the match argument is a string and\nends with <a>unittest/matcher.endsWith.suffixString</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"suffixString":{"name":"suffixString","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"equals":{"name":"equals","qualifiedName":"unittest/matcher.equals","comment":"<p>Returns a matcher that does a deep recursive match. This only works\nwith scalars, Maps and Iterables. To handle cyclic structures a\nrecursion depth <a>unittest/matcher.equals.limit</a> can be provided. The default limit is 100.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"limit":{"name":"limit","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"100","annotations":[]}},"annotations":[]},"equalsIgnoringCase":{"name":"equalsIgnoringCase","qualifiedName":"unittest/matcher.equalsIgnoringCase","comment":"<p>Returns a matcher which matches if the match argument is a string and\nis equal to <a>unittest/matcher.equalsIgnoringCase.value</a> when compared case-insensitively.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"equalsIgnoringWhitespace":{"name":"equalsIgnoringWhitespace","qualifiedName":"unittest/matcher.equalsIgnoringWhitespace","comment":"<p>Returns a matcher which matches if the match argument is a string and\nis equal to value when compared with all runs of whitespace\ncollapsed to single spaces and leading and trailing whitespace removed.</p>\n<p>For example, <code>equalsIgnoringCase(\"hello world\")</code> will match\n\"hello   world\", \"  hello world\" and \"hello world  \".</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"_string":{"name":"_string","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"everyElement":{"name":"everyElement","qualifiedName":"unittest/matcher.everyElement","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s in which all elements\nmatch the given <a>unittest/matcher.everyElement.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"expect":{"name":"expect","qualifiedName":"unittest/matcher.expect","comment":"<p>This is the main assertion function. It asserts that <a>unittest/matcher.expect.actual</a>\nmatches the <a>unittest/matcher.expect.matcher</a>. <a>unittest/matcher.expect.reason</a> is optional and is typically not\nsupplied, as a reason is generated from the matcher; if <a>unittest/matcher.expect.reason</a>\nis included it is appended to the reason generated by the matcher.</p>\n<p><a>unittest/matcher.expect.matcher</a> can be a value in which case it will be wrapped in an\n<a>unittest/matcher.equals</a> matcher.</p>\n<p>If the assertion fails, then the default behavior is to throw a\n<a>unittest/matcher.TestFailure</a>, but this behavior can be changed by calling\n<a>unittest/matcher.configureExpectFailureHandler</a> and providing an alternative handler that\nimplements the IFailureHandler interface. It is also possible to\npass a <a>unittest/matcher.expect.failureHandler</a> to <a>unittest/matcher.expect</a> as a final parameter for fine-\ngrained control.</p>\n<p>In some cases extra diagnostic info can be produced on failure (for\nexample, stack traces on mismatched exceptions). To enable these,\n<a>unittest/matcher.expect.verbose</a> should be specified as true;</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"actual":{"name":"actual","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"reason":{"name":"reason","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"failureHandler":{"name":"failureHandler","optional":true,"named":true,"default":false,"type":[{"outer":"unittest/matcher.FailureHandler","inner":[]}],"value":null,"annotations":[]},"verbose":{"name":"verbose","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"fail":{"name":"fail","qualifiedName":"unittest/matcher.fail","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"failureHandler":{"name":"failureHandler","optional":true,"named":true,"default":false,"type":[{"outer":"unittest/matcher.FailureHandler","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"getOrCreateExpectFailureHandler":{"name":"getOrCreateExpectFailureHandler","qualifiedName":"unittest/matcher.getOrCreateExpectFailureHandler","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.FailureHandler","inner":[]}],"parameters":{},"annotations":[]},"greaterThan":{"name":"greaterThan","qualifiedName":"unittest/matcher.greaterThan","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan the given <a>unittest/matcher.greaterThan.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"greaterThanOrEqualTo":{"name":"greaterThanOrEqualTo","qualifiedName":"unittest/matcher.greaterThanOrEqualTo","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to the given <a>unittest/matcher.greaterThanOrEqualTo.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"hasLength":{"name":"hasLength","qualifiedName":"unittest/matcher.hasLength","comment":"<p>Returns a matcher that matches if an object has a length property\nthat matches <a>unittest/matcher.hasLength.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inClosedOpenRange":{"name":"inClosedOpenRange","qualifiedName":"unittest/matcher.inClosedOpenRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to a <a>unittest/matcher.inClosedOpenRange.low</a> and less than <a>unittest/matcher.inClosedOpenRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inExclusiveRange":{"name":"inExclusiveRange","qualifiedName":"unittest/matcher.inExclusiveRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan <a>unittest/matcher.inExclusiveRange.low</a> and less than <a>unittest/matcher.inExclusiveRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inInclusiveRange":{"name":"inInclusiveRange","qualifiedName":"unittest/matcher.inInclusiveRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to <a>unittest/matcher.inInclusiveRange.low</a> and less than or equal to <a>unittest/matcher.inInclusiveRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inOpenClosedRange":{"name":"inOpenClosedRange","qualifiedName":"unittest/matcher.inOpenClosedRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan <a>unittest/matcher.inOpenClosedRange.low</a> and less than or equal to <a>unittest/matcher.inOpenClosedRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isIn":{"name":"isIn","qualifiedName":"unittest/matcher.isIn","comment":"<p>Returns a matcher that matches if the match argument is in\nthe expected value. This is the converse of <a>unittest/matcher.contains</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isNot":{"name":"isNot","qualifiedName":"unittest/matcher.isNot","comment":"<p>This returns a matcher that inverts <a>unittest/matcher.isNot.matcher</a> to its logical negation.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"lessThan":{"name":"lessThan","qualifiedName":"unittest/matcher.lessThan","comment":"<p>Returns a matcher which matches if the match argument is less\nthan the given <a>unittest/matcher.lessThan.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"lessThanOrEqualTo":{"name":"lessThanOrEqualTo","qualifiedName":"unittest/matcher.lessThanOrEqualTo","comment":"<p>Returns a matcher which matches if the match argument is less\nthan or equal to the given <a>unittest/matcher.lessThanOrEqualTo.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"matches":{"name":"matches","qualifiedName":"unittest/matcher.matches","comment":"<p>Returns a matcher that matches if the match argument is a string and\nmatches the regular expression given by <a>unittest/matcher.matches.re</a>. <a>unittest/matcher.matches.re</a> can be a RegExp\ninstance or a string; in the latter case it will be used to create\na RegExp instance.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"re":{"name":"re","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"orderedEquals":{"name":"orderedEquals","qualifiedName":"unittest/matcher.orderedEquals","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s that have the same\nlength and the same elements as <a>unittest/matcher.orderedEquals.expected</a>, and in the same order.\nThis is equivalent to equals but does not recurse.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"pairwiseCompare":{"name":"pairwiseCompare","qualifiedName":"unittest/matcher.pairwiseCompare","comment":"<p>A pairwise matcher for iterable. You can pass an arbitrary <a>unittest/matcher.pairwiseCompare.comparator</a>\nfunction that takes an expected and actual argument which will be applied\nto each pair in order. <a>unittest/matcher.pairwiseCompare.description</a>  should be a meaningful name for\nthe comparator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]},"comparator":{"name":"comparator","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"predicate":{"name":"predicate","qualifiedName":"unittest/matcher.predicate","comment":"<p>Returns a matcher that uses an arbitrary function that returns\ntrue or false for the actual value. For example:</p>\n<pre><code>expect(v, predicate((x) =&gt; ((x % 2) == 0), \"is even\"))\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"description":{"name":"description","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"\"satisfies function\"","annotations":[]}},"annotations":[]},"same":{"name":"same","qualifiedName":"unittest/matcher.same","comment":"<p>Returns a matches that matches if the value is the same instance\nas <a href=\"`===`\">object</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"startsWith":{"name":"startsWith","qualifiedName":"unittest/matcher.startsWith","comment":"<p>Returns a matcher that matches if the match argument is a string and\nstarts with <a>unittest/matcher.startsWith.prefixString</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"prefixString":{"name":"prefixString","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"stringContainsInOrder":{"name":"stringContainsInOrder","qualifiedName":"unittest/matcher.stringContainsInOrder","comment":"<p>Returns a matcher that matches if the match argument is a string and\ncontains a given list of <a>unittest/matcher.stringContainsInOrder.substrings</a> in relative order.</p>\n<p>For example, <code>stringContainsInOrder([\"a\", \"e\", \"i\", \"o\", \"u\"])</code> will match\n\"abcdefghijklmnopqrstuvwxyz\".</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"substrings":{"name":"substrings","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"throwsA":{"name":"throwsA","qualifiedName":"unittest/matcher.throwsA","comment":"<p>This can be used to match two kinds of objects:</p><ul><li>\n<p>A <a>dart-core.Function</a> that throws an exception when called. The function cannot\ntake any arguments. If you want to test that a function expecting\narguments throws, wrap it in another zero-argument function that calls\nthe one you want to test.</p></li><li>\n<p>A <a>unittest/dart-async.Future</a> that completes with an exception. Note that this creates an\nasynchronous expectation. The call to <code>expect()</code> that includes this will\nreturn immediately and execution will continue. Later, when the future\ncompletes, the actual expectation will run.</p></li></ul>\n<p>In both cases, when an exception is thrown, this will test that the exception\nobject matches <a>unittest/matcher.throwsA.matcher</a>. If <a>unittest/matcher.throwsA.matcher</a> is not an instance of <a>unittest/matcher.Matcher</a>, it\nwill implicitly be treated as <code>equals(matcher)</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"unorderedEquals":{"name":"unorderedEquals","qualifiedName":"unittest/matcher.unorderedEquals","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s that have the same\nlength and the same elements as <a>unittest/matcher.unorderedEquals.expected</a>, but not necessarily in\nthe same order. Note that this is O(n^2) so should only be used on\nsmall objects.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"wrapMatcher":{"name":"wrapMatcher","qualifiedName":"unittest/matcher.wrapMatcher","comment":"<p>Takes an argument and returns an equivalent matcher.\nIf the argument is already a matcher this does nothing,\nelse if the argument is a function, it generates a predicate\nfunction matcher, else it generates an equals matcher.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/matcher.Matcher","inner":[]}],"parameters":{"x":{"name":"x","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"CustomMatcher","qualifiedName":"unittest/matcher.CustomMatcher","preview":"<p>A useful utility class for implementing other matchers through inheritance.\nDerived classes should call the base constructor with a feature name and\ndescription, and an instance matcher, and should implement the\n<a>unittest/matcher.CustomMatcher.featureValueOf</a> abstract method.</p>"},{"name":"DefaultFailureHandler","qualifiedName":"unittest/matcher.DefaultFailureHandler"},{"name":"Description","qualifiedName":"unittest/matcher.Description","preview":"<p>Matchers build up their error messages by appending to\nDescription objects. This interface is implemented by\nStringDescription. This interface is unlikely to need\nother implementations, but could be useful to replace in\nsome cases - e.g. language conversion.</p>"},{"name":"FailureHandler","qualifiedName":"unittest/matcher.FailureHandler","preview":"<p>Failed matches are reported using a default IFailureHandler.\nThe default implementation simply throws <a>unittest/matcher.TestFailure</a>s;\nthis can be replaced by some other implementation of\nIFailureHandler by calling configureExpectHandler.</p>"},{"name":"Matcher","qualifiedName":"unittest/matcher.Matcher","preview":"<p><a>unittest/matcher.expect</a> Matchers must implement/extend the Matcher class.\nThe base Matcher class has a generic implementation of <a>unittest/matcher.Matcher.describeMismatch</a>\nso this does not need to be provided unless a more clear description is\nrequired. The other two methods (<a>unittest/matcher.Matcher.matches</a> and <a>unittest/matcher.Matcher.describe</a>)\nmust always be provided as they are highly matcher-specific.</p>"},{"name":"StringDescription","qualifiedName":"unittest/matcher.StringDescription","preview":"<p>The default implementation of IDescription. This should rarely need\nsubstitution, although conceivably it is a place where other languages\ncould be supported.</p>"},{"name":"Throws","qualifiedName":"unittest/matcher.Throws"},{"name":"TypeMatcher","qualifiedName":"unittest/matcher.TypeMatcher"},{"name":"isInstanceOf","qualifiedName":"unittest/matcher.isInstanceOf","preview":"<p>Returns a matcher that matches if an object is an instance\nof type (or a subtype).</p>"}],"typedef":{"ErrorFormatter":{"name":"ErrorFormatter","qualifiedName":"unittest/matcher.ErrorFormatter","comment":"<p>The ErrorFormatter type is used for functions that\ncan be used to build up error reports upon <a>unittest/matcher.expect</a> failures.\nThere is one built-in implementation (defaultErrorFormatter)\nwhich is used by the default failure handler. If the failure handler\nis replaced it may be desirable to replace the stringDescription\nerror formatter with another.</p>","return":"dart-core.String","parameters":{"actual":{"name":"actual","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"value":null,"annotations":[]},"reason":{"name":"reason","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"matchState":{"name":"matchState","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]},"verbose":{"name":"verbose","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.bool","inner":[]}],"value":null,"annotations":[]}},"annotations":[],"generics":{},"preview":"<p>The ErrorFormatter type is used for functions that\ncan be used to build up error reports upon <a>unittest/matcher.expect</a> failures.\nThere is one built-in implementation (defaultErrorFormatter)\nwhich is used by the default failure handler. If the failure handler\nis replaced it may be desirable to replace the stringDescription\nerror formatter with another.</p>"}},"error":[{"name":"TestFailure","qualifiedName":"unittest/matcher.TestFailure","preview":"<p>The objects thrown by the default failure handler.</p>"}]},"packageName":"unittest","packageIntro":""}