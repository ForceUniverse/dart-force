{"name":"unittest","qualifiedName":"unittest/unittest","comment":"<p>Support for writing Dart unit tests.</p>\n<p>For information on installing and importing this library, see the\n<a href=\"http://pub.dartlang.org/packages/unittest\">unittest package on pub.dartlang.org</a>.</p>\n<p><strong>See also:</strong>\n<a href=\"http://www.dartlang.org/articles/dart-unit-tests/\">Unit Testing with Dart</a></p>\n<h2>Concepts</h2><ul><li>\n<p><strong>Tests</strong>: Tests are specified via the top-level function <a>unittest/unittest.test</a>, they can be\n   organized together using <a>unittest/unittest.group</a>.</p></li><li>\n<p><strong>Checks</strong>: Test expectations can be specified via <a>unittest/unittest.expect</a></p></li><li>\n<p><strong>Matchers</strong>: <a>unittest/unittest.expect</a> assertions are written declaratively using the\n   <a>unittest/unittest.Matcher</a> class.</p></li><li>\n<p><strong>Configuration</strong>: The framework can be adapted by setting\n   <a>unittest/unittest.unittestConfiguration</a> with a <a>unittest/unittest.Configuration</a>. See the other libraries\n   in the <code>unittest</code> package for alternative implementations of\n   <a>unittest/unittest.Configuration</a> including <code>compact_vm_config.dart</code>, <code>html_config.dart</code> and\n   <code>html_enhanced_config.dart</code>.</p></li></ul>\n<h2>Examples</h2>\n<p>A trivial test:</p>\n<pre><code>import 'package:unittest/unittest.dart';\nmain() {\n  test('this is a test', () {\n    int x = 2 + 3;\n    expect(x, equals(5));\n  });\n}\n</code></pre>\n<p>Multiple tests:</p>\n<pre><code>import 'package:unittest/unittest.dart';\nmain() {\n  test('this is a test', () {\n    int x = 2 + 3;\n    expect(x, equals(5));\n  });\n  test('this is another test', () {\n    int x = 2 + 3;\n    expect(x, equals(5));\n  });\n}\n</code></pre>\n<p>Multiple tests, grouped by category:</p>\n<pre><code>import 'package:unittest/unittest.dart';\nmain() {\n  group('group A', () {\n    test('test A.1', () {\n      int x = 2 + 3;\n      expect(x, equals(5));\n    });\n    test('test A.2', () {\n      int x = 2 + 3;\n      expect(x, equals(5));\n    });\n  });\n  group('group B', () {\n    test('this B.1', () {\n      int x = 2 + 3;\n      expect(x, equals(5));\n    });\n  });\n}\n</code></pre>\n<p>Asynchronous tests: if callbacks expect between 0 and 2 positional arguments,\ndepending on the suffix of expectAsyncX(). expectAsyncX() will wrap a\nfunction into a new callback and will not consider the test complete until\nthat callback is run. A count argument can be provided to specify the number\nof times the callback should be called (the default is 1).</p>\n<pre><code>import 'package:unittest/unittest.dart';\nimport 'dart:isolate';\nmain() {\n  test('callback is executed once', () {\n    // wrap the callback of an asynchronous call with [expectAsync0] if\n    // the callback takes 0 arguments...\n    var timer = Timer.run(expectAsync0(() {\n      int x = 2 + 3;\n      expect(x, equals(5));\n    }));\n  });\n\n  test('callback is executed twice', () {\n    var callback = expectAsync0(() {\n      int x = 2 + 3;\n      expect(x, equals(5));\n    }, count: 2); // &lt;-- we can indicate multiplicity to [expectAsync0]\n    Timer.run(callback);\n    Timer.run(callback);\n  });\n}\n</code></pre>\n<p>expectAsyncX() will wrap the callback code in a try/catch handler to handle\nexceptions (treated as test failures). There may be times when the number of\ntimes a callback should be called is non-deterministic. In this case a dummy\ncallback can be created with expectAsync0((){}) and this can be called from\nthe real callback when it is finally complete. In this case the body of the\ncallback should be protected within a call to guardAsync(); this will ensure\nthat exceptions are properly handled.</p>\n<p>A variation on this is expectAsyncUntilX(), which takes a callback as the\nfirst parameter and a predicate function as the second parameter; after each\ntime * the callback is called, the predicate function will be called; if it\nreturns false the test will still be considered incomplete.</p>\n<p>Test functions can return <a>unittest/dart-async.Future</a>s, which provide another way of doing\nasynchronous tests. The test framework will handle exceptions thrown by\nthe Future, and will advance to the next test when the Future is complete.\nIt is still important to use expectAsync/guardAsync with any parts of the\ntest that may be invoked from a top level context (for example, with\nTimer.run()], as the Future exception handler may not capture exceptions\nin such code.</p>\n<p>Note: Due to some language limitations we have to use different functions\ndepending on the number of positional arguments of the callback. In the\nfuture, we plan to expose a single <code>expectAsync</code> function that can be used\nregardless of the number of positional arguments. This requires new langauge\nfeatures or fixes to the current spec (e.g. see\n<a href=\"http://dartbug.com/2706\">Issue 2706</a>).</p>","variables":{"BREATH_INTERVAL":{"name":"BREATH_INTERVAL","qualifiedName":"unittest/unittest.BREATH_INTERVAL","comment":"<p>Interval (in msecs) after which synchronous tests will insert an async\ndelay to allow DOM or other updates.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]},"ERROR":{"name":"ERROR","qualifiedName":"unittest/unittest.ERROR","comment":"","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"FAIL":{"name":"FAIL","qualifiedName":"unittest/unittest.FAIL","comment":"","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"PASS":{"name":"PASS","qualifiedName":"unittest/unittest.PASS","comment":"<p>Test case result strings.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"anything":{"name":"anything","qualifiedName":"unittest/matcher.anything","comment":"<p>A matcher that matches any value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"completes":{"name":"completes","qualifiedName":"unittest/matcher.completes","comment":"<p>Matches a <a>dart-async.Future</a> that completes successfully with a value. Note that this\ncreates an asynchronous expectation. The call to <code>expect()</code> that includes\nthis will return immediately and execution will continue. Later, when the\nfuture completes, the actual expectation will run.</p>\n<p>To test that a Future completes with an exception, you can use <a>unittest/matcher.throws</a> and\n<a>unittest/matcher.throwsA</a>.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"filterStacks":{"name":"filterStacks","qualifiedName":"unittest/unittest.filterStacks","comment":"<p>A flag that controls whether we try to filter out irrelevant frames from\nthe stack trace. Requires formatStacks to be set.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.bool","inner":[]}],"annotations":[]},"formatStacks":{"name":"formatStacks","qualifiedName":"unittest/unittest.formatStacks","comment":"<p>A flag that controls whether we hide unittest and core library details in\nexception stacks.</p>\n<p>Useful to disable when debugging unittest or matcher customizations.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.bool","inner":[]}],"annotations":[]},"groupSep":{"name":"groupSep","qualifiedName":"unittest/unittest.groupSep","comment":"<p>Separator used between group names and test names.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"isAbstractClassInstantiationError":{"name":"isAbstractClassInstantiationError","qualifiedName":"unittest/matcher.isAbstractClassInstantiationError","comment":"<p>A matcher for AbstractClassInstantiationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isArgumentError":{"name":"isArgumentError","qualifiedName":"unittest/matcher.isArgumentError","comment":"<p>A matcher for ArgumentErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isConcurrentModificationError":{"name":"isConcurrentModificationError","qualifiedName":"unittest/matcher.isConcurrentModificationError","comment":"<p>A matcher for ConcurrentModificationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isCyclicInitializationError":{"name":"isCyclicInitializationError","qualifiedName":"unittest/matcher.isCyclicInitializationError","comment":"<p>A matcher for CyclicInitializationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isEmpty":{"name":"isEmpty","qualifiedName":"unittest/matcher.isEmpty","comment":"<p>Returns a matcher that matches empty strings, maps or iterables\n(including collections).</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isException":{"name":"isException","qualifiedName":"unittest/matcher.isException","comment":"<p>A matcher for Exceptions.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isFallThroughError":{"name":"isFallThroughError","qualifiedName":"unittest/matcher.isFallThroughError","comment":"<p>A matcher for FallThroughError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isFalse":{"name":"isFalse","qualifiedName":"unittest/matcher.isFalse","comment":"<p>A matcher that matches anything except the Boolean value true.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isFormatException":{"name":"isFormatException","qualifiedName":"unittest/matcher.isFormatException","comment":"<p>A matcher for FormatExceptions.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isList":{"name":"isList","qualifiedName":"unittest/matcher.isList","comment":"<p>A matcher for List types.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isMap":{"name":"isMap","qualifiedName":"unittest/matcher.isMap","comment":"<p>A matcher for Map types.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isNegative":{"name":"isNegative","qualifiedName":"unittest/matcher.isNegative","comment":"<p>A matcher which matches if the match argument is negative.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isNoSuchMethodError":{"name":"isNoSuchMethodError","qualifiedName":"unittest/matcher.isNoSuchMethodError","comment":"<p>A matcher for NoSuchMethodErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isNonNegative":{"name":"isNonNegative","qualifiedName":"unittest/matcher.isNonNegative","comment":"<p>A matcher which matches if the match argument is zero or positive.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isNonPositive":{"name":"isNonPositive","qualifiedName":"unittest/matcher.isNonPositive","comment":"<p>A matcher which matches if the match argument is zero or negative.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isNonZero":{"name":"isNonZero","qualifiedName":"unittest/matcher.isNonZero","comment":"<p>A matcher which matches if the match argument is non-zero.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isNotNull":{"name":"isNotNull","qualifiedName":"unittest/matcher.isNotNull","comment":"<p>A matcher that matches any non-null value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isNull":{"name":"isNull","qualifiedName":"unittest/matcher.isNull","comment":"<p>A matcher that matches any null value.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isNullThrownError":{"name":"isNullThrownError","qualifiedName":"unittest/matcher.isNullThrownError","comment":"<p>A matcher for NullThrownError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isPositive":{"name":"isPositive","qualifiedName":"unittest/matcher.isPositive","comment":"<p>A matcher which matches if the match argument is positive.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isRangeError":{"name":"isRangeError","qualifiedName":"unittest/matcher.isRangeError","comment":"<p>A matcher for RangeErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isStateError":{"name":"isStateError","qualifiedName":"unittest/matcher.isStateError","comment":"<p>A matcher for StateErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isTrue":{"name":"isTrue","qualifiedName":"unittest/matcher.isTrue","comment":"<p>A matcher that matches the Boolean value true.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"isUnimplementedError":{"name":"isUnimplementedError","qualifiedName":"unittest/matcher.isUnimplementedError","comment":"<p>A matcher for UnimplementedErrors.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isUnsupportedError":{"name":"isUnsupportedError","qualifiedName":"unittest/matcher.isUnsupportedError","comment":"<p>A matcher for UnsupportedError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"isZero":{"name":"isZero","qualifiedName":"unittest/matcher.isZero","comment":"<p>A matcher which matches if the match argument is zero.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"returnsNormally":{"name":"returnsNormally","qualifiedName":"unittest/matcher.returnsNormally","comment":"<p>A matcher that matches a function call against no exception.\nThe function will be called once. Any exceptions will be silently swallowed.\nThe value passed to expect() should be a reference to the function.\nNote that the function cannot take arguments; to handle this\na wrapper will have to be created.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"testCases":{"name":"testCases","qualifiedName":"unittest/unittest.testCases","comment":"<p>Tests executed in this suite.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"unittest/unittest.TestCase","inner":[]}]}],"annotations":[]},"throws":{"name":"throws","qualifiedName":"unittest/matcher.throws","comment":"<p>This can be used to match two kinds of objects:</p><ul><li>\n<p>A <a>dart-core.Function</a> that throws an exception when called. The function cannot\ntake any arguments. If you want to test that a function expecting\narguments throws, wrap it in another zero-argument function that calls\nthe one you want to test.</p></li><li>\n<p>A <a>dart-async.Future</a> that completes with an exception. Note that this creates an\nasynchronous expectation. The call to <code>expect()</code> that includes this will\nreturn immediately and execution will continue. Later, when the future\ncompletes, the actual expectation will run.</p></li></ul>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsAbstractClassInstantiationError":{"name":"throwsAbstractClassInstantiationError","qualifiedName":"unittest/matcher.throwsAbstractClassInstantiationError","comment":"<p>A matcher for functions that throw AbstractClassInstantiationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsArgumentError":{"name":"throwsArgumentError","qualifiedName":"unittest/matcher.throwsArgumentError","comment":"<p>A matcher for functions that throw ArgumentError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsConcurrentModificationError":{"name":"throwsConcurrentModificationError","qualifiedName":"unittest/matcher.throwsConcurrentModificationError","comment":"<p>A matcher for functions that throw ConcurrentModificationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsCyclicInitializationError":{"name":"throwsCyclicInitializationError","qualifiedName":"unittest/matcher.throwsCyclicInitializationError","comment":"<p>A matcher for functions that throw CyclicInitializationError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsException":{"name":"throwsException","qualifiedName":"unittest/matcher.throwsException","comment":"<p>A matcher for functions that throw Exception.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsFallThroughError":{"name":"throwsFallThroughError","qualifiedName":"unittest/matcher.throwsFallThroughError","comment":"<p>A matcher for functions that throw FallThroughError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsFormatException":{"name":"throwsFormatException","qualifiedName":"unittest/matcher.throwsFormatException","comment":"<p>A matcher for functions that throw FormatException.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsNoSuchMethodError":{"name":"throwsNoSuchMethodError","qualifiedName":"unittest/matcher.throwsNoSuchMethodError","comment":"<p>A matcher for functions that throw NoSuchMethodError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsNullThrownError":{"name":"throwsNullThrownError","qualifiedName":"unittest/matcher.throwsNullThrownError","comment":"<p>A matcher for functions that throw NullThrownError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsRangeError":{"name":"throwsRangeError","qualifiedName":"unittest/matcher.throwsRangeError","comment":"<p>A matcher for functions that throw RangeError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsStateError":{"name":"throwsStateError","qualifiedName":"unittest/matcher.throwsStateError","comment":"<p>A matcher for functions that throw StateError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsUnimplementedError":{"name":"throwsUnimplementedError","qualifiedName":"unittest/matcher.throwsUnimplementedError","comment":"<p>A matcher for functions that throw Exception.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"throwsUnsupportedError":{"name":"throwsUnsupportedError","qualifiedName":"unittest/matcher.throwsUnsupportedError","comment":"<p>A matcher for functions that throw UnsupportedError.</p>","final":false,"static":false,"constant":true,"type":[{"outer":"unittest/matcher.Matcher","inner":[]}],"annotations":[]},"wrapAsync":{"name":"wrapAsync","qualifiedName":"unittest/matcher.wrapAsync","comment":"<p>Some matchers, like those for Futures and exception testing,\ncan fail in asynchronous sections, and throw exceptions.\nA user of this library will typically want to catch and handle\nsuch exceptions. The <a>unittest/matcher.wrapAsync</a> property is a function that\ncan wrap callbacks used by these Matchers so that they can be\nused safely. For example, the unittest library will set this\nto be expectAsync1. By default this is an identity function.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.Function","inner":[]}],"annotations":[]}},"functions":{"setters":{"unittestConfiguration=":{"name":"unittestConfiguration=","qualifiedName":"unittest/unittest.unittestConfiguration=","comment":"<p>Sets the <a>unittest/unittest.Configuration</a> used by the unittest library.</p>\n<p>Throws a <a>dart-core.StateError</a> if there is an existing, incompatible value.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"unittest/unittest.Configuration","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"getters":{"currentTestCase":{"name":"currentTestCase","qualifiedName":"unittest/unittest.currentTestCase","comment":"<p><a>unittest/unittest.TestCase</a> currently being executed.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.TestCase","inner":[]}],"parameters":{},"annotations":[]},"unittestConfiguration":{"name":"unittestConfiguration","qualifiedName":"unittest/unittest.unittestConfiguration","comment":"<p><a>unittest/unittest.Configuration</a> used by the unittest library. Note that if a\nconfiguration has not been set, calling this getter will create\na default configuration.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Configuration","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{},"methods":{"addStateInfo":{"name":"addStateInfo","qualifiedName":"unittest/unittest.addStateInfo","comment":"<p>Useful utility for nesting match states.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"matchState":{"name":"matchState","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]},"values":{"name":"values","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"allOf":{"name":"allOf","qualifiedName":"unittest/unittest.allOf","comment":"<p>This returns a matcher that matches if all of the matchers passed as\narguments (up to 7) match. Instead of passing the matchers separately\nthey can be passed as a single List argument.\nAny argument that is not a matcher is implicitly wrapped in a\nMatcher to check for equality.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"arg0":{"name":"arg0","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"arg1":{"name":"arg1","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg2":{"name":"arg2","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg3":{"name":"arg3","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg4":{"name":"arg4","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg5":{"name":"arg5","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg6":{"name":"arg6","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"anyElement":{"name":"anyElement","qualifiedName":"unittest/unittest.anyElement","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s in which at least one\nelement matches the given <a>unittest/unittest.anyElement.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"anyOf":{"name":"anyOf","qualifiedName":"unittest/unittest.anyOf","comment":"<p>Matches if any of the given matchers evaluate to true. The\narguments can be a set of matchers as separate parameters\n(up to 7), or a List of matchers.</p>\n<p>The matchers are evaluated from left to right using short-circuit\nevaluation, so evaluation stops as soon as a matcher returns true.</p>\n<p>Any argument that is not a matcher is implicitly wrapped in a\nMatcher to check for equality.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"arg0":{"name":"arg0","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"arg1":{"name":"arg1","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg2":{"name":"arg2","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg3":{"name":"arg3","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg4":{"name":"arg4","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg5":{"name":"arg5","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]},"arg6":{"name":"arg6","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"closeTo":{"name":"closeTo","qualifiedName":"unittest/unittest.closeTo","comment":"<p>Returns a matcher which matches if the match argument is within <a>unittest/unittest.closeTo.delta</a>\nof some <a>unittest/unittest.closeTo.value</a>; i.e. if the match argument is greater than\nthan or equal <a>unittest/unittest.closeTo.value</a>-<a>unittest/unittest.closeTo.delta</a> and less than or equal to <a>unittest/unittest.closeTo.value</a>+<a>unittest/unittest.closeTo.delta</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"delta":{"name":"delta","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"collapseWhitespace":{"name":"collapseWhitespace","qualifiedName":"unittest/unittest.collapseWhitespace","comment":"<p>Utility function to collapse whitespace runs to single spaces\nand strip leading/trailing whitespace.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"_string":{"name":"_string","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"completion":{"name":"completion","qualifiedName":"unittest/unittest.completion","comment":"<p>Matches a <a>unittest/dart-async.Future</a> that completes succesfully with a value that matches\n<a>unittest/unittest.completion.matcher</a>. Note that this creates an asynchronous expectation. The call to\n<code>expect()</code> that includes this will return immediately and execution will\ncontinue. Later, when the future completes, the actual expectation will run.</p>\n<p>To test that a Future completes with an exception, you can use <a>unittest/matcher.throws</a> and\n<a>unittest/unittest.throwsA</a>.</p>\n<p><a>unittest/unittest.completion.id</a> is an optional tag that can be used to identify the completion matcher\nin error messages.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"id":{"name":"id","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.String","inner":[]}],"value":"\"\"","annotations":[]}},"annotations":[]},"configureExpectFailureHandler":{"name":"configureExpectFailureHandler","qualifiedName":"unittest/unittest.configureExpectFailureHandler","comment":"<p>Changes or resets to the default the failure handler for expect()\n<a>unittest/unittest.configureExpectFailureHandler.handler</a> is a reference to the new handler; if this is omitted\nor null then the failure handler is reset to the default, which\nthrows <a>unittest/unittest.TestFailure</a>s on <a>unittest/unittest.expect</a> assertion failures.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"handler":{"name":"handler","optional":true,"named":false,"default":true,"type":[{"outer":"unittest/unittest.FailureHandler","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"configureExpectFormatter":{"name":"configureExpectFormatter","qualifiedName":"unittest/unittest.configureExpectFormatter","comment":"<p>Changes or resets to default the failure message formatter for expect().\n<a>unittest/unittest.configureExpectFormatter.formatter</a> is a reference to the new formatter; if this is omitted or\nnull then the failure formatter is reset to the default. The new\nformatter is returned; this allows custom expect handlers to easily\nget a reference to the default formatter.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.ErrorFormatter","inner":[]}],"parameters":{"formatter":{"name":"formatter","optional":true,"named":false,"default":true,"type":[{"outer":"unittest/unittest.ErrorFormatter","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"contains":{"name":"contains","qualifiedName":"unittest/unittest.contains","comment":"<p>Returns a matcher that matches if the match argument contains\nthe expected value. For <a>dart-core.String</a>s this means substring matching;\nfor <a>dart-core.Map</a>s it means the map has the key, and for <a>dart-core.Iterable</a>s\n(including <a>dart-core.Iterable</a>s) it means the iterable has a matching\nelement. In the case of iterables, <a>unittest/unittest.contains.expected</a> can itself be a\nmatcher.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"containsPair":{"name":"containsPair","qualifiedName":"unittest/unittest.containsPair","comment":"<p>Returns a matcher which matches maps containing the key-value pair\nwith <a>unittest/unittest.containsPair.key</a> => <a>unittest/unittest.containsPair.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"key":{"name":"key","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"containsValue":{"name":"containsValue","qualifiedName":"unittest/unittest.containsValue","comment":"<p>Returns a matcher which matches maps containing the given <a>unittest/unittest.containsValue.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"disableTest":{"name":"disableTest","qualifiedName":"unittest/unittest.disableTest","comment":"<p>Disable a test by ID.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"testId":{"name":"testId","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"enableTest":{"name":"enableTest","qualifiedName":"unittest/unittest.enableTest","comment":"<p>Enable a test by ID.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"testId":{"name":"testId","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"endsWith":{"name":"endsWith","qualifiedName":"unittest/unittest.endsWith","comment":"<p>Returns a matcher that matches if the match argument is a string and\nends with <a>unittest/unittest.endsWith.suffixString</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"suffixString":{"name":"suffixString","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"ensureInitialized":{"name":"ensureInitialized","qualifiedName":"unittest/unittest.ensureInitialized","comment":"<p>Lazily initializes the test library if not already initialized.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"equals":{"name":"equals","qualifiedName":"unittest/unittest.equals","comment":"<p>Returns a matcher that does a deep recursive match. This only works\nwith scalars, Maps and Iterables. To handle cyclic structures a\nrecursion depth <a>unittest/unittest.equals.limit</a> can be provided. The default limit is 100.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"limit":{"name":"limit","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"100","annotations":[]}},"annotations":[]},"equalsIgnoringCase":{"name":"equalsIgnoringCase","qualifiedName":"unittest/unittest.equalsIgnoringCase","comment":"<p>Returns a matcher which matches if the match argument is a string and\nis equal to <a>unittest/unittest.equalsIgnoringCase.value</a> when compared case-insensitively.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"equalsIgnoringWhitespace":{"name":"equalsIgnoringWhitespace","qualifiedName":"unittest/unittest.equalsIgnoringWhitespace","comment":"<p>Returns a matcher which matches if the match argument is a string and\nis equal to value when compared with all runs of whitespace\ncollapsed to single spaces and leading and trailing whitespace removed.</p>\n<p>For example, <code>equalsIgnoringCase(\"hello world\")</code> will match\n\"hello   world\", \"  hello world\" and \"hello world  \".</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"_string":{"name":"_string","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"everyElement":{"name":"everyElement","qualifiedName":"unittest/unittest.everyElement","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s in which all elements\nmatch the given <a>unittest/unittest.everyElement.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"expect":{"name":"expect","qualifiedName":"unittest/unittest.expect","comment":"<p>This is the main assertion function. It asserts that <a>unittest/unittest.expect.actual</a>\nmatches the <a>unittest/unittest.expect.matcher</a>. <a>unittest/unittest.expect.reason</a> is optional and is typically not\nsupplied, as a reason is generated from the matcher; if <a>unittest/unittest.expect.reason</a>\nis included it is appended to the reason generated by the matcher.</p>\n<p><a>unittest/unittest.expect.matcher</a> can be a value in which case it will be wrapped in an\n<a>unittest/unittest.equals</a> matcher.</p>\n<p>If the assertion fails, then the default behavior is to throw a\n<a>unittest/unittest.TestFailure</a>, but this behavior can be changed by calling\n<a>unittest/unittest.configureExpectFailureHandler</a> and providing an alternative handler that\nimplements the IFailureHandler interface. It is also possible to\npass a <a>unittest/unittest.expect.failureHandler</a> to <a>unittest/unittest.expect</a> as a final parameter for fine-\ngrained control.</p>\n<p>In some cases extra diagnostic info can be produced on failure (for\nexample, stack traces on mismatched exceptions). To enable these,\n<a>unittest/unittest.expect.verbose</a> should be specified as true;</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"actual":{"name":"actual","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"reason":{"name":"reason","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"failureHandler":{"name":"failureHandler","optional":true,"named":true,"default":false,"type":[{"outer":"unittest/unittest.FailureHandler","inner":[]}],"value":null,"annotations":[]},"verbose":{"name":"verbose","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"expectAsync0":{"name":"expectAsync0","qualifiedName":"unittest/unittest.expectAsync0","comment":"<p>Indicate that <a>unittest/unittest.expectAsync0.callback</a> is expected to be called a <a>unittest/unittest.expectAsync0.count</a> number of times\n(by default 1). The unittest framework will wait for the callback to run the\nspecified <a>unittest/unittest.expectAsync0.count</a> times before it continues with the following test.  Using\n<a>unittest/unittest.expectAsync0</a> will also ensure that errors that occur within <a>unittest/unittest.expectAsync0.callback</a> are\ntracked and reported. <a>unittest/unittest.expectAsync0.callback</a> should take 0 positional arguments (named\narguments are not supported). <a>unittest/unittest.expectAsync0.id</a> can be used to provide more\ndescriptive error messages if the callback is called more often than\nexpected. <a>unittest/unittest.expectAsync0.max</a> can be used to specify an upper bound on the number of\ncalls; if this is exceeded the test will fail (or be marked as in error if\nit was already complete). A value of 0 for <a>unittest/unittest.expectAsync0.max</a> (the default) will set\nthe upper bound to the same value as <a>unittest/unittest.expectAsync0.count</a>; i.e. the callback should be\ncalled exactly <a>unittest/unittest.expectAsync0.count</a> times. A value of -1 for <a>unittest/unittest.expectAsync0.max</a> will mean no upper\nbound.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"count":{"name":"count","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"max":{"name":"max","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"expectAsync1":{"name":"expectAsync1","qualifiedName":"unittest/unittest.expectAsync1","comment":"<p>Like <a>unittest/unittest.expectAsync0</a> but <a>unittest/unittest.expectAsync1.callback</a> should take 1 positional argument.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"count":{"name":"count","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"max":{"name":"max","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"expectAsync2":{"name":"expectAsync2","qualifiedName":"unittest/unittest.expectAsync2","comment":"<p>Like <a>unittest/unittest.expectAsync0</a> but <a>unittest/unittest.expectAsync2.callback</a> should take 2 positional arguments.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"count":{"name":"count","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"1","annotations":[]},"max":{"name":"max","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"expectAsyncUntil0":{"name":"expectAsyncUntil0","qualifiedName":"unittest/unittest.expectAsyncUntil0","comment":"<p>Indicate that <a>unittest/unittest.expectAsyncUntil0.callback</a> is expected to be called until <a>unittest/unittest.expectAsyncUntil0.isDone</a> returns\ntrue. The unittest framework check <a>unittest/unittest.expectAsyncUntil0.isDone</a> after each callback and only\nwhen it returns true will it continue with the following test. Using\n<a>unittest/unittest.expectAsyncUntil0</a> will also ensure that errors that occur within\n<a>unittest/unittest.expectAsyncUntil0.callback</a> are tracked and reported. <a>unittest/unittest.expectAsyncUntil0.callback</a> should take 0 positional\narguments (named arguments are not supported). <a>unittest/unittest.expectAsyncUntil0.id</a> can be used to\nidentify the callback in error messages (for example if it is called\nafter the test case is complete).</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"isDone":{"name":"isDone","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"expectAsyncUntil1":{"name":"expectAsyncUntil1","qualifiedName":"unittest/unittest.expectAsyncUntil1","comment":"<p>Like <a>unittest/unittest.expectAsyncUntil0</a> but <a>unittest/unittest.expectAsyncUntil1.callback</a> should take 1 positional argument.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"isDone":{"name":"isDone","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"expectAsyncUntil2":{"name":"expectAsyncUntil2","qualifiedName":"unittest/unittest.expectAsyncUntil2","comment":"<p>Like <a>unittest/unittest.expectAsyncUntil0</a> but <a>unittest/unittest.expectAsyncUntil2.callback</a> should take 2 positional arguments.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"isDone":{"name":"isDone","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"fail":{"name":"fail","qualifiedName":"unittest/unittest.fail","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"failureHandler":{"name":"failureHandler","optional":true,"named":true,"default":false,"type":[{"outer":"unittest/unittest.FailureHandler","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"filterTests":{"name":"filterTests","qualifiedName":"unittest/unittest.filterTests","comment":"<p>Filter the tests. <a>unittest/unittest.filterTests.testFilter</a> can be a <a>dart-core.RegExp</a>, a <a>dart-core.String</a> or a\npredicate function. This is different to enabling/disabling tests\nin that it removes the tests completely.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"testFilter":{"name":"testFilter","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"getOrCreateExpectFailureHandler":{"name":"getOrCreateExpectFailureHandler","qualifiedName":"unittest/unittest.getOrCreateExpectFailureHandler","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.FailureHandler","inner":[]}],"parameters":{},"annotations":[]},"greaterThan":{"name":"greaterThan","qualifiedName":"unittest/unittest.greaterThan","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan the given <a>unittest/unittest.greaterThan.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"greaterThanOrEqualTo":{"name":"greaterThanOrEqualTo","qualifiedName":"unittest/unittest.greaterThanOrEqualTo","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to the given <a>unittest/unittest.greaterThanOrEqualTo.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"group":{"name":"group","qualifiedName":"unittest/unittest.group","comment":"<p>Creates a new named group of tests. Calls to group() or test() within the\nbody of the function passed to this will inherit this group's description.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}}},"annotations":[]},"guardAsync":{"name":"guardAsync","qualifiedName":"unittest/unittest.guardAsync","comment":"<p>Run <a>unittest/unittest.guardAsync.tryBody</a> guarded in a try-catch block. If an exception is thrown, it is\npassed to the corresponding test.</p>\n<p>The value returned by <a>unittest/unittest.guardAsync.tryBody</a> (if any) is returned by <a>unittest/unittest.guardAsync</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"tryBody":{"name":"tryBody","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"handleExternalError":{"name":"handleExternalError","qualifiedName":"unittest/unittest.handleExternalError","comment":"<p>Handle errors that happen outside the tests.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"e":{"name":"e","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"stack":{"name":"stack","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"hasLength":{"name":"hasLength","qualifiedName":"unittest/unittest.hasLength","comment":"<p>Returns a matcher that matches if an object has a length property\nthat matches <a>unittest/unittest.hasLength.matcher</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inClosedOpenRange":{"name":"inClosedOpenRange","qualifiedName":"unittest/unittest.inClosedOpenRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to a <a>unittest/unittest.inClosedOpenRange.low</a> and less than <a>unittest/unittest.inClosedOpenRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inExclusiveRange":{"name":"inExclusiveRange","qualifiedName":"unittest/unittest.inExclusiveRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan <a>unittest/unittest.inExclusiveRange.low</a> and less than <a>unittest/unittest.inExclusiveRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inInclusiveRange":{"name":"inInclusiveRange","qualifiedName":"unittest/unittest.inInclusiveRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan or equal to <a>unittest/unittest.inInclusiveRange.low</a> and less than or equal to <a>unittest/unittest.inInclusiveRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"inOpenClosedRange":{"name":"inOpenClosedRange","qualifiedName":"unittest/unittest.inOpenClosedRange","comment":"<p>Returns a matcher which matches if the match argument is greater\nthan <a>unittest/unittest.inOpenClosedRange.low</a> and less than or equal to <a>unittest/unittest.inOpenClosedRange.high</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"low":{"name":"low","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"high":{"name":"high","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isIn":{"name":"isIn","qualifiedName":"unittest/unittest.isIn","comment":"<p>Returns a matcher that matches if the match argument is in\nthe expected value. This is the converse of <a>unittest/unittest.contains</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isNot":{"name":"isNot","qualifiedName":"unittest/unittest.isNot","comment":"<p>This returns a matcher that inverts <a>unittest/unittest.isNot.matcher</a> to its logical negation.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"lessThan":{"name":"lessThan","qualifiedName":"unittest/unittest.lessThan","comment":"<p>Returns a matcher which matches if the match argument is less\nthan the given <a>unittest/unittest.lessThan.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"lessThanOrEqualTo":{"name":"lessThanOrEqualTo","qualifiedName":"unittest/unittest.lessThanOrEqualTo","comment":"<p>Returns a matcher which matches if the match argument is less\nthan or equal to the given <a>unittest/unittest.lessThanOrEqualTo.value</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"logMessage":{"name":"logMessage","qualifiedName":"unittest/unittest.logMessage","comment":"<p>Can be called by tests to log status. Tests should use this\ninstead of <a>dart-core.print</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"message":{"name":"message","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"matches":{"name":"matches","qualifiedName":"unittest/unittest.matches","comment":"<p>Returns a matcher that matches if the match argument is a string and\nmatches the regular expression given by <a>unittest/unittest.matches.re</a>. <a>unittest/unittest.matches.re</a> can be a RegExp\ninstance or a string; in the latter case it will be used to create\na RegExp instance.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"re":{"name":"re","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"orderedEquals":{"name":"orderedEquals","qualifiedName":"unittest/unittest.orderedEquals","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s that have the same\nlength and the same elements as <a>unittest/unittest.orderedEquals.expected</a>, and in the same order.\nThis is equivalent to equals but does not recurse.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"pairwiseCompare":{"name":"pairwiseCompare","qualifiedName":"unittest/unittest.pairwiseCompare","comment":"<p>A pairwise matcher for iterable. You can pass an arbitrary <a>unittest/unittest.pairwiseCompare.comparator</a>\nfunction that takes an expected and actual argument which will be applied\nto each pair in order. <a>unittest/unittest.pairwiseCompare.description</a>  should be a meaningful name for\nthe comparator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]},"comparator":{"name":"comparator","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"predicate":{"name":"predicate","qualifiedName":"unittest/unittest.predicate","comment":"<p>Returns a matcher that uses an arbitrary function that returns\ntrue or false for the actual value. For example:</p>\n<pre><code>expect(v, predicate((x) =&gt; ((x % 2) == 0), \"is even\"))\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"description":{"name":"description","optional":true,"named":false,"default":true,"type":[{"outer":"dynamic","inner":[]}],"value":"\"satisfies function\"","annotations":[]}},"annotations":[]},"protectAsync0":{"name":"protectAsync0","qualifiedName":"unittest/unittest.protectAsync0","comment":"<p>Wraps the <a>unittest/unittest.protectAsync0.callback</a> in a new function and returns that function. The new\nfunction will be able to handle exceptions by directing them to the correct\ntest. This is thus similar to expectAsync0. Use it to wrap any callbacks that\nmight optionally be called but may never be called during the test.\n<a>unittest/unittest.protectAsync0.callback</a> should take 0 positional arguments (named arguments are not\nsupported). <a>unittest/unittest.protectAsync0.id</a> can be used to identify the callback in error\nmessages (for example if it is called after the test case is complete).</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"protectAsync1":{"name":"protectAsync1","qualifiedName":"unittest/unittest.protectAsync1","comment":"<p>Like <a>unittest/unittest.protectAsync0</a> but <a>unittest/unittest.protectAsync1.callback</a> should take 1 positional argument.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"protectAsync2":{"name":"protectAsync2","qualifiedName":"unittest/unittest.protectAsync2","comment":"<p>Like <a>unittest/unittest.protectAsync0</a> but <a>unittest/unittest.protectAsync2.callback</a> should take 2 positional arguments.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Function","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]},"id":{"name":"id","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"registerException":{"name":"registerException","qualifiedName":"unittest/unittest.registerException","comment":"<p>Registers that an exception was caught for the current test.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"e":{"name":"e","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"trace":{"name":"trace","optional":true,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"rerunTests":{"name":"rerunTests","qualifiedName":"unittest/unittest.rerunTests","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"runTests":{"name":"runTests","qualifiedName":"unittest/unittest.runTests","comment":"<p>Runs all queued tests, one at a time.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{},"annotations":[]},"same":{"name":"same","qualifiedName":"unittest/unittest.same","comment":"<p>Returns a matches that matches if the value is the same instance\nas <a href=\"`===`\">object</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"setSoloTest":{"name":"setSoloTest","qualifiedName":"unittest/unittest.setSoloTest","comment":"<p>Select a solo test by ID.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"id":{"name":"id","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"setUp":{"name":"setUp","qualifiedName":"unittest/unittest.setUp","comment":"<p>Register a <a>unittest/unittest.setUp</a> function for a test <a>unittest/unittest.group</a>. This function will\nbe called before each test in the group is run.\n<a>unittest/unittest.setUp</a> and <a>unittest/unittest.tearDown</a> should be called within the <a>unittest/unittest.group</a> before any\ncalls to <a>unittest/unittest.test</a>. The <a>unittest/unittest.setUp.setupTest</a> function can be asynchronous; in this\ncase it must return a <a>unittest/dart-async.Future</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"setupTest":{"name":"setupTest","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"skip_group":{"name":"skip_group","qualifiedName":"unittest/unittest.skip_group","comment":"<p>Like <a>unittest/unittest.skip_test</a>, but for groups.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}}},"annotations":[]},"skip_test":{"name":"skip_test","qualifiedName":"unittest/unittest.skip_test","comment":"<p>Convenience function for skipping a test.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"spec":{"name":"spec","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"unittest/unittest.TestFunction","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"solo_group":{"name":"solo_group","qualifiedName":"unittest/unittest.solo_group","comment":"<p>Like <a>unittest/unittest.solo_test</a>, but for groups.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"description":{"name":"description","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"void","inner":[]}],"parameters":{}}}},"annotations":[]},"solo_test":{"name":"solo_test","qualifiedName":"unittest/unittest.solo_test","comment":"<p>Creates a new test case with the given description and body. The\ndescription will include the descriptions of any surrounding group()\ncalls.</p>\n<p>If we use <a>unittest/unittest.solo_test</a> (or <a>unittest/unittest.solo_group</a>) instead of test, then all non-solo\ntests will be disabled. Note that if we use <a>unittest/unittest.solo_group</a>, all tests in\nthe group will be enabled, regardless of whether they use <a>unittest/unittest.test</a> or\n<a>unittest/unittest.solo_test</a>, or whether they are in a nested <a>unittest/unittest.group</a> vs <a>unittest/unittest.solo_group</a>. Put\nanother way, if there are any calls to <a>unittest/unittest.solo_test</a> or <a>unittest/unittest.solo_group</a> in a test\nfile, all tests that are not inside a <a>unittest/unittest.solo_group</a> will be disabled unless\nthey are <a>unittest/unittest.solo_test</a>s.</p>\n<p><a>unittest/unittest.skip_test</a> and <a>unittest/unittest.skip_group</a> take precedence over soloing, by virtue of the\nfact that they are effectively no-ops.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"spec":{"name":"spec","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"unittest/unittest.TestFunction","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"startsWith":{"name":"startsWith","qualifiedName":"unittest/unittest.startsWith","comment":"<p>Returns a matcher that matches if the match argument is a string and\nstarts with <a>unittest/unittest.startsWith.prefixString</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"prefixString":{"name":"prefixString","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"stringContainsInOrder":{"name":"stringContainsInOrder","qualifiedName":"unittest/unittest.stringContainsInOrder","comment":"<p>Returns a matcher that matches if the match argument is a string and\ncontains a given list of <a>unittest/unittest.stringContainsInOrder.substrings</a> in relative order.</p>\n<p>For example, <code>stringContainsInOrder([\"a\", \"e\", \"i\", \"o\", \"u\"])</code> will match\n\"abcdefghijklmnopqrstuvwxyz\".</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"substrings":{"name":"substrings","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"tearDown":{"name":"tearDown","qualifiedName":"unittest/unittest.tearDown","comment":"<p>Register a <a>unittest/unittest.tearDown</a> function for a test <a>unittest/unittest.group</a>. This function will\nbe called after each test in the group is run. Note that if groups\nare nested only the most locally scoped <a>unittest/unittest.tearDown.teardownTest</a> function will be run.\n<a>unittest/unittest.setUp</a> and <a>unittest/unittest.tearDown</a> should be called within the <a>unittest/unittest.group</a> before any\ncalls to <a>unittest/unittest.test</a>. The <a>unittest/unittest.tearDown.teardownTest</a> function can be asynchronous; in this\ncase it must return a <a>unittest/dart-async.Future</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"teardownTest":{"name":"teardownTest","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"test":{"name":"test","qualifiedName":"unittest/unittest.test","comment":"<p>Creates a new test case with the given description and body. The\ndescription will include the descriptions of any surrounding group()\ncalls.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"spec":{"name":"spec","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"body":{"name":"body","optional":false,"named":false,"default":false,"type":[{"outer":"unittest/unittest.TestFunction","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"throwsA":{"name":"throwsA","qualifiedName":"unittest/unittest.throwsA","comment":"<p>This can be used to match two kinds of objects:</p><ul><li>\n<p>A <a>dart-core.Function</a> that throws an exception when called. The function cannot\ntake any arguments. If you want to test that a function expecting\narguments throws, wrap it in another zero-argument function that calls\nthe one you want to test.</p></li><li>\n<p>A <a>unittest/dart-async.Future</a> that completes with an exception. Note that this creates an\nasynchronous expectation. The call to <code>expect()</code> that includes this will\nreturn immediately and execution will continue. Later, when the future\ncompletes, the actual expectation will run.</p></li></ul>\n<p>In both cases, when an exception is thrown, this will test that the exception\nobject matches <a>unittest/unittest.throwsA.matcher</a>. If <a>unittest/unittest.throwsA.matcher</a> is not an instance of <a>unittest/unittest.Matcher</a>, it\nwill implicitly be treated as <code>equals(matcher)</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"unorderedEquals":{"name":"unorderedEquals","qualifiedName":"unittest/unittest.unorderedEquals","comment":"<p>Returns a matcher which matches <a>dart-core.Iterable</a>s that have the same\nlength and the same elements as <a>unittest/unittest.unorderedEquals.expected</a>, but not necessarily in\nthe same order. Note that this is O(n^2) so should only be used on\nsmall objects.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"expected":{"name":"expected","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"wrapMatcher":{"name":"wrapMatcher","qualifiedName":"unittest/unittest.wrapMatcher","comment":"<p>Takes an argument and returns an equivalent matcher.\nIf the argument is already a matcher this does nothing,\nelse if the argument is a function, it generates a predicate\nfunction matcher, else it generates an equals matcher.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"unittest/unittest.Matcher","inner":[]}],"parameters":{"x":{"name":"x","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"Configuration","qualifiedName":"unittest/unittest.Configuration","preview":"<p>Describes the interface used by the unit test system for communicating the\nresults of a test run.</p>"},{"name":"CustomMatcher","qualifiedName":"unittest/unittest.CustomMatcher","preview":"<p>A useful utility class for implementing other matchers through inheritance.\nDerived classes should call the base constructor with a feature name and\ndescription, and an instance matcher, and should implement the\n<a>unittest/unittest.CustomMatcher.featureValueOf</a> abstract method.</p>"},{"name":"DefaultFailureHandler","qualifiedName":"unittest/unittest.DefaultFailureHandler"},{"name":"Description","qualifiedName":"unittest/unittest.Description","preview":"<p>Matchers build up their error messages by appending to\nDescription objects. This interface is implemented by\nStringDescription. This interface is unlikely to need\nother implementations, but could be useful to replace in\nsome cases - e.g. language conversion.</p>"},{"name":"FailureHandler","qualifiedName":"unittest/unittest.FailureHandler","preview":"<p>Failed matches are reported using a default IFailureHandler.\nThe default implementation simply throws <a>unittest/unittest.TestFailure</a>s;\nthis can be replaced by some other implementation of\nIFailureHandler by calling configureExpectHandler.</p>"},{"name":"Matcher","qualifiedName":"unittest/unittest.Matcher","preview":"<p><a>unittest/unittest.expect</a> Matchers must implement/extend the Matcher class.\nThe base Matcher class has a generic implementation of <a>unittest/unittest.Matcher.describeMismatch</a>\nso this does not need to be provided unless a more clear description is\nrequired. The other two methods (<a>unittest/unittest.Matcher.matches</a> and <a>unittest/unittest.Matcher.describe</a>)\nmust always be provided as they are highly matcher-specific.</p>"},{"name":"SimpleConfiguration","qualifiedName":"unittest/unittest.SimpleConfiguration","preview":"<p>Hooks to configure the unittest library for different platforms. This class\nimplements the API in a platform-independent way. Tests that want to take\nadvantage of the platform can create a subclass and override methods from\nthis class.</p>"},{"name":"StringDescription","qualifiedName":"unittest/unittest.StringDescription","preview":"<p>The default implementation of IDescription. This should rarely need\nsubstitution, although conceivably it is a place where other languages\ncould be supported.</p>"},{"name":"TestCase","qualifiedName":"unittest/unittest.TestCase","preview":"<p>Represents the state for an individual unit test.</p>"},{"name":"Throws","qualifiedName":"unittest/unittest.Throws"},{"name":"TypeMatcher","qualifiedName":"unittest/unittest.TypeMatcher"},{"name":"isInstanceOf","qualifiedName":"unittest/unittest.isInstanceOf","preview":"<p>Returns a matcher that matches if an object is an instance\nof type (or a subtype).</p>"}],"typedef":{"ErrorFormatter":{"name":"ErrorFormatter","qualifiedName":"unittest/unittest.ErrorFormatter","comment":"<p>The ErrorFormatter type is used for functions that\ncan be used to build up error reports upon <a>unittest/matcher.expect</a> failures.\nThere is one built-in implementation (defaultErrorFormatter)\nwhich is used by the default failure handler. If the failure handler\nis replaced it may be desirable to replace the stringDescription\nerror formatter with another.</p>","return":"dart-core.String","parameters":{"actual":{"name":"actual","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"matcher":{"name":"matcher","optional":false,"named":false,"default":false,"type":[{"outer":"unittest/unittest.Matcher","inner":[]}],"value":null,"annotations":[]},"reason":{"name":"reason","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"matchState":{"name":"matchState","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[]}],"value":null,"annotations":[]},"verbose":{"name":"verbose","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.bool","inner":[]}],"value":null,"annotations":[]}},"annotations":[],"generics":{},"preview":"<p>The ErrorFormatter type is used for functions that\ncan be used to build up error reports upon <a>unittest/matcher.expect</a> failures.\nThere is one built-in implementation (defaultErrorFormatter)\nwhich is used by the default failure handler. If the failure handler\nis replaced it may be desirable to replace the stringDescription\nerror formatter with another.</p>"},"TestFunction":{"name":"TestFunction","qualifiedName":"unittest/unittest.TestFunction","comment":"<p>Signature for a test function.</p>","return":"dynamic","parameters":{},"annotations":[],"generics":{},"preview":"<p>Signature for a test function.</p>"}},"error":[{"name":"TestFailure","qualifiedName":"unittest/unittest.TestFailure","preview":"<p>The objects thrown by the default failure handler.</p>"}]},"packageName":"unittest","packageIntro":""}