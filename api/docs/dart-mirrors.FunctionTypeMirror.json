{"name":"FunctionTypeMirror","qualifiedName":"dart-mirrors.FunctionTypeMirror","comment":"<p>A <a>dart-mirrors.FunctionTypeMirror</a> represents the type of a function in the\nDart language.</p>","isAbstract":true,"superclass":"dart-core.Object","implements":["dart-mirrors.ClassMirror"],"subclass":[],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{"callMethod":{"name":"callMethod","qualifiedName":"dart-mirrors.FunctionTypeMirror.callMethod","comment":"<p>A mirror on the <code>call</code> method for the reflectee.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-mirrors.MethodMirror","inner":[]}],"parameters":{},"annotations":[]},"parameters":{"name":"parameters","qualifiedName":"dart-mirrors.FunctionTypeMirror.parameters","comment":"<p>Returns a list of the parameter types of the reflectee.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-mirrors.ParameterMirror","inner":[]}]}],"parameters":{},"annotations":[]},"returnType":{"name":"returnType","qualifiedName":"dart-mirrors.FunctionTypeMirror.returnType","comment":"<p>Returns the return type of the reflectee.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-mirrors.TypeMirror","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{},"methods":{}},"inheritedMethods":{"setters":{},"getters":{"declarations":{"name":"declarations","qualifiedName":"dart-mirrors.FunctionTypeMirror.declarations","comment":"<p>Returns an immutable map of the declarations actually given in the class\ndeclaration.</p>\n<p>This map includes all regular methods, getters, setters, fields,\nconstructors and type variables actually declared in the class. Both\nstatic and instance members are included, but no inherited members are\nincluded. The map is keyed by the simple names of the declarations.</p>\n<p>This does not include inherited members.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ClassMirror.declarations","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.Symbol","inner":[]},{"outer":"dart-mirrors.DeclarationMirror","inner":[]}]}],"parameters":{},"annotations":[]},"hasReflectedType":{"name":"hasReflectedType","qualifiedName":"dart-mirrors.FunctionTypeMirror.hasReflectedType","comment":"<p>Returns true if this mirror reflects dynamic, a non-generic class or\ntypedef, or an instantiated generic class or typedef in the current\nisolate. Otherwise, returns false.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.TypeMirror.hasReflectedType","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"dart-mirrors.FunctionTypeMirror.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-mirrors.FunctionTypeMirror.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"instanceMembers":{"name":"instanceMembers","qualifiedName":"dart-mirrors.FunctionTypeMirror.instanceMembers","comment":"<p>Returns a map of the methods, getters and setters of an instance of the\nclass.</p>\n<p>The intent is to capture those members that constitute the API of an\ninstance. Hence fields are not included, but the getters and setters\nimplicitly introduced by fields are included. The map includes methods,\ngetters and setters that are inherited as well as those introduced by the\nclass itself.</p>\n<p>The map is keyed by the simple names of the members.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ClassMirror.instanceMembers","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.Symbol","inner":[]},{"outer":"dart-mirrors.MethodMirror","inner":[]}]}],"parameters":{},"annotations":[]},"isAbstract":{"name":"isAbstract","qualifiedName":"dart-mirrors.FunctionTypeMirror.isAbstract","comment":"<p>Is the reflectee abstract?</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ClassMirror.isAbstract","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isOriginalDeclaration":{"name":"isOriginalDeclaration","qualifiedName":"dart-mirrors.FunctionTypeMirror.isOriginalDeclaration","comment":"<p>Is this the original declaration of this type?</p>\n<p>For most classes, they are their own original declaration.  For\ngeneric classes, however, there is a distinction between the\noriginal class declaration, which has unbound type variables, and\nthe instantiations of generic classes, which have bound type\nvariables.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.TypeMirror.isOriginalDeclaration","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isPrivate":{"name":"isPrivate","qualifiedName":"dart-mirrors.FunctionTypeMirror.isPrivate","comment":"<p>Returns <code>true</code> if this declaration is considered private\naccording to the Dart language specification.\nAlways returns <code>false</code> if this declaration\nis a library.\nOtherwise return <code>false</code>.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.DeclarationMirror.isPrivate","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isTopLevel":{"name":"isTopLevel","qualifiedName":"dart-mirrors.FunctionTypeMirror.isTopLevel","comment":"<p>Is this declaration top-level?</p>\n<p>This is defined to be equivalent to:\n   <code>mirror.owner != null &amp;&amp; mirror.owner is LibraryMirror</code></p>","commentFrom":"","inheritedFrom":"dart-mirrors.DeclarationMirror.isTopLevel","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"location":{"name":"location","qualifiedName":"dart-mirrors.FunctionTypeMirror.location","comment":"<p>The source location of this Dart language entity.</p>\n<p>This operation is optional and may return <code>null</code>.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.DeclarationMirror.location","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-mirrors.SourceLocation","inner":[]}],"parameters":{},"annotations":[]},"metadata":{"name":"metadata","qualifiedName":"dart-mirrors.FunctionTypeMirror.metadata","comment":"<p>A list of the metadata associated with this declaration.</p>\n<p>Let <em>D</em> be the declaration this mirror reflects.\nIf <em>D</em> is decorated with annotations <em>A1, ..., An</em>\nwhere <em>n > 0</em>, then for each annotation <em>Ai</em> associated\nwith <em>D, 1 &lt;= i &lt;= n</em>, let <em>ci</em> be the constant object\nspecified by <em>Ai</em>. Then this method returns a list whose\nmembers are instance mirrors on <em>c1, ..., cn</em>.\nIf no annotations are associated with <em>D</em>, then\nan empty list is returned.</p>\n<p>If evaluating any of <em>c1, ..., cn</em> would cause a\ncompilation error\nthe effect is the same as if a non-reflective compilation error\nhad been encountered.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.DeclarationMirror.metadata","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-mirrors.InstanceMirror","inner":[]}]}],"parameters":{},"annotations":[]},"mixin":{"name":"mixin","qualifiedName":"dart-mirrors.FunctionTypeMirror.mixin","comment":"<p>The mixin of this class.\nIf this class is the result of a mixin application of the\nform S with M, returns a class mirror on M.\nOtherwise returns a class mirror on reflectee.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ClassMirror.mixin","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-mirrors.ClassMirror","inner":[]}],"parameters":{},"annotations":[]},"originalDeclaration":{"name":"originalDeclaration","qualifiedName":"dart-mirrors.FunctionTypeMirror.originalDeclaration","comment":"<p>A mirror on the original declaration of this type.</p>\n<p>For most classes, they are their own original declaration.  For\ngeneric classes, however, there is a distinction between the\noriginal class declaration, which has unbound type variables, and\nthe instantiations of generic classes, which have bound type\nvariables.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.TypeMirror.originalDeclaration","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-mirrors.TypeMirror","inner":[]}],"parameters":{},"annotations":[]},"owner":{"name":"owner","qualifiedName":"dart-mirrors.FunctionTypeMirror.owner","comment":"<p>A mirror on the owner of this Dart language entity. This is the declaration\nimmediately surrounding the reflectee.</p>\n<p>For a library, the owner is <code>null</code>.\nFor a class declaration, typedef or top level function\nor variable, the owner is the enclosing library.\nFor a mixin application <em>S with M</em>, the owner is the owner\nof <em>M</em>.\nFor a constructor, the owner is the immediately enclosing class.\nFor a method, instance variable or\na static variable, the owner is the immediately enclosing class,\nunless the class is a mixin application <em>S with M</em>, in which case\nthe owner is <em>M</em>. Note that <em>M</em> may be an invocation of a generic.\nFor a parameter, local variable or local function the owner is the\nimmediately enclosing function.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.DeclarationMirror.owner","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-mirrors.DeclarationMirror","inner":[]}],"parameters":{},"annotations":[]},"qualifiedName":{"name":"qualifiedName","qualifiedName":"dart-mirrors.FunctionTypeMirror.qualifiedName","comment":"<p>The fully-qualified name for this Dart language entity.</p>\n<p>This name is qualified by the name of the owner. For instance,\nthe qualified name of a method 'method' in class 'Class' in\nlibrary 'library' is 'library.Class.method'.</p>\n<p>Returns a <a>dart-core.Symbol</a> constructed from a string representing the\nfully qualified name of the reflectee.\nLet <em>o</em> be the <a>dart-mirrors.FunctionTypeMirror.owner</a> of this mirror, let <em>r</em> be the reflectee of\nthis mirror, let <em>p</em> be the fully qualified\nname of the reflectee of <em>o</em>, and let <em>s</em> be the simple name of <em>r</em>\ncomputed by <a>dart-mirrors.FunctionTypeMirror.simpleName</a>.\nThe fully qualified name of <em>r</em> is the\nconcatenation of <em>p</em>, '.', and <em>s</em>.</p>\n<p>Because an isolate can contain more than one library with the same name (at\ndifferent URIs), a fully-qualified name does not uniquely identify any\nlanguage entity.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.DeclarationMirror.qualifiedName","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Symbol","inner":[]}],"parameters":{},"annotations":[]},"reflectedType":{"name":"reflectedType","qualifiedName":"dart-mirrors.FunctionTypeMirror.reflectedType","comment":"<p>If <code>hasReflectedType</code> returns true, returns the corresponding <a>dart-core.Type</a>.\nOtherwise, an <a>dart-core.UnsupportedError</a> is thrown.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.TypeMirror.reflectedType","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-mirrors.FunctionTypeMirror.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]},"simpleName":{"name":"simpleName","qualifiedName":"dart-mirrors.FunctionTypeMirror.simpleName","comment":"<p>The simple name for this Dart language entity.</p>\n<p>The simple name is in most cases the the identifier name of the\nentity, such as 'method' for a method <code>void method() {...}</code> or\n'mylibrary' for a <code>library 'mylibrary';</code> declaration.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.DeclarationMirror.simpleName","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Symbol","inner":[]}],"parameters":{},"annotations":[]},"staticMembers":{"name":"staticMembers","qualifiedName":"dart-mirrors.FunctionTypeMirror.staticMembers","comment":"<p>Returns a map of the static methods, getters and setters of the class.</p>\n<p>The intent is to capture those members that constitute the API of a class.\nHence fields are not included, but the getters and setters implicitly\nintroduced by fields are included.</p>\n<p>The map is keyed by the simple names of the members.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ClassMirror.staticMembers","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.Symbol","inner":[]},{"outer":"dart-mirrors.MethodMirror","inner":[]}]}],"parameters":{},"annotations":[]},"superclass":{"name":"superclass","qualifiedName":"dart-mirrors.FunctionTypeMirror.superclass","comment":"<p>A mirror on the superclass on the reflectee.</p>\n<p>If this type is <code>Object</code>, the superclass will be null.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ClassMirror.superclass","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-mirrors.ClassMirror","inner":[]}],"parameters":{},"annotations":[]},"superinterfaces":{"name":"superinterfaces","qualifiedName":"dart-mirrors.FunctionTypeMirror.superinterfaces","comment":"<p>A list of mirrors on the superinterfaces of the reflectee.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ClassMirror.superinterfaces","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-mirrors.ClassMirror","inner":[]}]}],"parameters":{},"annotations":[]},"typeArguments":{"name":"typeArguments","qualifiedName":"dart-mirrors.FunctionTypeMirror.typeArguments","comment":"<p>An immutable list with mirrors for all type arguments for\nthis type.</p>\n<p>If the reflectee is an invocation of a generic class,\nthe type arguments are the bindings of its type parameters.\nIf the reflectee is the original declaration of a generic,\nit has no type arguments and this method returns an empty list.\nIf the reflectee is not generic, then\nit has no type arguments and this method returns an empty list.</p>\n<p>This list preserves the order of declaration of the type variables.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.TypeMirror.typeArguments","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-mirrors.TypeMirror","inner":[]}]}],"parameters":{},"annotations":[]},"typeVariables":{"name":"typeVariables","qualifiedName":"dart-mirrors.FunctionTypeMirror.typeVariables","comment":"<p>An immutable list with mirrors for all type variables for this type.</p>\n<p>If this type is a generic declaration or an invocation of a generic\ndeclaration, the returned list contains mirrors on the type variables\ndeclared in the original declaration.\nOtherwise, the returned list is empty.</p>\n<p>This list preserves the order of declaration of the type variables.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.TypeMirror.typeVariables","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-mirrors.TypeVariableMirror","inner":[]}]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-mirrors.FunctionTypeMirror.==","comment":"<p>Returns <code>true</code> if this mirror is equal to <a>dart-mirrors.FunctionTypeMirror.==.other</a>.\nOtherwise returns <code>false</code>.</p>\n<p>The equality holds if and only if\n(1) <a>dart-mirrors.FunctionTypeMirror.==.other</a> is a mirror of the same kind\nand\n(2) This mirror and <a>dart-mirrors.FunctionTypeMirror.==.other</a> reflect the same class.</p>\n<p>Note that if the reflected class is an invocation of\na generic class,(2) implies that the reflected class\nand <a>dart-mirrors.FunctionTypeMirror.==.other</a> have equal type arguments.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ClassMirror.==","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"getField":{"name":"getField","qualifiedName":"dart-mirrors.FunctionTypeMirror.getField","comment":"<p>Invokes a getter and returns a mirror on the result. The getter\ncan be the implicit getter for a field or a user-defined getter\nmethod.</p>\n<p>Let <em>o</em> be the object reflected by this mirror, let\n<em>f</em> be the simple name of the getter denoted by <a>dart-mirrors.FunctionTypeMirror.getField.fieldName</a>,\nThen this method will perform the getter invocation\n <em>o.f</em>\nin a scope that has access to the private members\nof <em>o</em> (if <em>o</em> is a class or library) or the private members of the\nclass of <em>o</em> (otherwise).</p>\n<p>If this mirror is an <a>dart-mirrors.InstanceMirror</a>, and <a>dart-mirrors.FunctionTypeMirror.getField.fieldName</a> denotes an instance\nmethod on its reflectee, the result of the invocation is an instance\nmirror on a closure corresponding to that method.</p>\n<p>If this mirror is a <a>dart-mirrors.LibraryMirror</a>, and <a>dart-mirrors.FunctionTypeMirror.getField.fieldName</a> denotes a top-level\nmethod in the corresponding library, the result of the invocation is an\ninstance mirror on a closure corresponding to that method.</p>\n<p>If this mirror is a <a>dart-mirrors.ClassMirror</a>, and <a>dart-mirrors.FunctionTypeMirror.getField.fieldName</a> denotes a static method\nin the corresponding class, the result of the invocation is an instance\nmirror on a closure corresponding to that method.</p>\n<p>If the invocation returns a result <em>r</em>, this method returns\nthe result of calling <a href=\"*r*\">reflect</a>.\nIf the invocation causes a compilation error\nthe effect is the same as if a non-reflective compilation error\nhad been encountered.\nIf the invocation throws an exception <em>e</em> (that it does not catch)\nthis method throws <em>e</em>.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ObjectMirror.getField","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-mirrors.InstanceMirror","inner":[]}],"parameters":{"fieldName":{"name":"fieldName","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"invoke":{"name":"invoke","qualifiedName":"dart-mirrors.FunctionTypeMirror.invoke","comment":"<p>Invokes the named function and returns a mirror on the result.</p>\n<p>Let <em>o</em> be the object reflected by this mirror, let\n<em>f</em> be the simple name of the member denoted by <a>dart-mirrors.FunctionTypeMirror.invoke.memberName</a>,\nlet <em>a1, ..., an</em> be the elements of <a>dart-mirrors.FunctionTypeMirror.invoke.positionalArguments</a>\nlet <em>k1, ..., km</em> be the identifiers denoted by the elements of\nnamedArguments.keys\nand let <em>v1, ..., vm</em> be the elements of namedArguments.values.\nThen this method will perform the method invocation\n <em>o.f(a1, ..., an, k1: v1, ..., km: vm)</em>\nin a scope that has access to the private members\nof <em>o</em> (if <em>o</em> is a class or library) or the private members of the\nclass of <em>o</em> (otherwise).\nIf the invocation returns a result <em>r</em>, this method returns\nthe result of calling <a href=\"*r*\">reflect</a>.\nIf the invocation causes a compilation error\nthe effect is the same as if a non-reflective compilation error\nhad been encountered.\nIf the invocation throws an exception <em>e</em> (that it does not catch)\nthis method throws <em>e</em>.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ObjectMirror.invoke","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-mirrors.InstanceMirror","inner":[]}],"parameters":{"memberName":{"name":"memberName","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]},"positionalArguments":{"name":"positionalArguments","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"namedArguments":{"name":"namedArguments","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.Symbol","inner":[]},{"outer":"dynamic","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"isAssignableTo":{"name":"isAssignableTo","qualifiedName":"dart-mirrors.FunctionTypeMirror.isAssignableTo","comment":"<p>Checks the assignability relationship, denoted by <code>&lt;=&gt;</code> in the language\nspecification. This is the type relationship tested on assignment in\nchecked mode.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.TypeMirror.isAssignableTo","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-mirrors.TypeMirror","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isSubclassOf":{"name":"isSubclassOf","qualifiedName":"dart-mirrors.FunctionTypeMirror.isSubclassOf","comment":"<p>Returns whether the class denoted by the receiver is a subclass of the\nclass denoted by the argument.</p>\n<p>Note that the subclass relationship is reflexive.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ClassMirror.isSubclassOf","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-mirrors.ClassMirror","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isSubtypeOf":{"name":"isSubtypeOf","qualifiedName":"dart-mirrors.FunctionTypeMirror.isSubtypeOf","comment":"<p>Checks the subtype relationship, denoted by <code>&lt;:</code> in the language\nspecification. This is the type relationship used in <code>is</code> test checks.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.TypeMirror.isSubtypeOf","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-mirrors.TypeMirror","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"newInstance":{"name":"newInstance","qualifiedName":"dart-mirrors.FunctionTypeMirror.newInstance","comment":"<p>Invokes the named constructor and returns a mirror on the result.</p>\n<p>Let <em>c</em> be the class reflected by this mirror\nlet <em>a1, ..., an</em> be the elements of <a>dart-mirrors.FunctionTypeMirror.newInstance.positionalArguments</a>\nlet <em>k1, ..., km</em> be the identifiers denoted by the elements of\nnamedArguments.keys\nand let <em>v1, ..., vm</em> be the elements of namedArguments.values.\nIf <a>dart-mirrors.FunctionTypeMirror.newInstance.constructorName</a> was created from the empty string\nThen this method will execute the instance creation expression\n<em>new c(a1, ..., an, k1: v1, ..., km: vm)</em>\nin a scope that has access to the private members\nof <em>c</em>. Otherwise, let\n<em>f</em> be the simple name of the constructor denoted by <a>dart-mirrors.FunctionTypeMirror.newInstance.constructorName</a>\nThen this method will execute the instance creation expression\n <em>new c.f(a1, ..., an, k1: v1, ..., km: vm)</em>\nin a scope that has access to the private members\nof <em>c</em>.\nIn either case:\nIf the expression evaluates to a result <em>r</em>, this method returns\nthe result of calling <a href=\"*r*\">reflect</a>.\nIf evaluating the expression causes a compilation error\nthe effect is the same as if a non-reflective compilation error\nhad been encountered.\nIf evaluating the expression throws an exception <em>e</em>\n(that it does not catch)\nthis method throws <em>e</em>.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ClassMirror.newInstance","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-mirrors.InstanceMirror","inner":[]}],"parameters":{"constructorName":{"name":"constructorName","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]},"positionalArguments":{"name":"positionalArguments","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"namedArguments":{"name":"namedArguments","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.Symbol","inner":[]},{"outer":"dynamic","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-mirrors.FunctionTypeMirror.noSuchMethod","comment":"<p><a>dart-mirrors.FunctionTypeMirror.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-mirrors.FunctionTypeMirror.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-mirrors.FunctionTypeMirror.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-mirrors.FunctionTypeMirror.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"setField":{"name":"setField","qualifiedName":"dart-mirrors.FunctionTypeMirror.setField","comment":"<p>Invokes a setter and returns a mirror on the result. The setter\nmay be either the implicit setter for a non-final field or a\nuser-defined setter method.</p>\n<p>Let <em>o</em> be the object reflected by this mirror, let\n<em>f</em> be the simple name of the getter denoted by <a>dart-mirrors.FunctionTypeMirror.setField.fieldName</a>,\nand let <em>a</em> be the object bound to <a>dart-mirrors.FunctionTypeMirror.setField.value</a>.\nThen this method will perform the setter invocation\n<em>o.f = a</em>\nin a scope that has access to the private members\nof <em>o</em> (if <em>o</em> is a class or library) or the private members of the\nclass of <em>o</em> (otherwise).\nIf the invocation returns a result <em>r</em>, this method returns\nthe result of calling <a href=\"[value]\">reflect</a>.\nIf the invocation causes a compilation error\nthe effect is the same as if a non-reflective compilation error\nhad been encountered.\nIf the invocation throws an exception <em>e</em> (that it does not catch)\nthis method throws <em>e</em>.</p>","commentFrom":"","inheritedFrom":"dart-mirrors.ObjectMirror.setField","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-mirrors.InstanceMirror","inner":[]}],"parameters":{"fieldName":{"name":"fieldName","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Symbol","inner":[]}],"value":null,"annotations":[]},"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-mirrors.FunctionTypeMirror.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}