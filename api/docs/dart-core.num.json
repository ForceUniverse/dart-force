{"name":"num","qualifiedName":"dart-core.num","comment":"<p>An integer or floating-point number.</p>\n<p>It is a compile-time error for any type other than <a>dart-core.int</a> or <a>dart-core.double</a>\nto attempt to extend or implement num.</p>","isAbstract":true,"superclass":"dart-core.Object","implements":["dart-core.Comparable"],"subclass":["dart-core.double","dart-core.int"],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"dart-core.num.hashCode","comment":"<p>Returns a hash code for a numerical value.</p>\n<p>The hash code is compatible with equality. It returns the same value\nfor an <a>dart-core.int</a> and a <a>dart-core.double</a> with the same numerical value, and therefore\nthe same value for the doubles zero and minus zero.</p>\n<p>No guarantees are made about the hash code of NaN.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"isFinite":{"name":"isFinite","qualifiedName":"dart-core.num.isFinite","comment":"<p>True if the number is finite; otherwise, false.</p>\n<p>The only non-finite numbers are NaN, positive infinitity and\nnegative infinity.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isInfinite":{"name":"isInfinite","qualifiedName":"dart-core.num.isInfinite","comment":"<p>True if the number is positive infinity or negative infinity; otherwise,\nfalse.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isNaN":{"name":"isNaN","qualifiedName":"dart-core.num.isNaN","comment":"<p>True if the number is the double Not-a-Number value; otherwise, false.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isNegative":{"name":"isNegative","qualifiedName":"dart-core.num.isNegative","comment":"<p>True if the number is negative; otherwise, false.</p>\n<p>Negative numbers are those less than zero, and the double <code>-0.0</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"sign":{"name":"sign","qualifiedName":"dart-core.num.sign","comment":"<p>Returns minus one, zero or plus one depending on the sign and\nnumerical value of the number.</p>\n<p>Returns minus one if the number is less than zero,\nplus one if the number is greater than zero,\nand zero if the number is equal to zero.</p>\n<p>Returns NaN if the number is the double NaN value.</p>\n<p>Returns a number of the same type as this number.\nFor doubles, <code>-0.0.sign == -0.0</code>.</p>\n<p>The result satisfies:</p>\n<pre><code>n == n.sign * n.abs()\n</code></pre>\n<p>for all numbers <code>n</code> (except NaN, because NaN isn't <code>==</code> to itself).</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"%":{"name":"%","qualifiedName":"dart-core.num.%","comment":"<p>Euclidean modulo operator.</p>\n<p>Returns the remainder of the euclidean division. The euclidean division of\ntwo integers <code>a</code> and <code>b</code> yields two integers <code>q</code> and <code>r</code> such that\n<code>a == b * q + r</code> and <code>0 &lt;= r &lt; b.abs()</code>.</p>\n<p>The euclidean division is only defined for integers, but can be easily\nextended to work with doubles. In that case <code>r</code> may have a non-integer\nvalue, but it still verifies <code>0 &lt;= r &lt; |b|</code>.</p>\n<p>The sign of the returned value <code>r</code> is always positive.</p>\n<p>See <a>dart-core.num.remainder</a> for the remainder of the truncating division.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"*":{"name":"*","qualifiedName":"dart-core.num.*","comment":"<p>Multiplication operator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"+":{"name":"+","qualifiedName":"dart-core.num.+","comment":"<p>Addition operator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"-":{"name":"-","qualifiedName":"dart-core.num.-","comment":"<p>Subtraction operator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"/":{"name":"/","qualifiedName":"dart-core.num./","comment":"<p>Division operator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"<":{"name":"<","qualifiedName":"dart-core.num.<","comment":"<p>Relational less than operator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"<=":{"name":"<=","qualifiedName":"dart-core.num.<=","comment":"<p>Relational less than or equal operator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"==":{"name":"==","qualifiedName":"dart-core.num.==","comment":"<p>Test whether this value is numerically equal to <code>other</code>.</p>\n<p>If both operands are doubles, they are equal if they have the same\nrepresentation, except that:\n  * zero and minus zero (0.0 and -0.0) are considered equal. They</p>\n<pre><code>both have the numerical value zero.\n</code></pre><ul><li>\n<p>NaN is not equal to anything, including NaN. If either operand is\nNaN, the result is always false.</p></li></ul>\n<p>If one operand is a double and the other is an int, they are equal if\nthe double has an integer value (finite with no fractional part) and\n<code>identical(doubleValue.toInt(), intValue)</code>.</p>\n<p>If both operands are integers, they are equal if they have the same value.</p>\n<p>Returns false if <code>other</code> is not a <a>dart-core.num</a>.</p>\n<p>Notice that the behavior for NaN is non-reflexive. This means that\nequality of double values is not a proper equality relation, as is\notherwise required of <code>operator==</code>. Using NaN in, e.g., a <a>dart-collection.HashSet</a>\nwill fail to work. The behavior is the standard IEEE-754 equality of\ndoubles.</p>\n<p>If you can avoid NaN values, the remaining doubles do have a proper eqality\nrelation, and can be used safely.</p>\n<p>Use <a>dart-core.num.compareTo</a> for a comparison that distinguishes zero and minus zero,\nand that considers NaN values as equal.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},">":{"name":">","qualifiedName":"dart-core.num.>","comment":"<p>Relational greater than operator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},">=":{"name":">=","qualifiedName":"dart-core.num.>=","comment":"<p>Relational greater than or equal operator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"unary-":{"name":"unary-","qualifiedName":"dart-core.num.unary-","comment":"<p>Negate operator.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{},"annotations":[]},"~/":{"name":"~/","qualifiedName":"dart-core.num.~/","comment":"<p>Truncating division operator.</p>\n<p>If either operand is a <a>dart-core.double</a> then the result of the truncating division\n<code>a ~/ b</code> is equivalent to <code>(a / b).truncate().toInt()</code>.</p>\n<p>If both operands are <a>dart-core.int</a>s then <code>a ~/ b</code> performs the truncating\ninteger division.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"abs":{"name":"abs","qualifiedName":"dart-core.num.abs","comment":"<p>Returns the absolute value of this <a>dart-core.num</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{},"annotations":[]},"ceil":{"name":"ceil","qualifiedName":"dart-core.num.ceil","comment":"<p>Returns the least integer no smaller than <code>this</code>.</p>\n<p>If <code>this</code> is not finite (<code>NaN</code> or infinity), throws an <a>dart-core.UnsupportedError</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"ceilToDouble":{"name":"ceilToDouble","qualifiedName":"dart-core.num.ceilToDouble","comment":"<p>Returns the least double integer value no smaller than <code>this</code>.</p>\n<p>If this is already an integer valued double, including <code>-0.0</code>, or it is a\nnon-finite double value, the value is returned unmodified.</p>\n<p>For the purpose of rounding, <code>-0.0</code> is considered to be below <code>0.0</code>.\nA number <code>d</code> in the range <code>-1.0 &lt; d &lt; 0.0</code> will return <code>-0.0</code>.</p>\n<p>The result is always a double.\nIf this is a numerically large integer, the result may be an infinite\ndouble.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]},"clamp":{"name":"clamp","qualifiedName":"dart-core.num.clamp","comment":"<p>Clamps this to be in the range <a>dart-core.num.clamp.lowerLimit</a>-<a>dart-core.num.clamp.upperLimit</a>. The comparison\nis done using <a>dart-core.num.compareTo</a> and therefore takes <code>-0.0</code> into account.\nIt also implies that <a>dart-core.double.NAN</a> is treated as the maximal double value.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"lowerLimit":{"name":"lowerLimit","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]},"upperLimit":{"name":"upperLimit","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"compareTo":{"name":"compareTo","qualifiedName":"dart-core.num.compareTo","comment":"<p>Compares this to <code>other</code>.</p>\n<p>Returns a negative number if <code>this</code> is less than <code>other</code>, zero if they are\nequal, and a positive number if <code>this</code> is greater than <code>other</code>.</p>\n<p>The orderding represented by this method is a total ordering of <a>dart-core.num</a>\nvalues. All distinct doubles are non-equal, as are all distinct integers,\nbut integers are equal to doubles if they have the same numerical\nvalue.</p>\n<p>For ordering, the double NaN value is considered equal to itself, and\ngreater than any numeric value (unlike its behavior in <code>operator==</code>).</p>\n<p>The double value -0.0 is considered less than 0.0 (and the integer 0), but\ngreater than any non-zero negative value.</p>\n<p>Positive infinity is greater than any finite value (any value apart from\nitself and NaN), and negative infinity is less than any other value.</p>\n<p>All other values are compared using their numeric value.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"floor":{"name":"floor","qualifiedName":"dart-core.num.floor","comment":"<p>Returns the greatest integer no greater than <code>this</code>.</p>\n<p>If <code>this</code> is not finite (<code>NaN</code> or infinity), throws an <a>dart-core.UnsupportedError</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"floorToDouble":{"name":"floorToDouble","qualifiedName":"dart-core.num.floorToDouble","comment":"<p>Returns the greatest double integer value no greater than <code>this</code>.</p>\n<p>If this is already an integer valued double, including <code>-0.0</code>, or it is a\nnon-finite double value, the value is returned unmodified.</p>\n<p>For the purpose of rounding, <code>-0.0</code> is considered to be below <code>0.0</code>.\nA number <code>d</code> in the range <code>0.0 &lt; d &lt; 1.0</code> will return <code>0.0</code>.</p>\n<p>The result is always a double.\nIf this is a numerically large integer, the result may be an infinite\ndouble.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]},"parse":{"name":"parse","qualifiedName":"dart-core.num.parse","comment":"<p>Parses a string containing a number literal into a number.</p>\n<p>The method first tries to read the <a>dart-core.num.parse.input</a> as integer (similar to\n<a>dart-core.int.parse</a> without a radix).\nIf that fails, it tries to parse the <a>dart-core.num.parse.input</a> as a double (similar to\n<a>dart-core.double.parse</a>).\nIf that fails, too, it invokes <a>dart-core.num.parse.onError</a> with <a>dart-core.num.parse.input</a>.</p>\n<p>If no <a>dart-core.num.parse.onError</a> is supplied, it defaults to a function that throws a\n<a>dart-core.FormatException</a>.</p>\n<p>For any number <code>n</code>, this function satisfies\n<code>identical(n, num.parse(n.toString()))</code>.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"input":{"name":"input","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"onError":{"name":"onError","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"input":{"name":"input","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"remainder":{"name":"remainder","qualifiedName":"dart-core.num.remainder","comment":"<p>Returns the remainder of the truncating division of <code>this</code> by <a>dart-core.num.remainder.other</a>.</p>\n<p>The result <code>r</code> of this operation satisfies:\n<code>this == (this ~/ other) * other + r</code>.\nAs a consequence the remainder <code>r</code> has the same sign as the divider <code>this</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"round":{"name":"round","qualifiedName":"dart-core.num.round","comment":"<p>Returns the integer closest to <code>this</code>.</p>\n<p>Rounds away from zero when there is no closest integer:\n <code>(3.5).round() == 4</code> and <code>(-3.5).round() == -4</code>.</p>\n<p>If <code>this</code> is not finite (<code>NaN</code> or infinity), throws an <a>dart-core.UnsupportedError</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"roundToDouble":{"name":"roundToDouble","qualifiedName":"dart-core.num.roundToDouble","comment":"<p>Returns the double integer value closest to <code>this</code>.</p>\n<p>Rounds away from zero when there is no closest integer:\n <code>(3.5).roundToDouble() == 4</code> and <code>(-3.5).roundToDouble() == -4</code>.</p>\n<p>If this is already an integer valued double, including <code>-0.0</code>, or it is a\nnon-finite double value, the value is returned unmodified.</p>\n<p>For the purpose of rounding, <code>-0.0</code> is considered to be below <code>0.0</code>,\nand <code>-0.0</code> is therefore considered closer to negative numbers than <code>0.0</code>.\nThis means that for a value, <code>d</code> in the range <code>-0.5 &lt; d &lt; 0.0</code>,\nthe result is <code>-0.0</code>.</p>\n<p>The result is always a double.\nIf this is a numerically large integer, the result may be an infinite\ndouble.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]},"toDouble":{"name":"toDouble","qualifiedName":"dart-core.num.toDouble","comment":"<p>Return this <a>dart-core.num</a> as a <a>dart-core.double</a>.</p>\n<p>If the number is not representable as a <a>dart-core.double</a>, an\napproximation is returned. For numerically large integers, the\napproximation may be infinite.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]},"toInt":{"name":"toInt","qualifiedName":"dart-core.num.toInt","comment":"<p>Truncates this <a>dart-core.num</a> to an integer and returns the result as an <a>dart-core.int</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-core.num.toString","comment":"<p>Returns the shortest string that correctly represent the input number.</p>\n<p>All <a>dart-core.double</a>s in the range <code>10^-6</code> (inclusive) to <code>10^21</code> (exclusive)\nare converted to their decimal representation with at least one digit\nafter the decimal point. For all other doubles,\nexcept for special values like <code>NaN</code> or <code>Infinity</code>, this method returns an\nexponential representation (see <a>dart-core.num.toStringAsExponential</a>).</p>\n<p>Returns <code>\"NaN\"</code> for <a>dart-core.double.NAN</a>, <code>\"Infinity\"</code> for <a>dart-core.double.INFINITY</a>, and\n<code>\"-Infinity\"</code> for double.MINUS_INFINITY.</p>\n<p>An <a>dart-core.int</a> is converted to a decimal representation with no decimal point.</p>\n<p>Examples:</p>\n<pre><code>(0.000001).toString();  // \"0.000001\"\n(0.0000001).toString(); // \"1e-7\"\n(111111111111111111111.0).toString();  // \"111111111111111110000.0\"\n(100000000000000000000.0).toString();  // \"100000000000000000000.0\"\n(1000000000000000000000.0).toString(); // \"1e+21\"\n(1111111111111111111111.0).toString(); // \"1.1111111111111111e+21\"\n1.toString(); // \"1\"\n111111111111111111111.toString();  // \"111111111111111110000\"\n100000000000000000000.toString();  // \"100000000000000000000\"\n1000000000000000000000.toString(); // \"1000000000000000000000\"\n1111111111111111111111.toString(); // \"1111111111111111111111\"\n1.234e5.toString();   // 123400\n1234.5e6.toString();  // 1234500000\n12.345e67.toString(); // 1.2345e+68\n</code></pre>\n<p>Note: the conversion may round the output if the returned string\nis accurate enough to uniquely identify the input-number.\nFor example the most precise representation of the <a>dart-core.double</a> <code>9e59</code> equals\n<code>\"899999999999999918767229449717619953810131273674690656206848\"</code>, but\nthis method returns the shorter (but still uniquely identifying) <code>\"9e59\"</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"toStringAsExponential":{"name":"toStringAsExponential","qualifiedName":"dart-core.num.toStringAsExponential","comment":"<p>Returns an exponential string-representation of <code>this</code>.</p>\n<p>Converts <code>this</code> to a <a>dart-core.double</a> before computing the string representation.</p>\n<p>If <a>dart-core.num.toStringAsExponential.fractionDigits</a> is given then it must be an integer satisfying:\n<code>0 &lt;= fractionDigits &lt;= 20</code>. In this case the string contains exactly\n<a>dart-core.num.toStringAsExponential.fractionDigits</a> after the decimal point. Otherwise, without the parameter,\nthe returned string uses the shortest number of digits that accurately\nrepresent this.</p>\n<p>If <a>dart-core.num.toStringAsExponential.fractionDigits</a> equals 0 then the decimal point is omitted.\nExamples:</p>\n<pre><code>1.toStringAsExponential();       // 1e+0\n1.toStringAsExponential(3);      // 1.000e+0\n123456.toStringAsExponential();  // 1.23456e+5\n123456.toStringAsExponential(3); // 1.235e+5\n123.toStringAsExponential(0);    // 1e+2\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"fractionDigits":{"name":"fractionDigits","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toStringAsFixed":{"name":"toStringAsFixed","qualifiedName":"dart-core.num.toStringAsFixed","comment":"<p>Returns a decimal-point string-representation of <code>this</code>.</p>\n<p>Converts <code>this</code> to a <a>dart-core.double</a> before computing the string representation.</p>\n<p>If the absolute value of <code>this</code> is greater or equal to <code>10^21</code> then this\nmethods returns an exponential representation computed by\n<code>this.toStringAsExponential()</code>. Otherwise the result\nis the closest string representation with exactly <a>dart-core.num.toStringAsFixed.fractionDigits</a> digits\nafter the decimal point. If <a>dart-core.num.toStringAsFixed.fractionDigits</a> equals 0 then the decimal\npoint is omitted.</p>\n<p>The parameter <a>dart-core.num.toStringAsFixed.fractionDigits</a> must be an integer satisfying:\n<code>0 &lt;= fractionDigits &lt;= 20</code>.</p>\n<p>Examples:</p>\n<pre><code>1.toStringAsFixed(3);  // 1.000\n(4321.12345678).toStringAsFixed(3);  // 4321.123\n(4321.12345678).toStringAsFixed(5);  // 4321.12346\n123456789012345678901.toStringAsFixed(3);  // 123456789012345683968.000\n1000000000000000000000.toStringAsFixed(3); // 1e+21\n5.25.toStringAsFixed(0); // 5\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"fractionDigits":{"name":"fractionDigits","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toStringAsPrecision":{"name":"toStringAsPrecision","qualifiedName":"dart-core.num.toStringAsPrecision","comment":"<p>Converts <code>this</code> to a double and returns a string representation with\nexactly <a>dart-core.num.toStringAsPrecision.precision</a> significant digits.</p>\n<p>The parameter <a>dart-core.num.toStringAsPrecision.precision</a> must be an integer satisfying:\n<code>1 &lt;= precision &lt;= 21</code>.</p>\n<p>Examples:</p>\n<pre><code>1.toStringAsPrecision(2);       // 1.0\n1e15.toStringAsPrecision(3);    // 1.00+15\n1234567.toStringAsPrecision(3); // 1.23e+6\n1234567.toStringAsPrecision(9); // 1234567.00\n12345678901234567890.toStringAsPrecision(20); // 12345678901234567168\n12345678901234567890.toStringAsPrecision(14); // 1.2345678901235e+19\n0.00000012345.toPrecision(15); // 1.23450000000000e-7\n0.0000012345.toPrecision(15);  // 0.00000123450000000000\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"precision":{"name":"precision","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"truncate":{"name":"truncate","qualifiedName":"dart-core.num.truncate","comment":"<p>Returns the integer obtained by discarding any fractional\ndigits from <code>this</code>.</p>\n<p>If <code>this</code> is not finite (<code>NaN</code> or infinity), throws an <a>dart-core.UnsupportedError</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"truncateToDouble":{"name":"truncateToDouble","qualifiedName":"dart-core.num.truncateToDouble","comment":"<p>Returns the double integer value obtained by discarding any fractional\ndigits from the double value of <code>this</code>.</p>\n<p>If this is already an integer valued double, including <code>-0.0</code>, or it is a\nnon-finite double value, the value is returned unmodified.</p>\n<p>For the purpose of rounding, <code>-0.0</code> is considered to be below <code>0.0</code>.\nA number <code>d</code> in the range <code>-1.0 &lt; d &lt; 0.0</code> will return <code>-0.0</code>, and\nin the range <code>0.0 &lt; d &lt; 1.0</code> it will return 0.0.</p>\n<p>The result is always a double.\nIf this is a numerically large integer, the result may be an infinite\ndouble.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"dart-core.num.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-core.num.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-core.num.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-core.num.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart-core.num.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart-core.num.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"compareTo":{"name":"compareTo","qualifiedName":"dart-core.num.compareTo","comment":"<p>Compares this object to another <a>dart-core.Comparable</a></p>\n<p>Returns a value like a <a>dart-core.Comparator</a> when comparing <code>this</code> to <a>dart-core.num.compareTo.other</a>.\nThat is, it returns a negative integer if <code>this</code> is ordered before <a>dart-core.num.compareTo.other</a>,\na positive integer if <code>this</code> is ordered after <a>dart-core.num.compareTo.other</a>,\nand zero if <code>this</code> and <a>dart-core.num.compareTo.other</a> are ordered together.</p>\n<p>The <a>dart-core.num.compareTo.other</a> argument must be a value that is comparable to this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Comparable.compareTo","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Comparable.T","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-core.num.noSuchMethod","comment":"<p><a>dart-core.num.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-core.num.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-core.num.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-core.num.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-core.num.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}