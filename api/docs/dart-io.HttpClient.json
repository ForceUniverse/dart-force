{"name":"HttpClient","qualifiedName":"dart-io.HttpClient","comment":"<p>A client that receives content, such as web pages, from\na server using the HTTP protocol.</p>\n<p>HttpClient contains a number of methods to send an <a>dart-io.HttpClientRequest</a>\nto an Http server and receive an <a>dart-io.HttpClientResponse</a> back.\nFor example, you can use the <a>dart-io.HttpClient.get</a>, <a>dart-io.HttpClient.getUrl</a>, <a>dart-io.HttpClient.post</a>, and <a>dart-io.HttpClient.postUrl</a> methods\nfor GET and POST requests, respectively.</p>\n<h2>Making a simple GET request: an example</h2>\n<p>A <code>getUrl</code> request is a two-step process, triggered by two <a>dart-async.Future</a>s.\nWhen the first future completes with a <a>dart-io.HttpClientRequest</a>, the underlying\nnetwork connection has been established, but no data has been sent.\nIn the callback function for the first future, the HTTP headers and body\ncan be set on the request. Either the first write to the request object\nor a call to <a>dart-io.HttpClient.close</a> sends the request to the server.</p>\n<p>When the HTTP response is received from the server,\nthe second future, which is returned by close,\ncompletes with an <a>dart-io.HttpClientResponse</a> object.\nThis object provides access to the headers and body of the response.\nThe body is available as a stream implemented by HttpClientResponse.\nIf a body is present, it must be read. Otherwise, it leads to resource\nleaks. Consider using HttpClientResponse.drain if the body is unused.</p>\n<pre><code>HttpClient client = new HttpClient();\nclient.getUrl(Uri.parse(\"http://www.example.com/\"))\n    .then((HttpClientRequest request) {\n      // Optionally set up headers...\n      // Optionally write to the request object...\n      // Then call close.\n      ...\n      return request.close();\n    })\n    .then((HttpClientResponse response) {\n      // Process the response.\n      ...\n    });\n</code></pre>\n<p>The future for <a>dart-io.HttpClientRequest</a> is created by methods such as\n<a>dart-io.HttpClient.getUrl</a> and <a>dart-io.HttpClient.open</a>.</p>\n<h2>Headers</h2>\n<p>All HttpClient requests set the following header by default:</p>\n<pre><code>Accept-Encoding: gzip\n</code></pre>\n<p>This allows the HTTP server to use gzip compression for the body if\npossible. If this behavior is not desired set the\n<code>Accept-Encoding</code> header to something else.\nTo turn off gzip compression of the response, clear this header:</p>\n<pre><code> request.headers.removeAll(HttpHeaders.ACCEPT_ENCODING)\n</code></pre>\n<h2>Closing the HttpClient</h2>\n<p>The HttpClient supports persistent connections and caches network\nconnections to reuse them for multiple requests whenever\npossible. This means that network connections can be kept open for\nsome time after a request has completed. Use HttpClient.close\nto force the HttpClient object to shut down and to close the idle\nnetwork connections.</p>\n<h2>Turning proxies on and off</h2>\n<p>By default the HttpClient uses the proxy configuration available\nfrom the environment, see <a>dart-io.HttpClient.findProxyFromEnvironment</a>. To turn off\nthe use of proxies set the <a>dart-io.HttpClient.findProxy=</a> property to\n<code>null</code>.</p>\n<pre><code>HttpClient client = new HttpClient();\nclient.findProxy = null;\n</code></pre>","isAbstract":true,"superclass":"dart-core.Object","implements":[],"subclass":[],"variables":{"DEFAULT_HTTPS_PORT":{"name":"DEFAULT_HTTPS_PORT","qualifiedName":"dart-io.HttpClient.DEFAULT_HTTPS_PORT","comment":"","final":false,"static":true,"constant":true,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]},"DEFAULT_HTTP_PORT":{"name":"DEFAULT_HTTP_PORT","qualifiedName":"dart-io.HttpClient.DEFAULT_HTTP_PORT","comment":"","final":false,"static":true,"constant":true,"type":[{"outer":"dart-core.int","inner":[]}],"annotations":[]},"idleTimeout":{"name":"idleTimeout","qualifiedName":"dart-io.HttpClient.idleTimeout","comment":"<p>Get and set the idle timeout of non-active persistent (keep-alive)\nconnections. The default value is 15 seconds.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.Duration","inner":[]}],"annotations":[]},"userAgent":{"name":"userAgent","qualifiedName":"dart-io.HttpClient.userAgent","comment":"<p>Set and get the default value of the <code>User-Agent</code> header for all requests\ngenerated by this <a>dart-io.HttpClient</a>. The default value is\n<code>Dart/&lt;version&gt; (dart:io)</code>.</p>\n<p>If the userAgent is set to <code>null</code>, no default <code>User-Agent</code> header will be\nadded to each request.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]}},"inheritedVariables":{},"methods":{"setters":{"authenticate=":{"name":"authenticate=","qualifiedName":"dart-io.HttpClient.authenticate=","comment":"<p>Sets the function to be called when a site is requesting\nauthentication. The URL requested and the security realm from the\nserver are passed in the arguments url and realm.</p>\n<p>The function returns a <a>dart-async.Future</a> which should complete when the\nauthentication has been resolved. If credentials cannot be\nprovided the <a>dart-async.Future</a> should complete with <code>false</code>. If\ncredentials are available the function should add these using\n<a>dart-io.HttpClient.addCredentials</a> before completing the <a>dart-async.Future</a> with the value\n<code>true</code>.</p>\n<p>If the <a>dart-async.Future</a> completes with true the request will be retried\nusing the updated credentials. Otherwise response processing will\ncontinue normally.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.bool","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]},"scheme":{"name":"scheme","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"realm":{"name":"realm","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"authenticateProxy=":{"name":"authenticateProxy=","qualifiedName":"dart-io.HttpClient.authenticateProxy=","comment":"<p>Sets the function to be called when a proxy is requesting\nauthentication. Information on the proxy in use and the security\nrealm for the authentication are passed in the arguments host,\nport and realm.</p>\n<p>The function returns a <a>dart-async.Future</a> which should complete when the\nauthentication has been resolved. If credentials cannot be\nprovided the <a>dart-async.Future</a> should complete with <code>false</code>. If\ncredentials are available the function should add these using\n<a>dart-io.HttpClient.addProxyCredentials</a> before completing the <a>dart-async.Future</a> with the value\n<code>true</code>.</p>\n<p>If the <a>dart-async.Future</a> completes with <code>true</code> the request will be retried\nusing the updated credentials. Otherwise response processing will\ncontinue normally.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.bool","inner":[]}]}],"parameters":{"host":{"name":"host","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"port":{"name":"port","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"scheme":{"name":"scheme","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"realm":{"name":"realm","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"badCertificateCallback=":{"name":"badCertificateCallback=","qualifiedName":"dart-io.HttpClient.badCertificateCallback=","comment":"<p>Sets a callback that will decide whether to accept a secure connection\nwith a server certificate that cannot be authenticated by any of our\ntrusted root certificates.</p>\n<p>When an secure HTTP request if made, using this HttpClient, and the\nserver returns a server certificate that cannot be authenticated, the\ncallback is called asynchronously with the <a>dart-io.X509Certificate</a> object and\nthe server's hostname and port.  If the value of <a>dart-io.HttpClient.badCertificateCallback=</a>\nis <code>null</code>, the bad certificate is rejected, as if the callback\nreturned <code>false</code></p>\n<p>If the callback returns true, the secure connection is accepted and the\n<code>Future&lt;HttpClientRequest&gt;</code> that was returned from the call making the\nrequest completes with a valid HttpRequest object. If the callback returns\nfalse, the <code>Future&lt;HttpClientRequest&gt;</code> completes with an exception.</p>\n<p>If a bad certificate is received on a connection attempt, the library calls\nthe function that was the value of badCertificateCallback at the time\nthe the request is made, even if the value of badCertificateCallback\nhas changed since then.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"callback":{"name":"callback","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"cert":{"name":"cert","optional":false,"named":false,"default":false,"type":[{"outer":"dart-io.X509Certificate","inner":[]}],"value":null,"annotations":[]},"host":{"name":"host","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"port":{"name":"port","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"findProxy=":{"name":"findProxy=","qualifiedName":"dart-io.HttpClient.findProxy=","comment":"<p>Sets the function used to resolve the proxy server to be used for\nopening a HTTP connection to the specified url. If this\nfunction is not set, direct connections will always be used.</p>\n<p>The string returned by <a>dart-io.HttpClient.findProxy=.f</a> must be in the format used by browser\nPAC (proxy auto-config) scripts. That is either</p>\n<pre><code>\"DIRECT\"\n</code></pre>\n<p>for using a direct connection or</p>\n<pre><code>\"PROXY host:port\"\n</code></pre>\n<p>for using the proxy server <code>host</code> on port <code>port</code>.</p>\n<p>A configuration can contain several configuration elements\nseparated by semicolons, e.g.</p>\n<pre><code>\"PROXY host:port; PROXY host2:port2; DIRECT\"\n</code></pre>\n<p>The static function <a>dart-io.HttpClient.findProxyFromEnvironment</a> on this class can\nbe used to implement proxy server resolving based on environment\nvariables.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"f":{"name":"f","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]}},"getters":{},"constructors":{"":{"name":"","qualifiedName":"dart-io.HttpClient.HttpClient-","comment":"","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-io.HttpClient","inner":[]}],"parameters":{},"annotations":[]}},"operators":{},"methods":{"addCredentials":{"name":"addCredentials","qualifiedName":"dart-io.HttpClient.addCredentials","comment":"<p>Add credentials to be used for authorizing HTTP requests.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]},"realm":{"name":"realm","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"credentials":{"name":"credentials","optional":false,"named":false,"default":false,"type":[{"outer":"dart-io.HttpClientCredentials","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"addProxyCredentials":{"name":"addProxyCredentials","qualifiedName":"dart-io.HttpClient.addProxyCredentials","comment":"<p>Add credentials to be used for authorizing HTTP proxies.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"host":{"name":"host","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"port":{"name":"port","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"realm":{"name":"realm","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"credentials":{"name":"credentials","optional":false,"named":false,"default":false,"type":[{"outer":"dart-io.HttpClientCredentials","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"close":{"name":"close","qualifiedName":"dart-io.HttpClient.close","comment":"<p>Shutdown the HTTP client. If <a>dart-io.HttpClient.close.force</a> is <code>false</code> (the default)\nthe <code>HttpClient</code> will be kept alive until all active\nconnections are done. If <a>dart-io.HttpClient.close.force</a> is <code>true</code> any active\nconnections will be closed to immediately release all\nresources. These closed connections will receive an <code>onError</code>\ncallback to indicate that the client was shutdown. In both cases\ntrying to establish a new connection after calling shutdown\nwill throw an exception.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"force":{"name":"force","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"delete":{"name":"delete","qualifiedName":"dart-io.HttpClient.delete","comment":"<p>Opens a HTTP connection using the DELETE method.</p>\n<p>The server is specified using <a>dart-io.HttpClient.delete.host</a> and <a>dart-io.HttpClient.delete.port</a>, and the path\n(including possible fragment and query) is specified using\n<a>dart-io.HttpClient.delete.path</a>.</p>\n<p>See <a>dart-io.HttpClient.open</a> for details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"host":{"name":"host","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"port":{"name":"port","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"deleteUrl":{"name":"deleteUrl","qualifiedName":"dart-io.HttpClient.deleteUrl","comment":"<p>Opens a HTTP connection using the DELETE method.</p>\n<p>The URL to use is specified in <a>dart-io.HttpClient.deleteUrl.url</a>.</p>\n<p>See <a>dart-io.HttpClient.openUrl</a> for details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"findProxyFromEnvironment":{"name":"findProxyFromEnvironment","qualifiedName":"dart-io.HttpClient.findProxyFromEnvironment","comment":"<p>Function for resolving the proxy server to be used for a HTTP\nconnection from the proxy configuration specified through\nenvironment variables.</p>\n<p>The following environment variables are taken into account:</p>\n<pre><code>http_proxy\nhttps_proxy\nno_proxy\nHTTP_PROXY\nHTTPS_PROXY\nNO_PROXY\n</code></pre>\n<p><code>http_proxy</code> and <code>HTTP_PROXY</code> specify the proxy server to use for\nhttp:// urls. Use the format <code>hostname:port</code>. If no port is used a\ndefault of 1080 will be used. If both are set the lower case one takes\nprecedence.</p>\n<p><code>https_proxy</code> and <code>HTTPS_PROXY</code> specify the proxy server to use for\nhttps:// urls. Use the format <code>hostname:port</code>. If no port is used a\ndefault of 1080 will be used. If both are set the lower case one takes\nprecedence.</p>\n<p><code>no_proxy</code> and <code>NO_PROXY</code> specify a comma separated list of\npostfixes of hostnames for which not to use the proxy\nserver. E.g. the value \"localhost,127.0.0.1\" will make requests\nto both \"localhost\" and \"127.0.0.1\" not use a proxy. If both are set\nthe lower case one takes precedence.</p>\n<p>To activate this way of resolving proxies assign this function to\nthe <a>dart-io.HttpClient.findProxy=</a> property on the <a>dart-io.HttpClient</a>.</p>\n<pre><code>HttpClient client = new HttpClient();\nclient.findProxy = HttpClient.findProxyFromEnvironment;\n</code></pre>\n<p>If you don't want to use the system environment you can use a\ndifferent one by wrapping the function.</p>\n<pre><code>HttpClient client = new HttpClient();\nclient.findProxy = (url) {\n  return HttpClient.findProxyFromEnvironment(\n      url, {\"http_proxy\": ..., \"no_proxy\": ...});\n}\n</code></pre>\n<p>If a proxy requires authentication it is possible to configure\nthe username and password as well. Use the format\n<code>username:password@hostname:port</code> to include the username and\npassword. Alternatively the API <a>dart-io.HttpClient.addProxyCredentials</a> can be used\nto set credentials for proxies which require authentication.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]},"environment":{"name":"environment","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"get":{"name":"get","qualifiedName":"dart-io.HttpClient.get","comment":"<p>Opens a HTTP connection using the GET method.</p>\n<p>The server is specified using <a>dart-io.HttpClient.get.host</a> and <a>dart-io.HttpClient.get.port</a>, and the path\n(including possible fragment and query) is specified using\n<a>dart-io.HttpClient.get.path</a>.</p>\n<p>See <a>dart-io.HttpClient.open</a> for details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"host":{"name":"host","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"port":{"name":"port","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"getUrl":{"name":"getUrl","qualifiedName":"dart-io.HttpClient.getUrl","comment":"<p>Opens a HTTP connection using the GET method.</p>\n<p>The URL to use is specified in <a>dart-io.HttpClient.getUrl.url</a>.</p>\n<p>See <a>dart-io.HttpClient.openUrl</a> for details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"head":{"name":"head","qualifiedName":"dart-io.HttpClient.head","comment":"<p>Opens a HTTP connection using the HEAD method.</p>\n<p>The server is specified using <a>dart-io.HttpClient.head.host</a> and <a>dart-io.HttpClient.head.port</a>, and the path\n(including possible fragment and query) is specified using\n<a>dart-io.HttpClient.head.path</a>.</p>\n<p>See <a>dart-io.HttpClient.open</a> for details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"host":{"name":"host","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"port":{"name":"port","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"headUrl":{"name":"headUrl","qualifiedName":"dart-io.HttpClient.headUrl","comment":"<p>Opens a HTTP connection using the HEAD method.</p>\n<p>The URL to use is specified in <a>dart-io.HttpClient.headUrl.url</a>.</p>\n<p>See <a>dart-io.HttpClient.openUrl</a> for details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"open":{"name":"open","qualifiedName":"dart-io.HttpClient.open","comment":"<p>Opens a HTTP connection.</p>\n<p>The HTTP method to use is specified in <a>dart-io.HttpClient.open.method</a>, the server is\nspecified using <a>dart-io.HttpClient.open.host</a> and <a>dart-io.HttpClient.open.port</a>, and the path (including\npossible fragment and query) is specified using <a>dart-io.HttpClient.open.path</a>.</p>\n<p>The <code>Host</code> header for the request will be set to the value\n<a>dart-io.HttpClient.open.host</a>:<a>dart-io.HttpClient.open.port</a>. This can be overridden through the\n<a>dart-io.HttpClientRequest</a> interface before the request is sent.  NOTE\nif <a>dart-io.HttpClient.open.host</a> is an IP address this will still be set in the <code>Host</code>\nheader.</p>\n<p>For additional information on the sequence of events during an\nHTTP transaction, and the objects returned by the futures, see\nthe overall documentation for the class <a>dart-io.HttpClient</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"method":{"name":"method","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"host":{"name":"host","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"port":{"name":"port","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"openUrl":{"name":"openUrl","qualifiedName":"dart-io.HttpClient.openUrl","comment":"<p>Opens a HTTP connection.</p>\n<p>The HTTP method is specified in <a>dart-io.HttpClient.openUrl.method</a> and the URL to use in\n<a>dart-io.HttpClient.openUrl.url</a>.</p>\n<p>The <code>Host</code> header for the request will be set to the value\nhost:port. This can be overridden through the\n<a>dart-io.HttpClientRequest</a> interface before the request is sent.  NOTE\nif host is an IP address this will still be set in the <code>Host</code>\nheader.</p>\n<p>For additional information on the sequence of events during an\nHTTP transaction, and the objects returned by the futures, see\nthe overall documentation for the class <a>dart-io.HttpClient</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"method":{"name":"method","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"patch":{"name":"patch","qualifiedName":"dart-io.HttpClient.patch","comment":"<p>Opens a HTTP connection using the PATCH method.</p>\n<p>The server is specified using <a>dart-io.HttpClient.patch.host</a> and <a>dart-io.HttpClient.patch.port</a>, and the path\n(including possible fragment and query) is specified using\n<a>dart-io.HttpClient.patch.path</a>.</p>\n<p>See <a>dart-io.HttpClient.open</a> for details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"host":{"name":"host","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"port":{"name":"port","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"patchUrl":{"name":"patchUrl","qualifiedName":"dart-io.HttpClient.patchUrl","comment":"<p>Opens a HTTP connection using the PATCH method.</p>\n<p>The URL to use is specified in <a>dart-io.HttpClient.patchUrl.url</a>.</p>\n<p>See <a>dart-io.HttpClient.openUrl</a> for details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"post":{"name":"post","qualifiedName":"dart-io.HttpClient.post","comment":"<p>Opens a HTTP connection using the POST method.</p>\n<p>The server is specified using <a>dart-io.HttpClient.post.host</a> and <a>dart-io.HttpClient.post.port</a>, and the path\n(including possible fragment and query) is specified using\n<a>dart-io.HttpClient.post.path</a>.</p>\n<p>See <a>dart-io.HttpClient.open</a> for details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"host":{"name":"host","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"port":{"name":"port","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"postUrl":{"name":"postUrl","qualifiedName":"dart-io.HttpClient.postUrl","comment":"<p>Opens a HTTP connection using the POST method.</p>\n<p>The URL to use is specified in <a>dart-io.HttpClient.postUrl.url</a>.</p>\n<p>See <a>dart-io.HttpClient.openUrl</a> for details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"put":{"name":"put","qualifiedName":"dart-io.HttpClient.put","comment":"<p>Opens a HTTP connection using the PUT method.</p>\n<p>The server is specified using <a>dart-io.HttpClient.put.host</a> and <a>dart-io.HttpClient.put.port</a>, and the path\n(including possible fragment and query) is specified using\n<a>dart-io.HttpClient.put.path</a>.</p>\n<p>See <a>dart-io.HttpClient.open</a> for details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"host":{"name":"host","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"port":{"name":"port","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"putUrl":{"name":"putUrl","qualifiedName":"dart-io.HttpClient.putUrl","comment":"<p>Opens a HTTP connection using the PUT method.</p>\n<p>The URL to use is specified in <a>dart-io.HttpClient.putUrl.url</a>.</p>\n<p>See <a>dart-io.HttpClient.openUrl</a> for details.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.HttpClientRequest","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"dart-io.HttpClient.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-io.HttpClient.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-io.HttpClient.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-io.HttpClient.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart-io.HttpClient.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart-io.HttpClient.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-io.HttpClient.noSuchMethod","comment":"<p><a>dart-io.HttpClient.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-io.HttpClient.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-io.HttpClient.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-io.HttpClient.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-io.HttpClient.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}