{"name":"Process","qualifiedName":"dart-io.Process","comment":"<p>The means to execute a program.</p>\n<p>Use the static <a>dart-io.Process.start</a> and <a>dart-io.Process.run</a> methods to start a new process.\nThe run method executes the process non-interactively to completion.\nIn contrast, the start method allows your code to interact with the\nrunning process.</p>\n<h2>Start a process with the run method</h2>\n<p>The following code sample uses the run method to create a process\nthat runs the UNIX command <code>ls</code>, which lists the contents of a directory.\nThe run method completes with a <a>dart-io.ProcessResult</a> object when the process\nterminates. This provides access to the output and exit code from the\nprocess. The run method does not return a Process object; this prevents your\ncode from interacting with the running process.</p>\n<pre><code>import 'dart:io';\n\nmain() {\n  // List all files in the current directory in UNIX-like systems.\n  Process.run('ls', ['-l']).then((ProcessResult results) {\n    print(results.stdout);\n  });\n}\n</code></pre>\n<h2>Start a process with the start method</h2>\n<p>The following example uses start to create the process.\nThe start method returns a <a>dart-async.Future</a> for a Process object.\nWhen the future completes the process is started and\nyour code can interact with the\nProcess: writing to stdin, listening to stdout, and so on.</p>\n<p>The following sample starts the UNIX <code>cat</code> utility, which when given no\ncommand-line arguments, echos its input.\nThe program writes to the process's standard input stream\nand prints data from its standard output stream.</p>\n<pre><code>import 'dart:io';\nimport 'dart:convert';\n\nmain() {\n  Process.start('cat', []).then((Process process) {\n    process.stdout\n        .transform(UTF8.decoder)\n        .listen((data) { print(data); });\n    process.stdin.writeln('Hello, world!');\n    process.stdin.writeln('Hello, galaxy!');\n    process.stdin.writeln('Hello, universe!');\n  });\n}\n</code></pre>\n<h2>Standard I/O streams</h2>\n<p>As seen in the previous code sample, you can interact with the Process's\nstandard output stream through the getter <a>dart-io.Process.stdout</a>,\nand you can interact with the Process's standard input stream through\nthe getter <a>dart-io.Process.stdin</a>.\nIn addition, Process provides a getter <a>dart-io.Process.stderr</a> for using the Process's\nstandard error stream.</p>\n<p>A Process's streams are distinct from the top-level streams\nfor the current program.</p>\n<h2>Exit codes</h2>\n<p>Call the <a>dart-io.Process.exitCode</a> method to get the exit code of the process.\nThe exit code indicates whether the program terminated successfully\n(usually indicated with an exit code of 0) or with an error.</p>\n<p>If the start method is used, the exitCode is available through a future\non the Process object (as shown in the example below).\nIf the run method is used, the exitCode is available\nthrough a getter on the ProcessResult instance.</p>\n<pre><code>import 'dart:io';\n\nmain() {\n  Process.start('ls', ['-l']).then((process) {\n    // Get the exit code from the new process.\n    process.exitCode.then((exitCode) {\n      print('exit code: $exitCode');\n    });\n  });\n}\n</code></pre>\n<h2>Other resources</h2>\n<p><a href=\"https://www.dartlang.org/dart-by-example/#dart-io-and-command-line-apps\">Dart by Example</a>\nprovides additional task-oriented code samples that show how to use\nvarious API from the dart:io library.</p>","isAbstract":true,"superclass":"dart-core.Object","implements":[],"subclass":[],"variables":{"exitCode":{"name":"exitCode","qualifiedName":"dart-io.Process.exitCode","comment":"<p>Returns a <code>Future</code> which completes with the exit code of the process\nwhen the process completes.</p>\n<p>The handling of exit codes is platform specific.</p>\n<p>On Linux and Mac a normal exit code will be a positive value in\nthe range 0..255. If the process was terminated due to a signal\nthe exit code will be a negative value in the range -255..-1,\nwhere the absolute value of the exit code is the signal\nnumber. For example, if a process crashes due to a segmentation\nviolation the exit code will be -11, as the signal SIGSEGV has the\nnumber 11.</p>\n<p>On Windows a process can report any 32-bit value as an exit\ncode. When returning the exit code this exit code is turned into\na signed value. Some special values are used to report\ntermination due to some system event. E.g. if a process crashes\ndue to an access violation the 32-bit exit code is <code>0xc0000005</code>,\nwhich will be returned as the negative number <code>-1073741819</code>. To\nget the original 32-bit value use <code>(0x100000000 + exitCode) &amp;\n0xffffffff</code>.</p>","final":false,"static":false,"constant":false,"type":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.int","inner":[]}]}],"annotations":[]}},"inheritedVariables":{},"methods":{"setters":{},"getters":{"pid":{"name":"pid","qualifiedName":"dart-io.Process.pid","comment":"<p>Returns the process id of the process.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"stderr":{"name":"stderr","qualifiedName":"dart-io.Process.stderr","comment":"<p>Returns the standard error stream of the process as a <code>Stream</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}]}],"parameters":{},"annotations":[]},"stdin":{"name":"stdin","qualifiedName":"dart-io.Process.stdin","comment":"<p>Returns the standard input stream of the process as an <a>dart-io.IOSink</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.IOSink","inner":[]}],"parameters":{},"annotations":[]},"stdout":{"name":"stdout","qualifiedName":"dart-io.Process.stdout","comment":"<p>Returns the standard output stream of the process as a <code>Stream</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{},"methods":{"kill":{"name":"kill","qualifiedName":"dart-io.Process.kill","comment":"<p>On Linux and Mac OS, <a>dart-io.Process.kill</a> sends <a>dart-io.Process.kill.signal</a> to the process. When the process\nterminates as a result of calling <a>dart-io.Process.kill</a>, the value for <a>dart-io.Process.exitCode</a> may be a\nnegative number corresponding to the provided <a>dart-io.Process.kill.signal</a>.</p>\n<p>On Windows, <a>dart-io.Process.kill</a> kills the process, ignoring the <a>dart-io.Process.kill.signal</a> flag.</p>\n<p>Returns <code>true</code> if the signal is successfully sent and process is killed.\nOtherwise the signal could not be sent, usually meaning that the process is\nalready dead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"signal":{"name":"signal","optional":true,"named":false,"default":true,"type":[{"outer":"dart-io.ProcessSignal","inner":[]}],"value":"ConstructedConstant(ProcessSignal(\"_signalNumber\"=Instance of 'IntConstant',\"_name\"=Instance of 'StringConstant'))","annotations":[]}},"annotations":[]},"run":{"name":"run","qualifiedName":"dart-io.Process.run","comment":"<p>Starts a process and runs it non-interactively to completion. The\nprocess run is <a>dart-io.Process.run.executable</a> with the specified <a>dart-io.Process.run.arguments</a>.</p>\n<p>Use <a>dart-io.Process.run.workingDirectory</a> to set the working directory for the process. Note\nthat the change of directory occurs before executing the process on some\nplatforms, which may have impact when using relative paths for the\nexecutable and the arguments.</p>\n<p>Use <a>dart-io.Process.run.environment</a> to set the environment variables for the process. If not\nset the environment of the parent process is inherited. Currently, only\nUS-ASCII environment variables are supported and errors are likely to occur\nif an environment variable with code-points outside the US-ASCII range is\npassed in.</p>\n<p>If <a>dart-io.Process.run.includeParentEnvironment</a> is <code>true</code>, the process's environment will\ninclude the parent process's environment, with <a>dart-io.Process.run.environment</a> taking\nprecedence. Default is <code>true</code>.</p>\n<p>If <a>dart-io.Process.run.runInShell</a> is true, the process will be spawned through a system\nshell. On Linux and Mac OS, <code>/bin/sh</code> is used, while\n<code>%WINDIR%\\system32\\cmd.exe</code> is used on Windows.</p>\n<p>The encoding used for decoding <code>stdout</code> and <code>stderr</code> into text is\ncontrolled through <a>dart-io.Process.run.stdoutEncoding</a> and <a>dart-io.Process.run.stderrEncoding</a>. The\ndefault encoding is <a>dart-io.SYSTEM_ENCODING</a>. If <code>null</code> is used no\ndecoding will happen and the <a>dart-io.ProcessResult</a> will hold binary\ndata.</p>\n<p>Returns a <code>Future&lt;ProcessResult&gt;</code> that completes with the\nresult of running the process, i.e., exit code, standard out and\nstandard in.</p>\n<p>The following code uses <code>Process.run</code> to grep for <code>main</code> in the\nfile <code>test.dart</code> on Linux.</p>\n<pre><code>Process.run('grep', ['-i', 'main', 'test.dart']).then((result) {\n  stdout.write(result.stdout);\n  stderr.write(result.stderr);\n});\n</code></pre>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.ProcessResult","inner":[]}]}],"parameters":{"executable":{"name":"executable","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"arguments":{"name":"arguments","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]},"workingDirectory":{"name":"workingDirectory","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"environment":{"name":"environment","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]},"includeParentEnvironment":{"name":"includeParentEnvironment","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]},"runInShell":{"name":"runInShell","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]},"stdoutEncoding":{"name":"stdoutEncoding","optional":true,"named":true,"default":true,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":"ConstructedConstant(SystemEncoding())","annotations":[]},"stderrEncoding":{"name":"stderrEncoding","optional":true,"named":true,"default":true,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":"ConstructedConstant(SystemEncoding())","annotations":[]}},"annotations":[]},"runSync":{"name":"runSync","qualifiedName":"dart-io.Process.runSync","comment":"<p>Starts a process and runs it to completion. This is a synchronous\ncall and will block until the child process terminates.</p>\n<p>The arguments are the same as for <code>Process.run</code>.</p>\n<p>Returns a <code>ProcessResult</code> with the result of running the process,\ni.e., exit code, standard out and standard in.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-io.ProcessResult","inner":[]}],"parameters":{"executable":{"name":"executable","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"arguments":{"name":"arguments","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]},"workingDirectory":{"name":"workingDirectory","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"environment":{"name":"environment","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]},"includeParentEnvironment":{"name":"includeParentEnvironment","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]},"runInShell":{"name":"runInShell","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]},"stdoutEncoding":{"name":"stdoutEncoding","optional":true,"named":true,"default":true,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":"ConstructedConstant(SystemEncoding())","annotations":[]},"stderrEncoding":{"name":"stderrEncoding","optional":true,"named":true,"default":true,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":"ConstructedConstant(SystemEncoding())","annotations":[]}},"annotations":[]},"start":{"name":"start","qualifiedName":"dart-io.Process.start","comment":"<p>Starts a process running the <a>dart-io.Process.start.executable</a> with the specified\n<a>dart-io.Process.start.arguments</a>. Returns a <code>Future&lt;Process&gt;</code> that completes with a\nProcess instance when the process has been successfully\nstarted. That <a>dart-io.Process</a> object can be used to interact with the\nprocess. If the process cannot be started the returned <a>dart-async.Future</a>\ncompletes with an exception.</p>\n<p>Use <a>dart-io.Process.start.workingDirectory</a> to set the working directory for the process. Note\nthat the change of directory occurs before executing the process on some\nplatforms, which may have impact when using relative paths for the\nexecutable and the arguments.</p>\n<p>Use <a>dart-io.Process.start.environment</a> to set the environment variables for the process. If not\nset the environment of the parent process is inherited. Currently, only\nUS-ASCII environment variables are supported and errors are likely to occur\nif an environment variable with code-points outside the US-ASCII range is\npassed in.</p>\n<p>If <a>dart-io.Process.start.includeParentEnvironment</a> is <code>true</code>, the process's environment will\ninclude the parent process's environment, with <a>dart-io.Process.start.environment</a> taking\nprecedence. Default is <code>true</code>.</p>\n<p>If <a>dart-io.Process.start.runInShell</a> is true, the process will be spawned through a system\nshell. On Linux and Mac OS, <code>/bin/sh</code> is used, while\n<code>%WINDIR%\\system32\\cmd.exe</code> is used on Windows.</p>\n<p>Users must read all data coming on the <a>dart-io.Process.stdout</a> and <a>dart-io.Process.stderr</a>\nstreams of processes started with <code>Process.start</code>. If the user\ndoes not read all data on the streams the underlying system\nresources will not be freed since there is still pending data.</p>\n<p>The following code uses <code>Process.start</code> to grep for <code>main</code> in the\nfile <code>test.dart</code> on Linux.</p>\n<pre><code>Process.start('grep', ['-i', 'main', 'test.dart']).then((process) {\n  stdout.addStream(process.stdout);\n  stderr.addStream(process.stderr);\n});\n</code></pre>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.Process","inner":[]}]}],"parameters":{"executable":{"name":"executable","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"arguments":{"name":"arguments","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]},"workingDirectory":{"name":"workingDirectory","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"environment":{"name":"environment","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]},"includeParentEnvironment":{"name":"includeParentEnvironment","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]},"runInShell":{"name":"runInShell","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"dart-io.Process.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-io.Process.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-io.Process.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-io.Process.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart-io.Process.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart-io.Process.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-io.Process.noSuchMethod","comment":"<p><a>dart-io.Process.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-io.Process.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-io.Process.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-io.Process.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-io.Process.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}