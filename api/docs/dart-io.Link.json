{"name":"Link","qualifiedName":"dart-io.Link","comment":"<p><a>dart-io.Link</a> objects are references to filesystem links.</p>","isAbstract":true,"superclass":"dart-io.FileSystemEntity","implements":[],"subclass":[],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{"absolute":{"name":"absolute","qualifiedName":"dart-io.Link.absolute","comment":"<p>Returns a <a>dart-io.Link</a> instance whose path is the absolute path to this.</p>\n<p>The absolute path is computed by prefixing\na relative path with the current working directory, and returning\nan absolute path unchanged.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.Link","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"dart-io.Link.Link-","comment":"<p>Creates a Link object.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-io.Link","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"fromUri":{"name":"fromUri","qualifiedName":"dart-io.Link.Link-fromUri","comment":"<p>Create a Lint object from a URI.</p>\n<p>If <a>dart-io.Link.Link-fromUri.uri</a> cannot reference a link this throws <a>dart-core.UnsupportedError</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-io.Link","inner":[]}],"parameters":{"uri":{"name":"uri","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{"create":{"name":"create","qualifiedName":"dart-io.Link.create","comment":"<p>Creates a symbolic link. Returns a <code>Future&lt;Link&gt;</code> that completes with\nthe link when it has been created. If the link exists,\nthe future will complete with an error.</p>\n<p>If <a>dart-io.Link.create.recursive</a> is false, the default, the link is created\nonly if all directories in its path exist.\nIf <a>dart-io.Link.create.recursive</a> is true, all non-existing path\ncomponents are created. The directories in the path of <a>dart-io.Link.create.target</a> are\nnot affected, unless they are also in <a>dart-io.Link.path</a>.</p>\n<p>On the Windows platform, this will only work with directories, and the\ntarget directory must exist. The link will be created as a Junction.\nOnly absolute links will be created, and relative paths to the target\nwill be converted to absolute paths by joining them with the path of the\ndirectory the link is contained in.</p>\n<p>On other platforms, the posix symlink() call is used to make a symbolic\nlink containing the string <a>dart-io.Link.create.target</a>.  If <a>dart-io.Link.create.target</a> is a relative path,\nit will be interpreted relative to the directory containing the link.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.Link","inner":[]}]}],"parameters":{"target":{"name":"target","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"createSync":{"name":"createSync","qualifiedName":"dart-io.Link.createSync","comment":"<p>Synchronously create the link. Calling <a>dart-io.Link.createSync</a> on an existing link\nwill throw an exception.</p>\n<p>If <a>dart-io.Link.createSync.recursive</a> is false, the default, the link is created only if all\ndirectories in its path exist. If <a>dart-io.Link.createSync.recursive</a> is true, all\nnon-existing path components are created. The directories in\nthe path of <a>dart-io.Link.createSync.target</a> are not affected, unless they are also in <a>dart-io.Link.path</a>.</p>\n<p>On the Windows platform, this will only work with directories, and the\ntarget directory must exist. The link will be created as a Junction.\nOnly absolute links will be created, and relative paths to the target\nwill be converted to absolute paths.</p>\n<p>On other platforms, the posix symlink() call is used to make a symbolic\nlink containing the string <a>dart-io.Link.createSync.target</a>.  If <a>dart-io.Link.createSync.target</a> is a relative path,\nit will be interpreted relative to the directory containing the link.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"target":{"name":"target","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"rename":{"name":"rename","qualifiedName":"dart-io.Link.rename","comment":"<p>Renames this link. Returns a <code>Future&lt;Link&gt;</code> that completes\nwith a <a>dart-io.Link</a> instance for the renamed link.</p>\n<p>If <a>dart-io.Link.rename.newPath</a> identifies an existing link, that link is\nreplaced. If <a>dart-io.Link.rename.newPath</a> identifies an existing file or directory,\nthe operation fails and the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.Link","inner":[]}]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"renameSync":{"name":"renameSync","qualifiedName":"dart-io.Link.renameSync","comment":"<p>Synchronously renames this link. Returns a <a>dart-io.Link</a>\ninstance for the renamed link.</p>\n<p>If <a>dart-io.Link.renameSync.newPath</a> identifies an existing link, that link is\nreplaced. If <a>dart-io.Link.renameSync.newPath</a> identifies an existing file or directory\nthe operation fails and an exception is thrown.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.Link","inner":[]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"resolveSymbolicLinks":{"name":"resolveSymbolicLinks","qualifiedName":"dart-io.Link.resolveSymbolicLinks","comment":"<p>Resolves the path of a file system object relative to the\ncurrent working directory, resolving all symbolic links on\nthe path and resolving all '..' and '.' path segments.\n<a>dart-io.Link.resolveSymbolicLinks</a> returns a <code>Future&lt;String&gt;</code></p>\n<p><a>dart-io.Link.resolveSymbolicLinks</a> uses the operating system's native filesystem api\nto resolve the path, using the realpath function on linux and\nMac OS, and the GetFinalPathNameByHandle function on Windows.\nIf the path does not point to an existing file system object,\n<a>dart-io.Link.resolveSymbolicLinks</a> completes the returned Future with an FileSystemException.</p>\n<p>On Windows, symbolic links are resolved to their target before applying\na '..' that follows, and on other platforms, the '..' is applied to the\nsymbolic link without resolving it.  The second behavior can be emulated\non Windows by processing any '..' segments before calling\n<a>dart-io.Link.resolveSymbolicLinks</a>.  One way of doing this is with the URI class:\n:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();,\nsince resolve removes '..' segments.</p>","commentFrom":"dart-io.FileSystemEntity.resolveSymbolicLinks","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{},"annotations":[]},"resolveSymbolicLinksSync":{"name":"resolveSymbolicLinksSync","qualifiedName":"dart-io.Link.resolveSymbolicLinksSync","comment":"<p>Resolves the path of a file system object relative to the\ncurrent working directory, resolving all symbolic links on\nthe path and resolving all '..' and '.' path segments.</p>\n<p><a>dart-io.Link.resolveSymbolicLinksSync</a> uses the operating system's native\nfilesystem api to resolve the path, using the realpath function\non linux and Mac OS, and the GetFinalPathNameByHandle function on Windows.\nIf the path does not point to an existing file system object,\n<a>dart-io.Link.resolveSymbolicLinksSync</a> throws a FileSystemException.</p>\n<p>On Windows, symbolic links are resolved to their target before applying\na '..' that follows, and on other platforms, the '..' is applied to the\nsymbolic link without resolving it.  The second behavior can be emulated\non Windows by processing any '..' segments before calling\n<a>dart-io.Link.resolveSymbolicLinks</a>.  One way of doing this is with the URI class:\n:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();,\nsince resolve removes '..' segments.</p>","commentFrom":"dart-io.FileSystemEntity.resolveSymbolicLinksSync","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"target":{"name":"target","qualifiedName":"dart-io.Link.target","comment":"<p>Gets the target of the link. Returns a future that completes with\nthe path to the target.</p>\n<p>If the returned target is a relative path, it is relative to the\ndirectory containing the link.</p>\n<p>If the link does not exist, or is not a link, the future completes with\na FileSystemException.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{},"annotations":[]},"targetSync":{"name":"targetSync","qualifiedName":"dart-io.Link.targetSync","comment":"<p>Synchronously gets the target of the link. Returns the path to the target.</p>\n<p>If the returned target is a relative path, it is relative to the\ndirectory containing the link.</p>\n<p>If the link does not exist, or is not a link, throws a FileSystemException.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"update":{"name":"update","qualifiedName":"dart-io.Link.update","comment":"<p>Updates the link. Returns a <code>Future&lt;Link&gt;</code> that completes with the\nlink when it has been updated.  Calling <a>dart-io.Link.update</a> on a non-existing link\nwill complete its returned future with an exception.</p>\n<p>On the Windows platform, this will only work with directories, and the\ntarget directory must exist.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.Link","inner":[]}]}],"parameters":{"target":{"name":"target","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"updateSync":{"name":"updateSync","qualifiedName":"dart-io.Link.updateSync","comment":"<p>Synchronously updates the link. Calling <a>dart-io.Link.updateSync</a> on a non-existing link\nwill throw an exception.</p>\n<p>On the Windows platform, this will only work with directories, and the\ntarget directory must exist.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"target":{"name":"target","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"absolute":{"name":"absolute","qualifiedName":"dart-io.Link.absolute","comment":"<p>Returns a <a>dart-io.FileSystemEntity</a> whose path is the absolute path to this.\nThe type of the returned instance is the type of this.</p>\n<p>The absolute path is computed by prefixing\na relative path with the current working directory, and returning\nan absolute path unchanged.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.absolute","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.FileSystemEntity","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"dart-io.Link.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-io.Link.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"isAbsolute":{"name":"isAbsolute","qualifiedName":"dart-io.Link.isAbsolute","comment":"<p>Returns a <a>dart-core.bool</a> indicating whether this object's path is absolute.</p>\n<p>On Windows, a path is absolute if it starts with \\\\ or a drive letter\nbetween a and z (upper or lower case) followed by :\\ or :/.\nOn non-Windows, a path is absolute if it starts with /.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.isAbsolute","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"parent":{"name":"parent","qualifiedName":"dart-io.Link.parent","comment":"<p>The directory containing this.  If this is a root\ndirectory, returns this.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.parent","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-io.Directory","inner":[]}],"parameters":{},"annotations":[]},"path":{"name":"path","qualifiedName":"dart-io.Link.path","comment":"","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.path","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-io.Link.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-io.Link.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart-io.Link.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart-io.Link.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"delete":{"name":"delete","qualifiedName":"dart-io.Link.delete","comment":"<p>Deletes this <a>dart-io.FileSystemEntity</a>.</p>\n<p>If the <a>dart-io.FileSystemEntity</a> is a directory, and if <a>dart-io.Link.delete.recursive</a> is false,\nthe directory must be empty. Otherwise, if <a>dart-io.Link.delete.recursive</a> is true, the\ndirectory and all sub-directories and files in the directories are\ndeleted. Links are not followed when deleting recursively. Only the link\nis deleted, not its target.</p>\n<p>If <a>dart-io.Link.delete.recursive</a> is true, the <a>dart-io.FileSystemEntity</a> is deleted even if the type\nof the <a>dart-io.FileSystemEntity</a> doesn't match the content of the file system.\nThis behavior allows <a>dart-io.Link.delete</a> to be used to unconditionally delete any file\nsystem object.</p>\n<p>Returns a <code>Future&lt;FileSystemEntity&gt;</code> that completes with this\n<a>dart-io.FileSystemEntity</a> when the deletion is done. If the <a>dart-io.FileSystemEntity</a>\ncannot be deleted, the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.delete","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileSystemEntity","inner":[]}]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"deleteSync":{"name":"deleteSync","qualifiedName":"dart-io.Link.deleteSync","comment":"<p>Synchronously deletes this <a>dart-io.FileSystemEntity</a>.</p>\n<p>If the <a>dart-io.FileSystemEntity</a> is a directory, and if <a>dart-io.Link.deleteSync.recursive</a> is false,\nthe directory must be empty. Otherwise, if <a>dart-io.Link.deleteSync.recursive</a> is true, the\ndirectory and all sub-directories and files in the directories are\ndeleted. Links are not followed when deleting recursively. Only the link\nis deleted, not its target.</p>\n<p>If <a>dart-io.Link.deleteSync.recursive</a> is true, the <a>dart-io.FileSystemEntity</a> is deleted even if the type\nof the <a>dart-io.FileSystemEntity</a> doesn't match the content of the file system.\nThis behavior allows <a>dart-io.Link.deleteSync</a> to be used to unconditionally delete any\nfile system object.</p>\n<p>Throws an exception if the <a>dart-io.FileSystemEntity</a> cannot be deleted.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.deleteSync","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"exists":{"name":"exists","qualifiedName":"dart-io.Link.exists","comment":"<p>Checks whether the file system entity with this path exists. Returns\na <code>Future&lt;bool&gt;</code> that completes with the result.</p>\n<p>Since FileSystemEntity is abstract, every FileSystemEntity object\nis actually an instance of one of the subclasses <a>dart-io.File</a>,\n<a>dart-io.Directory</a>, and <a>dart-io.Link</a>.  Calling <a>dart-io.Link.exists</a> on an instance of one\nof these subclasses checks whether the object exists in the file\nsystem object exists and is of the correct type (file, directory,\nor link).  To check whether a path points to an object on the\nfile system, regardless of the object's type, use the <a>dart-io.FileSystemEntity.type</a>\nstatic method.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.exists","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.bool","inner":[]}]}],"parameters":{},"annotations":[]},"existsSync":{"name":"existsSync","qualifiedName":"dart-io.Link.existsSync","comment":"<p>Synchronously checks whether the file system entity with this path\nexists.</p>\n<p>Since FileSystemEntity is abstract, every FileSystemEntity object\nis actually an instance of one of the subclasses <a>dart-io.File</a>,\n<a>dart-io.Directory</a>, and <a>dart-io.Link</a>.  Calling <a>dart-io.Link.existsSync</a> on an instance of\none of these subclasses checks whether the object exists in the\nfile system object exists and is of the correct type (file,\ndirectory, or link).  To check whether a path points to an object\non the file system, regardless of the object's type, use the\n<a>dart-io.FileSystemEntity.typeSync</a> static method.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.existsSync","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-io.Link.noSuchMethod","comment":"<p><a>dart-io.Link.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-io.Link.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-io.Link.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-io.Link.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"rename":{"name":"rename","qualifiedName":"dart-io.Link.rename","comment":"<p>Renames this file system entity. Returns a <code>Future&lt;FileSystemEntity&gt;</code>\nthat completes with a <a>dart-io.FileSystemEntity</a> instance for the renamed\nfile system entity.</p>\n<p>If <a>dart-io.Link.rename.newPath</a> identifies an existing entity of the same type, that entity\nis replaced. If <a>dart-io.Link.rename.newPath</a> identifies an existing entity of a different\ntype, the operation fails and the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.rename","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileSystemEntity","inner":[]}]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"renameSync":{"name":"renameSync","qualifiedName":"dart-io.Link.renameSync","comment":"<p>Synchronously renames this file system entity. Returns a <a>dart-io.FileSystemEntity</a>\ninstance for the renamed entity.</p>\n<p>If <a>dart-io.Link.renameSync.newPath</a> identifies an existing entity of the same type, that entity\nis replaced. If <a>dart-io.Link.renameSync.newPath</a> identifies an existing entity of a different\ntype, the operation fails and an exception is thrown.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.renameSync","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.FileSystemEntity","inner":[]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"resolveSymbolicLinks":{"name":"resolveSymbolicLinks","qualifiedName":"dart-io.Link.resolveSymbolicLinks","comment":"<p>Resolves the path of a file system object relative to the\ncurrent working directory, resolving all symbolic links on\nthe path and resolving all '..' and '.' path segments.\n<a>dart-io.Link.resolveSymbolicLinks</a> returns a <code>Future&lt;String&gt;</code></p>\n<p><a>dart-io.Link.resolveSymbolicLinks</a> uses the operating system's native filesystem api\nto resolve the path, using the realpath function on linux and\nMac OS, and the GetFinalPathNameByHandle function on Windows.\nIf the path does not point to an existing file system object,\n<a>dart-io.Link.resolveSymbolicLinks</a> completes the returned Future with an FileSystemException.</p>\n<p>On Windows, symbolic links are resolved to their target before applying\na '..' that follows, and on other platforms, the '..' is applied to the\nsymbolic link without resolving it.  The second behavior can be emulated\non Windows by processing any '..' segments before calling\n<a>dart-io.Link.resolveSymbolicLinks</a>.  One way of doing this is with the URI class:\n:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();,\nsince resolve removes '..' segments.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.resolveSymbolicLinks","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{},"annotations":[]},"resolveSymbolicLinksSync":{"name":"resolveSymbolicLinksSync","qualifiedName":"dart-io.Link.resolveSymbolicLinksSync","comment":"<p>Resolves the path of a file system object relative to the\ncurrent working directory, resolving all symbolic links on\nthe path and resolving all '..' and '.' path segments.</p>\n<p><a>dart-io.Link.resolveSymbolicLinksSync</a> uses the operating system's native\nfilesystem api to resolve the path, using the realpath function\non linux and Mac OS, and the GetFinalPathNameByHandle function on Windows.\nIf the path does not point to an existing file system object,\n<a>dart-io.Link.resolveSymbolicLinksSync</a> throws a FileSystemException.</p>\n<p>On Windows, symbolic links are resolved to their target before applying\na '..' that follows, and on other platforms, the '..' is applied to the\nsymbolic link without resolving it.  The second behavior can be emulated\non Windows by processing any '..' segments before calling\n<a>dart-io.Link.resolveSymbolicLinks</a>.  One way of doing this is with the URI class:\n:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();,\nsince resolve removes '..' segments.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.resolveSymbolicLinksSync","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"stat":{"name":"stat","qualifiedName":"dart-io.Link.stat","comment":"<p>Calls the operating system's stat() function on the <a>dart-io.Link.path</a> of this\n<a>dart-io.FileSystemEntity</a>.  Identical to <code>FileStat.stat(this.path)</code>.</p>\n<p>Returns a <code>Future&lt;FileStat&gt;</code> object containing the data returned by\nstat().</p>\n<p>If the call fails, completes the future with a <a>dart-io.FileStat</a> object\nwith .type set to\nFileSystemEntityType.NOT_FOUND and the other fields invalid.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.stat","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileStat","inner":[]}]}],"parameters":{},"annotations":[]},"statSync":{"name":"statSync","qualifiedName":"dart-io.Link.statSync","comment":"<p>Synchronously calls the operating system's stat() function on the\n<a>dart-io.Link.path</a> of this <a>dart-io.FileSystemEntity</a>.\nIdentical to <code>FileStat.statSync(this.path)</code>.</p>\n<p>Returns a <a>dart-io.FileStat</a> object containing the data returned by stat().</p>\n<p>If the call fails, returns a <a>dart-io.FileStat</a> object with .type set to\nFileSystemEntityType.NOT_FOUND and the other fields invalid.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.statSync","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.FileStat","inner":[]}],"parameters":{},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-io.Link.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"watch":{"name":"watch","qualifiedName":"dart-io.Link.watch","comment":"<p>Start watching the <a>dart-io.FileSystemEntity</a> for changes.</p>\n<p>The implementation uses platform-dependent event-based APIs for receiving\nfile-system notifications, thus behavior depends on the platform.</p><ul><li>\n<p><code>Windows</code>: Uses <code>ReadDirectoryChangesW</code>. The implementation only\nsupports watching directories. Recursive watching is supported.</p></li><li>\n<p><code>Linux</code>: Uses <code>inotify</code>. The implementation supports watching both\nfiles and directories. Recursive watching is not supported.\nNote: When watching files directly, delete events might not happen\nas expected.</p></li><li>\n<p><code>Mac OS</code>: Uses <code>FSEvents</code>. The implementation supports watching both\nfiles and directories. Recursive watching is supported.</p></li></ul>\n<p>The system will start listening for events once the returned <a>dart-async.Stream</a> is\nbeing listened to, not when the call to <a>dart-io.Link.watch</a> is issued.</p>\n<p>The returned value is an endless broadcast <a>dart-async.Stream</a>, that only stops when\none of the following happends:</p><ul><li>\n<p>The <a>dart-async.Stream</a> is canceled, e.g. by calling <code>cancel</code> on the\n <a>dart-async.StreamSubscription</a>.</p></li><li>The <a>dart-io.FileSystemEntity</a> being watches, is deleted.</li></ul>\n<p>Use <code>events</code> to specify what events to listen for. The constants in\n<a>dart-io.FileSystemEvent</a> can be or'ed together to mix events. Default is\n<a>dart-io.FileSystemEvent.ALL</a>.</p>","commentFrom":"","inheritedFrom":"dart-io.FileSystemEntity.watch","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-io.FileSystemEvent","inner":[]}]}],"parameters":{"events":{"name":"events","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"15","annotations":[]},"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]}}},"annotations":[],"generics":{}}