{"name":"String","qualifiedName":"dart-core.String","comment":"<p>A sequence of characters.</p>\n<p>A string can be either single or multiline. Single line strings are\nwritten using matching single or double quotes, and multiline strings are\nwritten using triple quotes. The following are all valid Dart strings:</p>\n<pre><code>'Single quotes';\n\"Double quotes\";\n'Double quotes in \"single\" quotes';\n\"Single quotes in 'double' quotes\";\n\n'''A\nmultiline\nstring''';\n\n\"\"\"\nAnother\nmultiline\nstring\"\"\";\n</code></pre>\n<p>Strings are immutable. Although you cannot change a string, you can perform\nan operation on a string and assign the result to a new string:</p>\n<pre><code>var string = 'Dart is fun';\nvar newString = string.substring(0, 5);\n</code></pre>\n<p>You can use the plus (<code>+</code>) operator to concatenate strings:</p>\n<pre><code>'Dart ' + 'is ' + 'fun!'; // 'Dart is fun!'\n</code></pre>\n<p>You can also use adjacent string literals for concatenation:</p>\n<pre><code>'Dart ' 'is ' 'fun!';    // 'Dart is fun!'\n</code></pre>\n<p>You can use <code>${}</code> to interpolate the value of Dart expressions\nwithin strings. The curly braces can be omitted when evaluating identifiers:</p>\n<pre><code>string = 'dartlang';\n'$string has ${string.length} letters'; // 'dartlang has 8 letters'\n</code></pre>\n<p>A string is represented by a sequence of Unicode UTF-16 code units\naccessible through the <a>dart-core.String.codeUnitAt</a> or the <a>dart-core.String.codeUnits</a> members:</p>\n<pre><code>string = 'Dart';\nstring.codeUnitAt(0); // 68\nstring.codeUnits;     // [68, 97, 114, 116]\n</code></pre>\n<p>The string representation of code units is accessible through the index\noperator:</p>\n<pre><code>string[0];            // 'D'\n</code></pre>\n<p>The characters of a string are encoded in UTF-16. Decoding UTF-16, which\ncombines surrogate pairs, yields Unicode code points. Following a similar\nterminology to Go, we use the name 'rune' for an integer representing a\nUnicode code point. Use the <a>dart-core.String.runes</a> property to get the runes of a string:</p>\n<pre><code>string.runes.toList(); // [68, 97, 114, 116]\n</code></pre>\n<p>For a character outside the Basic Multilingual Plane (plane 0) that is\ncomposed of a surrogate pair, <a>dart-core.String.runes</a> combines the pair and returns a\nsingle integer.  For example, the Unicode character for a\nmusical G-clef ('ùÑû') with rune value 0x1D11E consists of a UTF-16 surrogate\npair: <code>0xD834</code> and <code>0xDD1E</code>. Using <a>dart-core.String.codeUnits</a> returns the surrogate pair,\nand using <code>runes</code> returns their combined value:</p>\n<pre><code>var clef = '\\u{1D11E}';\nclef.codeUnits;         // [0xD834, 0xDD1E]\nclef.runes.toList();    // [0x1D11E]\n</code></pre>\n<p>The String class can not be extended or implemented. Attempting to do so\nyields a compile-time error.</p>\n<h2>Other resources</h2>\n<p>See <a>dart-core.StringBuffer</a> to efficiently build a string incrementally. See\n<a>dart-core.RegExp</a> to work with regular expressions.</p>\n<p>Also see:</p><ul><li>\n<p><a href=\"https://www.dartlang.org/docs/cookbook/#strings\">Dart Cookbook</a>\nfor String examples and recipes.</p></li><li>\n<p><a href=\"https://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-strings-and-regular-expressions\">Dart Up and Running</a></p></li></ul>","isAbstract":true,"superclass":"dart-core.Object","implements":["dart-core.Pattern","dart-core.Comparable"],"subclass":[],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{"codeUnits":{"name":"codeUnits","qualifiedName":"dart-core.String.codeUnits","comment":"<p>Returns an unmodifiable list of the UTF-16 code units of this string.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}],"parameters":{},"annotations":[]},"isEmpty":{"name":"isEmpty","qualifiedName":"dart-core.String.isEmpty","comment":"<p>Returns true if this string is empty.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isNotEmpty":{"name":"isNotEmpty","qualifiedName":"dart-core.String.isNotEmpty","comment":"<p>Returns true if this string is not empty.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"length":{"name":"length","qualifiedName":"dart-core.String.length","comment":"<p>The length of the string.</p>\n<p>Returns the number of UTF-16 code units in this string. The number\nof <a>dart-core.String.runes</a> might be fewer, if the string contains characters outside\nthe Basic Multilingual Plane (plane 0):</p>\n<pre><code>'Dart'.length;          // 4\n'Dart'.runes.length;    // 4\n\nvar clef = '\\u{1D11E}';\nclef.length;            // 2\nclef.runes.length;      // 1\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runes":{"name":"runes","qualifiedName":"dart-core.String.runes","comment":"<p>Returns an <a>dart-core.Iterable</a> of Unicode code-points of this string.</p>\n<p>If the string contains surrogate pairs, they are combined and returned\nas one integer by this iterator. Unmatched surrogate halves are treated\nlike valid 16-bit code-units.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Runes","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{"fromCharCode":{"name":"fromCharCode","qualifiedName":"dart-core.String.String-fromCharCode","comment":"<p>Allocates a new String for the specified <a>dart-core.String.String-fromCharCode.charCode</a>.</p>\n<p>If the <a>dart-core.String.String-fromCharCode.charCode</a> can be represented by a single UTF-16 code unit, the new\nstring contains a single code unit. Otherwise, the <a>dart-core.String.length</a> is 2 and\nthe code units form a surrogate pair. See documentation for\nfromCharCodes.</p>\n<p>Creating a String with half of a surrogate pair is allowed.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"charCode":{"name":"charCode","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"fromCharCodes":{"name":"fromCharCodes","qualifiedName":"dart-core.String.String-fromCharCodes","comment":"<p>Allocates a new String for the specified <a>dart-core.String.String-fromCharCodes.charCodes</a>.</p>\n<p>The <a>dart-core.String.String-fromCharCodes.charCodes</a> can be UTF-16 code units or runes. If a char-code value is\n16-bit, it is copied verbatim:</p>\n<pre><code>new String.fromCharCodes([68]); // 'D'\n</code></pre>\n<p>If a char-code value is greater than 16-bits, it is decomposed into a\nsurrogate pair:</p>\n<pre><code>var clef = new String.fromCharCodes([0x1D11E]);\nclef.codeUnitAt(0); // 0xD834\nclef.codeUnitAt(1); // 0xDD1E\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"charCodes":{"name":"charCodes","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.int","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"fromEnvironment":{"name":"fromEnvironment","qualifiedName":"dart-core.String.String-fromEnvironment","comment":"<p>Returns the string value of the environment declaration <a>dart-core.String.String-fromEnvironment.name</a>.</p>\n<p>Environment declarations are provided by the surrounding system compiling\nor running the Dart program. Declarations map a string key to a string\nvalue.</p>\n<p>If <a>dart-core.String.String-fromEnvironment.name</a> is not declared in the environment, the result is instead\n<a>dart-core.String.String-fromEnvironment.defaultValue</a>.</p>\n<p>Example of getting a value:</p>\n<pre><code>const String.fromEnvironment(\"defaultFloo\", defaultValue: \"no floo\")\n</code></pre>\n<p>Example of checking whether a declaration is there at all:</p>\n<pre><code>var isDeclared = const String.fromEnvironment(\"maybeDeclared\") != null;\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"defaultValue":{"name":"defaultValue","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{"*":{"name":"*","qualifiedName":"dart-core.String.*","comment":"<p>Creates a new string by concatenating this string with itself a number\nof times.</p>\n<p>The result of <code>str * n</code> is equivalent to\n<code>str + str + ...</code>(n times)<code>... + str</code>.</p>\n<p>Returns an empty string if <a>dart-core.String.*.times</a> is zero or negative.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"times":{"name":"times","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"+":{"name":"+","qualifiedName":"dart-core.String.+","comment":"<p>Creates a new string by concatenating this string with <a>dart-core.String.+.other</a>.</p>\n<pre><code>'dart' + 'lang'; // 'dartlang'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"==":{"name":"==","qualifiedName":"dart-core.String.==","comment":"<p>Returns true if the two strings are equal. False, otherwise.</p>\n<p>This method compares each individual code unit of the strings.\nIt does not check for Unicode equivalence.\nFor example, both the following strings represent the string 'Am√©lie',\nbut due to their different encoding, are not equal:</p>\n<pre><code>'Am\\xe9lie' == 'Ame\\u{301}lie'; // false\n</code></pre>\n<p>The first string encodes '√©' as a single unicode code unit (also\na single rune), whereas the second string encodes it as 'e' with the\ncombining accent character '‚óåÃÅ'.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"[]":{"name":"[]","qualifiedName":"dart-core.String.[]","comment":"<p>Gets the character (as a single-code-unit <a>dart-core.String</a>) at the given <a>dart-core.String.[].index</a>.</p>\n<p>The returned string represents exactly one UTF-16 code unit, which may be\nhalf of a surrogate pair. A single member of a surrogate pair is an\ninvalid UTF-16 string:</p>\n<pre><code>var clef = '\\u{1D11E}';\n// These represent invalid UTF-16 strings.\nclef[0].codeUnits;      // [0xD834]\nclef[1].codeUnits;      // [0xDD1E]\n</code></pre>\n<p>This method is equivalent to\n<code>new String.fromCharCode(this.codeUnitAt(index))</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"index":{"name":"index","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"codeUnitAt":{"name":"codeUnitAt","qualifiedName":"dart-core.String.codeUnitAt","comment":"<p>Returns the 16-bit UTF-16 code unit at the given <a>dart-core.String.codeUnitAt.index</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"index":{"name":"index","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"contains":{"name":"contains","qualifiedName":"dart-core.String.contains","comment":"<p>Returns true if this string contains a match of <a>dart-core.String.contains.other</a>:</p>\n<pre><code>var string = 'Dart strings';\nstring.contains('D');                     // true\nstring.contains(new RegExp(r'[A-Z]'));    // true\n</code></pre>\n<p>If <a>dart-core.String.contains.startIndex</a> is provided, this method matches only at or after that\nindex:</p>\n<pre><code>string.contains('X', 1);                  // false\nstring.contains(new RegExp(r'[A-Z]'), 1); // false\n</code></pre>\n<p><a>dart-core.String.contains.startIndex</a> must not be negative or greater than <a>dart-core.String.length</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Pattern","inner":[]}],"value":null,"annotations":[]},"startIndex":{"name":"startIndex","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]}},"annotations":[]},"endsWith":{"name":"endsWith","qualifiedName":"dart-core.String.endsWith","comment":"<p>Returns true if this string ends with <a>dart-core.String.endsWith.other</a>. For example:</p>\n<pre><code>'Dart'.endsWith('t'); // true\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"indexOf":{"name":"indexOf","qualifiedName":"dart-core.String.indexOf","comment":"<p>Returns the position of the first match of <a>dart-core.String.indexOf.pattern</a> in this string,\nstarting at <a>dart-core.String.indexOf.start</a>, inclusive:</p>\n<pre><code>var string = 'Dartisans';\nstring.indexOf('art');                     // 1\nstring.indexOf(new RegExp(r'[A-Z][a-z]')); // 0\n</code></pre>\n<p>Returns -1 if no match is found:</p>\n<pre><code>string.indexOf(new RegExp(r'dart'));       // -1\n</code></pre>\n<p><a>dart-core.String.indexOf.start</a> must not be negative or greater than <a>dart-core.String.length</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"pattern":{"name":"pattern","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Pattern","inner":[]}],"value":null,"annotations":[]},"start":{"name":"start","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"lastIndexOf":{"name":"lastIndexOf","qualifiedName":"dart-core.String.lastIndexOf","comment":"<p>Returns the position of the last match <a>dart-core.String.lastIndexOf.pattern</a> in this string, searching\nbackward starting at <a>dart-core.String.lastIndexOf.start</a>, inclusive:</p>\n<pre><code>var string = 'Dartisans';\nstring.lastIndexOf('a');                    // 6\nstring.lastIndexOf(new RegExp(r'a(r|n)'));  // 6\n</code></pre>\n<p>Returns -1 if other could not be found.</p>\n<pre><code>string.lastIndexOf(new RegExp(r'DART'));    // -1\n</code></pre>\n<p><a>dart-core.String.lastIndexOf.start</a> must not be negative or greater than <a>dart-core.String.length</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"pattern":{"name":"pattern","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Pattern","inner":[]}],"value":null,"annotations":[]},"start":{"name":"start","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"padLeft":{"name":"padLeft","qualifiedName":"dart-core.String.padLeft","comment":"<p>Pads this string on the left if it is shorther than <a>dart-core.String.padLeft.width</a>.</p>\n<p>Return a new string that prepends <a>dart-core.String.padLeft.padding</a> onto this string\none time for each position the length is less than <a>dart-core.String.padLeft.width</a>.</p>\n<p>If <a>dart-core.String.padLeft.width</a> is already smaller than or equal to <code>this.length</code>,\nno padding is added. A negative <code>width</code> is treated as zero.</p>\n<p>If <a>dart-core.String.padLeft.padding</a> has length different from 1, the result will not\nhave length <code>width</code>. This may be useful for cases where the\npadding is a longer string representing a single character, like\n<code>\"&amp;nbsp;\"</code> or <code>\"\\u{10002}</code>\".\nIn that case, the user should make sure that <code>this.length</code> is\nthe correct measure of the strings length.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"width":{"name":"width","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"padding":{"name":"padding","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.String","inner":[]}],"value":"\" \"","annotations":[]}},"annotations":[]},"padRight":{"name":"padRight","qualifiedName":"dart-core.String.padRight","comment":"<p>Pads this string on the right if it is shorther than <a>dart-core.String.padRight.width</a>.</p>\n<p>Return a new string that appends <a>dart-core.String.padRight.padding</a> after this string\none time for each position the length is less than <a>dart-core.String.padRight.width</a>.</p>\n<p>If <a>dart-core.String.padRight.width</a> is already smaller than or equal to <code>this.length</code>,\nno padding is added. A negative <code>width</code> is treated as zero.</p>\n<p>If <a>dart-core.String.padRight.padding</a> has length different from 1, the result will not\nhave length <code>width</code>. This may be useful for cases where the\npadding is a longer string representing a single character, like\n<code>\"&amp;nbsp;\"</code> or <code>\"\\u{10002}</code>\".\nIn that case, the user should make sure that <code>this.length</code> is\nthe correct measure of the strings length.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"width":{"name":"width","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"padding":{"name":"padding","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.String","inner":[]}],"value":"\" \"","annotations":[]}},"annotations":[]},"replaceAll":{"name":"replaceAll","qualifiedName":"dart-core.String.replaceAll","comment":"<p>Replaces all substrings that match <a>dart-core.String.replaceAll.from</a> with <a>dart-core.String.replaceAll.replace</a>.</p>\n<p>Returns a new string in which the non-overlapping substrings matching\n<a>dart-core.String.replaceAll.from</a> (the ones iterated by <code>from.allMatches(thisString)</code>) are replaced\nby the literal string <a>dart-core.String.replaceAll.replace</a>.</p>\n<pre><code>'resume'.replaceAll(new RegExp(r'e'), '√©'); // 'r√©sum√©'\n</code></pre>\n<p>Notice that the <a>dart-core.String.replaceAll.replace</a> string is not interpreted. If the replacement\ndepends on the match (for example on a <a>dart-core.RegExp</a>'s capture groups), use\nthe <a>dart-core.String.replaceAllMapped</a> method instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"from":{"name":"from","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Pattern","inner":[]}],"value":null,"annotations":[]},"replace":{"name":"replace","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"replaceAllMapped":{"name":"replaceAllMapped","qualifiedName":"dart-core.String.replaceAllMapped","comment":"<p>Replace all substrings that match <a>dart-core.String.replaceAllMapped.from</a> by a string computed from the\nmatch.</p>\n<p>Returns a new string in which the non-overlapping substrings that match\n<a>dart-core.String.replaceAllMapped.from</a> (the ones iterated by <code>from.allMatches(thisString)</code>) are replaced\nby the result of calling <a>dart-core.String.replaceAllMapped.replace</a> on the corresponding <a>dart-core.Match</a> object.</p>\n<p>This can be used to replace matches with new content that depends on the\nmatch, unlike <a>dart-core.String.replaceAll</a> where the replacement string is always the same.</p>\n<p>The <a>dart-core.String.replaceAllMapped.replace</a> function is called with the <a>dart-core.Match</a> generated\nby the pattern, and its result is used as replacement.</p>\n<p>The function defined below converts each word in a string to simplified\n'pig latin' using <a>dart-core.String.replaceAllMapped</a>:</p>\n<pre><code>pigLatin(String words) =&gt; words.replaceAllMapped(\n    new RegExp(r'\\b(\\w*?)([aeiou]\\w*)', caseSensitive: false),\n    (Match m) =&gt; \"${m[2]}${m[1]}${m[1].isEmpty ? 'way' : 'ay'}\");\n\npigLatin('I have a secret now!'); // 'Iway avehay away ecretsay ownay!'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"from":{"name":"from","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Pattern","inner":[]}],"value":null,"annotations":[]},"replace":{"name":"replace","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"match":{"name":"match","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Match","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"replaceFirst":{"name":"replaceFirst","qualifiedName":"dart-core.String.replaceFirst","comment":"<p>Returns a new string in which  the first occurence of <a>dart-core.String.replaceFirst.from</a> in this string\nis replaced with <a>dart-core.String.replaceFirst.to</a>:</p>\n<pre><code>'0.0001'.replaceFirst(new RegExp(r'0'), ''); // '.0001'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"from":{"name":"from","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Pattern","inner":[]}],"value":null,"annotations":[]},"to":{"name":"to","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"split":{"name":"split","qualifiedName":"dart-core.String.split","comment":"<p>Splits the string at matches of <a>dart-core.String.split.pattern</a>. Returns\na list of substrings.</p>\n<p>Splitting with an empty string pattern (<code>''</code>) splits at UTF-16 code unit\nboundaries and not at rune boundaries:</p>\n<pre><code>var string = 'Pub';\nstring.split('');                       // ['P', 'u', 'b']\n\nstring.codeUnits.map((unit) {\n  return new String.fromCharCode(unit);\n}).toList();                            // ['P', 'u', 'b']\n\n// String made up of two code units, but one rune.\nstring = '\\u{1D11E}';\nstring.split('').length;                 // 2\n</code></pre>\n<p>You should map the runes unless you are certain that the string is in\nthe basic multilingual plane (meaning that each code unit represents a\nrune):</p>\n<pre><code>string.runes.map((rune) =&gt; new String.fromCharCode(rune));\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{"pattern":{"name":"pattern","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Pattern","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"splitMapJoin":{"name":"splitMapJoin","qualifiedName":"dart-core.String.splitMapJoin","comment":"<p>Splits the string, converts its parts, and combines them into a new\nstring.</p>\n<p><a>dart-core.String.splitMapJoin.pattern</a> is used to split the string into parts and separating matches.</p>\n<p>Each match is converted to a string by calling <a>dart-core.String.splitMapJoin.onMatch</a>. If <a>dart-core.String.splitMapJoin.onMatch</a>\nis omitted, the matched string is used.</p>\n<p>Each non-matched part is converted by a call to <a>dart-core.String.splitMapJoin.onNonMatch</a>. If\n<a>dart-core.String.splitMapJoin.onNonMatch</a> is omitted, the non-matching part is used.</p>\n<p>Then all the converted parts are combined into the resulting string.</p>\n<pre><code>'Eats shoots leaves'.splitMapJoin((new RegExp(r'shoots')),\n    onMatch:    (m) =&gt; '${m.group(0)}',\n    onNonMatch: (n) =&gt; '*'); // *shoots*\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"pattern":{"name":"pattern","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Pattern","inner":[]}],"value":null,"annotations":[]},"onMatch":{"name":"onMatch","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"match":{"name":"match","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Match","inner":[]}],"value":null,"annotations":[]}}}},"onNonMatch":{"name":"onNonMatch","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"nonMatch":{"name":"nonMatch","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"startsWith":{"name":"startsWith","qualifiedName":"dart-core.String.startsWith","comment":"<p>Returns true if this string starts with a match of <a>dart-core.String.startsWith.pattern</a>.</p>\n<pre><code>var string = 'Dart';\nstring.startsWith('D');                       // true\nstring.startsWith(new RegExp(r'[A-Z][a-z]')); // true\n</code></pre>\n<p>If <a>dart-core.String.startsWith.index</a> is provided, this method checks if the substring starting\nat that index starts with a match of <a>dart-core.String.startsWith.pattern</a>:</p>\n<pre><code>string.startsWith('art', 1);                  // true\nstring.startsWith(new RegExp(r'\\w{3}'));      // true\n</code></pre>\n<p><a>dart-core.String.startsWith.index</a> must not be negative or greater than <a>dart-core.String.length</a>.</p>\n<p>A <a>dart-core.RegExp</a> containing '^' does not match if the <a>dart-core.String.startsWith.index</a> is greater than\nzero. The pattern works on the string as a whole, and does not extract\na substring starting at <a>dart-core.String.startsWith.index</a> first:</p>\n<pre><code>string.startsWith(new RegExp(r'^art'), 1);    // false\nstring.startsWith(new RegExp(r'art'), 1);     // true\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"pattern":{"name":"pattern","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Pattern","inner":[]}],"value":null,"annotations":[]},"index":{"name":"index","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]}},"annotations":[]},"substring":{"name":"substring","qualifiedName":"dart-core.String.substring","comment":"<p>Returns the substring of this string that extends from <a>dart-core.String.substring.startIndex</a>,\ninclusive, to <a>dart-core.String.substring.endIndex</a>, exclusive.</p>\n<pre><code>var string = 'dartlang';\nstring.substring(1);    // 'artlang'\nstring.substring(1, 4); // 'art'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"startIndex":{"name":"startIndex","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"endIndex":{"name":"endIndex","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toLowerCase":{"name":"toLowerCase","qualifiedName":"dart-core.String.toLowerCase","comment":"<p>Converts all characters in this string to lower case.\nIf the string is already in all lower case, this method returns <code>this</code>.</p>\n<pre><code>'ALPHABET'.toLowerCase(); // 'alphabet'\n'abc'.toLowerCase();      // 'abc'\n</code></pre>\n<p>This function uses the language independent Unicode mapping and thus only\nworks in some languages.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"toUpperCase":{"name":"toUpperCase","qualifiedName":"dart-core.String.toUpperCase","comment":"<p>Converts all characters in this string to upper case.\nIf the string is already in all upper case, this method returns <code>this</code>.</p>\n<pre><code>'alphabet'.toUpperCase(); // 'ALPHABET'\n'ABC'.toUpperCase();      // 'ABC'\n</code></pre>\n<p>This function uses the language independent Unicode mapping and thus only\nworks in some languages.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"trim":{"name":"trim","qualifiedName":"dart-core.String.trim","comment":"<p>Returns the string without any leading and trailing whitespace.</p>\n<p>If the string contains leading or trailing whitespace, a new string with no\nleading and no trailing whitespace is returned:</p>\n<pre><code>'\\tDart is fun\\n'.trim(); // 'Dart is fun'\n</code></pre>\n<p>Otherwise, the original string itself is returned:</p>\n<pre><code>var str1 = 'Dart';\nvar str2 = str1.trim();\nidentical(str1, str2);    // true\n</code></pre>\n<p>Whitespace is defined by the Unicode White_Space property (as defined in\nversion 6.2 or later) and the BOM character, 0xFEFF.</p>\n<p>Here is the list of trimmed characters (following version 6.2):</p>\n<pre><code>0009..000D    ; White_Space # Cc   &lt;control-0009&gt;..&lt;control-000D&gt;\n0020          ; White_Space # Zs   SPACE\n0085          ; White_Space # Cc   &lt;control-0085&gt;\n00A0          ; White_Space # Zs   NO-BREAK SPACE\n1680          ; White_Space # Zs   OGHAM SPACE MARK\n180E          ; White_Space # Zs   MONGOLIAN VOWEL SEPARATOR\n2000..200A    ; White_Space # Zs   EN QUAD..HAIR SPACE\n2028          ; White_Space # Zl   LINE SEPARATOR\n2029          ; White_Space # Zp   PARAGRAPH SEPARATOR\n202F          ; White_Space # Zs   NARROW NO-BREAK SPACE\n205F          ; White_Space # Zs   MEDIUM MATHEMATICAL SPACE\n3000          ; White_Space # Zs   IDEOGRAPHIC SPACE\n\nFEFF          ; BOM                ZERO WIDTH NO_BREAK SPACE\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"trimLeft":{"name":"trimLeft","qualifiedName":"dart-core.String.trimLeft","comment":"<p>Returns the string without any leading whitespace.</p>\n<p>As <a>dart-core.String.trim</a>, but only removes leading whitespace.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"trimRight":{"name":"trimRight","qualifiedName":"dart-core.String.trimRight","comment":"<p>Returns the string without any trailing whitespace.</p>\n<p>As <a>dart-core.String.trim</a>, but only removes trailing whitespace.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"dart-core.String.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-core.String.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-core.String.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-core.String.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart-core.String.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart-core.String.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"allMatches":{"name":"allMatches","qualifiedName":"dart-core.String.allMatches","comment":"<p>Match this pattern against the string repeatedly.</p>\n<p>The iterable will contain all the non-overlapping matches of the\npattern on the string, ordered by start index.</p>\n<p>The matches are found by repeatedly finding the first match\nof the pattern on the string, starting from the end of the previous\nmatch, and initially starting from index zero.</p>\n<p>If the pattern matches the empty string at some point, the next\nmatch is found by starting at the previous match's end plus one.</p>","commentFrom":"","inheritedFrom":"dart-core.Pattern.allMatches","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.Match","inner":[]}]}],"parameters":{"str":{"name":"str","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"compareTo":{"name":"compareTo","qualifiedName":"dart-core.String.compareTo","comment":"<p>Compares this object to another <a>dart-core.Comparable</a></p>\n<p>Returns a value like a <a>dart-core.Comparator</a> when comparing <code>this</code> to <a>dart-core.String.compareTo.other</a>.\nThat is, it returns a negative integer if <code>this</code> is ordered before <a>dart-core.String.compareTo.other</a>,\na positive integer if <code>this</code> is ordered after <a>dart-core.String.compareTo.other</a>,\nand zero if <code>this</code> and <a>dart-core.String.compareTo.other</a> are ordered together.</p>\n<p>The <a>dart-core.String.compareTo.other</a> argument must be a value that is comparable to this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Comparable.compareTo","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Comparable.T","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"matchAsPrefix":{"name":"matchAsPrefix","qualifiedName":"dart-core.String.matchAsPrefix","comment":"<p>Match this pattern against the start of string.</p>\n<p>If <a>dart-core.String.matchAsPrefix.start</a> is provided, it must be an integer in the range <code>0</code> ..\n<code>string.length</code>. In that case, this patten is tested against the\nstring at the <a>dart-core.String.matchAsPrefix.start</a> position. That is, a match is returned if the\npattern can match a part of the string starting from position <a>dart-core.String.matchAsPrefix.start</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Pattern.matchAsPrefix","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.Match","inner":[]}],"parameters":{"string":{"name":"string","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"start":{"name":"start","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]}},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-core.String.noSuchMethod","comment":"<p><a>dart-core.String.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-core.String.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-core.String.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-core.String.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-core.String.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}