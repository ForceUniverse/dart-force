{"name":"http","qualifiedName":"http/http","comment":"<p>A composable, <a>http/dart-async.Future</a>-based library for making HTTP requests.</p>\n<h2>Installing</h2>\n<p>Use <a href=\"http://pub.dartlang.org\">pub</a> to install this package. Add the following to your\n<code>pubspec.yaml</code> file.</p>\n<pre><code>dependencies:\n  http: any\n</code></pre>\n<p>Then run <code>pub install</code>.</p>\n<p>For more information, see the\n<a href=\"http://pub.dartlang.org/packages/http\">http package on pub.dartlang.org</a>.</p>\n<p>The easiest way to use this library is via the top-level functions. They\nallow you to make individual HTTP requests with minimal hassle:</p>\n<pre><code>import 'package:http/http.dart' as http;\n\nvar url = \"http://example.com/whatsit/create\";\nhttp.post(url, body: {\"name\": \"doodle\", \"color\": \"blue\"})\n    .then((response) {\n  print(\"Response status: ${response.statusCode}\");\n  print(\"Response body: ${response.body}\");\n});\n\nhttp.read(\"http://example.com/foobar.txt\").then(print);\n</code></pre>\n<p>If you're making multiple requests to the same server, you can keep open a\npersistent connection by using a <a>http/http.Client</a> rather than making one-off\nrequests. If you do this, make sure to close the client when you're done:</p>\n<pre><code>var client = new http.Client();\nclient.post(\n    \"http://example.com/whatsit/create\",\n    body: {\"name\": \"doodle\", \"color\": \"blue\"})\n  .then((response) =&gt; client.get(response.bodyFields['uri']))\n  .then((response) =&gt; print(response.body))\n  .whenComplete(client.close);\n</code></pre>\n<p>You can also exert more fine-grained control over your requests and\nresponses by creating Request or StreamedRequest objects yourself and\npassing them to <a>http/http.Client.send</a>.</p>\n<p>This package is designed to be composable. This makes it easy for external\nlibraries to work with one another to add behavior to it. Libraries wishing\nto add behavior should create a subclass of BaseClient that wraps another\n<a>http/http.Client</a> and adds the desired behavior:</p>\n<pre><code>class UserAgentClient extends http.BaseClient {\n  final String userAgent;\n  final http.Client _inner;\n\n  UserAgentClient(this.userAgent, this._inner);\n\n  Future&lt;StreamedResponse&gt; send(BaseRequest request) {\n    request.headers[HttpHeaders.USER_AGENT] = userAgent;\n    return _inner.send(request);\n  }\n}\n</code></pre>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"delete":{"name":"delete","qualifiedName":"http/http.delete","comment":"<p>Sends an HTTP DELETE request with the given headers to the given URL, which\ncan be a <a>dart-core.Uri</a> or a <a>dart-core.String</a>.</p>\n<p>This automatically initializes a new <a>http/http.Client</a> and closes that client once\nthe request is complete. If you're planning on making multiple requests to\nthe same server, you should use a single <a>http/http.Client</a> for all of those requests.</p>\n<p>For more fine-grained control over the request, use Request instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"http/http.Response","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"headers":{"name":"headers","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"get":{"name":"get","qualifiedName":"http/http.get","comment":"<p>Sends an HTTP GET request with the given headers to the given URL, which can\nbe a <a>dart-core.Uri</a> or a <a>dart-core.String</a>.</p>\n<p>This automatically initializes a new <a>http/http.Client</a> and closes that client once\nthe request is complete. If you're planning on making multiple requests to\nthe same server, you should use a single <a>http/http.Client</a> for all of those requests.</p>\n<p>For more fine-grained control over the request, use Request instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"http/http.Response","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"headers":{"name":"headers","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"head":{"name":"head","qualifiedName":"http/http.head","comment":"<p>Sends an HTTP HEAD request with the given headers to the given URL, which\ncan be a <a>dart-core.Uri</a> or a <a>dart-core.String</a>.</p>\n<p>This automatically initializes a new <a>http/http.Client</a> and closes that client once\nthe request is complete. If you're planning on making multiple requests to\nthe same server, you should use a single <a>http/http.Client</a> for all of those requests.</p>\n<p>For more fine-grained control over the request, use Request instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"http/http.Response","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"headers":{"name":"headers","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"post":{"name":"post","qualifiedName":"http/http.post","comment":"<p>Sends an HTTP POST request with the given headers and body to the given URL,\nwhich can be a <a>dart-core.Uri</a> or a <a>dart-core.String</a>.</p>\n<p><a>http/http.post.body</a> sets the body of the request. It can be a <a>dart-core.String</a>, a <a>dart-core</a>&lt;<a>dart-core</a>> or\na <a>dart-core</a>&lt;<a>dart-core</a>, <a>dart-core</a>>. If it's a String, it's encoded using <a>http/http.post.encoding</a> and\nused as the body of the request. The content-type of the request will\ndefault to \"text/plain\".</p>\n<p>If <a>http/http.post.body</a> is a List, it's used as a list of bytes for the body of the\nrequest.</p>\n<p>If <a>http/http.post.body</a> is a Map, it's encoded as form fields using <a>http/http.post.encoding</a>. The\ncontent-type of the request will be set to\n<code>\"application/x-www-form-urlencoded\"</code>; this cannot be overridden.</p>\n<p><a>http/http.post.encoding</a> defaults to <a>http/dart-convert.UTF8</a>.</p>\n<p>For more fine-grained control over the request, use Request or\nStreamedRequest instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"http/http.Response","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"headers":{"name":"headers","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]},"body":{"name":"body","optional":true,"named":true,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"encoding":{"name":"encoding","optional":true,"named":true,"default":false,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"put":{"name":"put","qualifiedName":"http/http.put","comment":"<p>Sends an HTTP PUT request with the given headers and body to the given URL,\nwhich can be a <a>dart-core.Uri</a> or a <a>dart-core.String</a>.</p>\n<p><a>http/http.put.body</a> sets the body of the request. It can be a <a>dart-core.String</a>, a <a>dart-core</a>&lt;<a>dart-core</a>> or\na <a>dart-core</a>&lt;<a>dart-core</a>, <a>dart-core</a>>. If it's a String, it's encoded using <a>http/http.put.encoding</a> and\nused as the body of the request. The content-type of the request will\ndefault to \"text/plain\".</p>\n<p>If <a>http/http.put.body</a> is a List, it's used as a list of bytes for the body of the\nrequest.</p>\n<p>If <a>http/http.put.body</a> is a Map, it's encoded as form fields using <a>http/http.put.encoding</a>. The\ncontent-type of the request will be set to\n<code>\"application/x-www-form-urlencoded\"</code>; this cannot be overridden.</p>\n<p><a>http/http.put.encoding</a> defaults to <a>http/dart-convert.UTF8</a>.</p>\n<p>For more fine-grained control over the request, use Request or\nStreamedRequest instead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"http/http.Response","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"headers":{"name":"headers","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]},"body":{"name":"body","optional":true,"named":true,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"encoding":{"name":"encoding","optional":true,"named":true,"default":false,"type":[{"outer":"dart-convert.Encoding","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"read":{"name":"read","qualifiedName":"http/http.read","comment":"<p>Sends an HTTP GET request with the given headers to the given URL, which can\nbe a <a>dart-core.Uri</a> or a <a>dart-core.String</a>, and returns a Future that completes to the body of\nthe response as a <a>dart-core.String</a>.</p>\n<p>The Future will emit an HttpException if the response doesn't have a\nsuccess status code.</p>\n<p>This automatically initializes a new <a>http/http.Client</a> and closes that client once\nthe request is complete. If you're planning on making multiple requests to\nthe same server, you should use a single <a>http/http.Client</a> for all of those requests.</p>\n<p>For more fine-grained control over the request and response, use Request\ninstead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"headers":{"name":"headers","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"readBytes":{"name":"readBytes","qualifiedName":"http/http.readBytes","comment":"<p>Sends an HTTP GET request with the given headers to the given URL, which can\nbe a <a>dart-core.Uri</a> or a <a>dart-core.String</a>, and returns a Future that completes to the body of\nthe response as a list of bytes.</p>\n<p>The Future will emit an HttpException if the response doesn't have a\nsuccess status code.</p>\n<p>This automatically initializes a new <a>http/http.Client</a> and closes that client once\nthe request is complete. If you're planning on making multiple requests to\nthe same server, you should use a single <a>http/http.Client</a> for all of those requests.</p>\n<p>For more fine-grained control over the request and response, use Request\ninstead.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-typed_data.Uint8List","inner":[]}]}],"parameters":{"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"headers":{"name":"headers","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"BaseClient","qualifiedName":"http/http.BaseClient","preview":"<p>The abstract base class for an HTTP client. This is a mixin-style class;\nsubclasses only need to implement <a>http/http.BaseClient.send</a> and maybe <a>http/http.BaseClient.close</a>, and then they\nget various convenience methods for free.</p>"},{"name":"BaseRequest","qualifiedName":"http/http.BaseRequest","preview":"<p>The base class for HTTP requests.</p>"},{"name":"BaseResponse","qualifiedName":"http/http.BaseResponse","preview":"<p>The base class for HTTP responses.</p>"},{"name":"ByteStream","qualifiedName":"http/http.ByteStream","preview":"<p>A stream of chunks of bytes representing a single piece of data.</p>"},{"name":"Client","qualifiedName":"http/http.Client","preview":"<p>The interface for HTTP clients that take care of maintaining persistent\nconnections across multiple requests to the same server. If you only need to\nsend a single request, it's usually easier to use <a>http/http.Client.head</a>, <a>http/http.Client.get</a>, <a>http/http.Client.post</a>,\n<a>http/http.Client.put</a>, or <a>http/http.Client.delete</a> instead.</p>"},{"name":"MultipartFile","qualifiedName":"http/http.MultipartFile","preview":"<p>A file to be uploaded as part of a MultipartRequest. This doesn't need to\ncorrespond to a physical file.</p>"},{"name":"MultipartRequest","qualifiedName":"http/http.MultipartRequest","preview":"<p>A <code>multipart/form-data</code> request. Such a request has both string <a>http/http.MultipartRequest.fields</a>,\nwhich function as normal form fields, and (potentially streamed) binary\n<a>http/http.MultipartRequest.files</a>.</p>"},{"name":"Request","qualifiedName":"http/http.Request","preview":"<p>An HTTP request where the entire request body is known in advance.</p>"},{"name":"Response","qualifiedName":"http/http.Response","preview":"<p>An HTTP response where the entire response body is known in advance.</p>"},{"name":"StreamedRequest","qualifiedName":"http/http.StreamedRequest","preview":"<p>An HTTP request where the request body is sent asynchronously after the\nconnection has been established and the headers have been sent.</p>"},{"name":"StreamedResponse","qualifiedName":"http/http.StreamedResponse","preview":"<p>An HTTP response where the response body is received asynchronously after\nthe headers have been received.</p>"}],"typedef":{},"error":[]},"packageName":"http","packageIntro":"<h1>http</h1>\n<p>A composable, Future-based library for making HTTP requests.</p>\n<p>This package contains a set of high-level functions and classes that make it\neasy to consume HTTP resources.</p>\n<p><strong>NOTE:</strong> This package currently only works for\nserver-side or command-line Dart applications. In other words, if the app\nimports <code>dart:io</code>, it can use this package.</p>\n<h2>Using</h2>\n<p>Please see the <a href=\"https://api.dartlang.org/docs/channels/dev/latest/http.html\">API docs</a> for explanations and examples.</p>\n<h2>Filing issues</h2>\n<p>Please file issues for the http package at <a href=\"http://dartbug.com/new\">http://dartbug.com/new</a>.</p>"}