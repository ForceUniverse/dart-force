{"name":"StreamedRequest","qualifiedName":"http/http.StreamedRequest","comment":"<p>An HTTP request where the request body is sent asynchronously after the\nconnection has been established and the headers have been sent.</p>\n<p>When the request is sent via BaseClient.send, only the headers and\nwhatever data has already been written to StreamedRequest.stream will be\nsent immediately. More data will be sent as soon as it's written to\n<a>http/http.StreamedRequest.sink</a>, and when the sink is closed the request will end.</p>","isAbstract":false,"superclass":"http/http.BaseRequest","implements":[],"subclass":[],"variables":{},"inheritedVariables":{"headers":{"name":"headers","qualifiedName":"http/http.BaseRequest.headers","comment":"<p>The headers for this request.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.Map","inner":[{"outer":"dart-core.String","inner":[]},{"outer":"dart-core.String","inner":[]}]}],"annotations":[]},"method":{"name":"method","qualifiedName":"http/http.BaseRequest.method","comment":"<p>The HTTP method of the request. Most commonly \"GET\" or \"POST\", less\ncommonly \"HEAD\", \"PUT\", or \"DELETE\". Non-standard method names are also\nsupported.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.String","inner":[]}],"annotations":[]},"url":{"name":"url","qualifiedName":"http/http.BaseRequest.url","comment":"<p>The URL to which the request will be sent.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"annotations":[]}},"methods":{"setters":{},"getters":{"sink":{"name":"sink","qualifiedName":"http/http.StreamedRequest.sink","comment":"<p>The sink to which to write data that will be sent as the request body.\nThis may be safely written to before the request is sent; the data will be\nbuffered.</p>\n<p>Closing this signals the end of the request.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.EventSink","inner":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.int","inner":[]}]}]}],"parameters":{},"annotations":[]}},"constructors":{"":{"name":"","qualifiedName":"http/http.StreamedRequest.StreamedRequest-","comment":"<p>Creates a new streaming request.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"method":{"name":"method","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"url":{"name":"url","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Uri","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{},"methods":{"finalize":{"name":"finalize","qualifiedName":"http/http.StreamedRequest.finalize","comment":"<p>Freezes all mutable fields other than stream and returns a\nsingle-subscription <a>http/http.ByteStream</a> that emits the data being written to\n<a>http/http.StreamedRequest.sink</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"http/http.ByteStream","inner":[]}],"parameters":{},"annotations":[]}}},"inheritedMethods":{"setters":{"contentLength=":{"name":"contentLength=","qualifiedName":"http/http.StreamedRequest.contentLength=","comment":"","commentFrom":"","inheritedFrom":"http.BaseRequest.contentLength=","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"followRedirects=":{"name":"followRedirects=","qualifiedName":"http/http.StreamedRequest.followRedirects=","comment":"","commentFrom":"","inheritedFrom":"http.BaseRequest.followRedirects=","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.bool","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"maxRedirects=":{"name":"maxRedirects=","qualifiedName":"http/http.StreamedRequest.maxRedirects=","comment":"","commentFrom":"","inheritedFrom":"http.BaseRequest.maxRedirects=","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"persistentConnection=":{"name":"persistentConnection=","qualifiedName":"http/http.StreamedRequest.persistentConnection=","comment":"","commentFrom":"","inheritedFrom":"http.BaseRequest.persistentConnection=","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"value":{"name":"value","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.bool","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"getters":{"contentLength":{"name":"contentLength","qualifiedName":"http/http.StreamedRequest.contentLength","comment":"<p>The size of the request body, in bytes. This defaults to -1, which\nindicates that the size of the request is not known in advance.</p>","commentFrom":"","inheritedFrom":"http.BaseRequest.contentLength","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"finalized":{"name":"finalized","qualifiedName":"http/http.StreamedRequest.finalized","comment":"<p>Whether the request has been finalized.</p>","commentFrom":"","inheritedFrom":"http.BaseRequest.finalized","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"followRedirects":{"name":"followRedirects","qualifiedName":"http/http.StreamedRequest.followRedirects","comment":"<p>Whether the client should follow redirects while resolving this request.\nDefaults to true.</p>","commentFrom":"","inheritedFrom":"http.BaseRequest.followRedirects","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"hashCode":{"name":"hashCode","qualifiedName":"http/http.StreamedRequest.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>http/http.StreamedRequest.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"maxRedirects":{"name":"maxRedirects","qualifiedName":"http/http.StreamedRequest.maxRedirects","comment":"<p>The maximum number of redirects to follow when <a>http/http.StreamedRequest.followRedirects</a> is true.\nIf this number is exceeded the BaseResponse future will signal a\nRedirectException. Defaults to 5.</p>","commentFrom":"","inheritedFrom":"http.BaseRequest.maxRedirects","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"persistentConnection":{"name":"persistentConnection","qualifiedName":"http/http.StreamedRequest.persistentConnection","comment":"<p>Whether a persistent connection should be maintained with the server.\nDefaults to true.</p>","commentFrom":"","inheritedFrom":"http.BaseRequest.persistentConnection","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"http/http.StreamedRequest.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"http/http.StreamedRequest.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>http/http.StreamedRequest.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>http/http.StreamedRequest.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"finalize":{"name":"finalize","qualifiedName":"http/http.StreamedRequest.finalize","comment":"<p>Finalizes the HTTP request in preparation for it being sent. This freezes\nall mutable fields and returns a single-subscription <a>http/http.ByteStream</a> that\nemits the body of the request.</p>\n<p>The base implementation of this returns null rather than a <a>http/http.ByteStream</a>;\nsubclasses are responsible for creating the return value, which should be\nsingle-subscription to ensure that no data is dropped. They should also\nfreeze any additional mutable fields they add that don't make sense to\nchange after the request headers are sent.</p>","commentFrom":"","inheritedFrom":"http.BaseRequest.finalize","static":false,"abstract":false,"constant":false,"return":[{"outer":"http/http.ByteStream","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"http/http.StreamedRequest.noSuchMethod","comment":"<p><a>http/http.StreamedRequest.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>http/http.StreamedRequest.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>http/http.StreamedRequest.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>http/http.StreamedRequest.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"send":{"name":"send","qualifiedName":"http/http.StreamedRequest.send","comment":"<p>Sends this request.</p>\n<p>This automatically initializes a new <a>http/http.Client</a> and closes that client once\nthe request is complete. If you're planning on making multiple requests to\nthe same server, you should use a single <a>http/http.Client</a> for all of those\nrequests.</p>","commentFrom":"","inheritedFrom":"http.BaseRequest.send","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"http/http.StreamedResponse","inner":[]}]}],"parameters":{},"annotations":[]},"toString":{"name":"toString","qualifiedName":"http/http.StreamedRequest.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"dart-core.Object.toString","inheritedFrom":"http.BaseRequest.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}