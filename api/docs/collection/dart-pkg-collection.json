{"name":"dart-pkg-collection","qualifiedName":"collection/dart-pkg-collection","comment":"<p>Exports all the individual parts of the collection-helper library.</p>\n<p>The sub-libraries of this package are:</p><ul><li>\n<p><code>algorithms.dart</code>: Algorithms that work on lists (shuffle, binary search</p>\n<pre><code>             and various sorting algorithms).\n</code></pre></li><li><code>equality.dart</code>: Different notions of equality of collections.</li><li><code>iterable_zip.dart</code>: Combining multiple iterables into one.</li><li><code>priority_queue.dart</code>: Priority queue type and implementations.</li><li>\n<p><code>wrappers.dart</code>: Wrapper classes that delegate to a collection object.</p>\n<pre><code>           Includes unmodifiable views of collections.\n</code></pre></li></ul>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"binarySearch":{"name":"binarySearch","qualifiedName":"collection/dart-pkg-collection.binarySearch","comment":"<p>Returns a position of the <a>collection/dart-pkg-collection.binarySearch.key</a> in <a>collection/dart-pkg-collection.binarySearch.sortedList</a>, if it is there.</p>\n<p>If the list isn't sorted according to the <a>collection/dart-pkg-collection.binarySearch.compare</a> function, the result\nis unpredictable.</p>\n<p>If <a>collection/dart-pkg-collection.binarySearch.compare</a> is omitted, it defaults to calling <a>collection/dart-core.Comparable.compareTo</a> on\nthe objects.</p>\n<p>Returns -1 if <a>collection/dart-pkg-collection.binarySearch.key</a> is not in the list by default.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"sortedList":{"name":"sortedList","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"key":{"name":"key","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"compare":{"name":"compare","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"a":{"name":"a","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"b":{"name":"b","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"insertionSort":{"name":"insertionSort","qualifiedName":"collection/dart-pkg-collection.insertionSort","comment":"<p>Sort a list using insertion sort.</p>\n<p>Insertion sort is a simple sorting algorithm. For <code>n</code> elements it does on\nthe order of <code>n * log(n)</code> comparisons but up to <code>n</code> squared moves. The\nsorting is performed in-place, without using extra memory.</p>\n<p>For short lists the many moves have less impact than the simple algorithm,\nand it is often the favored sorting algorithm for short lists.</p>\n<p>This insertion sort is stable: Equal elements end up in the same order\nas they started in.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"list":{"name":"list","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"compare":{"name":"compare","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"a":{"name":"a","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"b":{"name":"b","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}}}},"start":{"name":"start","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"end":{"name":"end","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"mergeSort":{"name":"mergeSort","qualifiedName":"collection/dart-pkg-collection.mergeSort","comment":"<p>Sorts a list, or a range of a list, using the merge sort algorithm.</p>\n<p>Merge-sorting works by splitting the job into two parts, sorting each\nrecursively, and then merging the two sorted parts.</p>\n<p>This takes on the order of <code>n * log(n)</code> comparisons and moves to sort\n<code>n</code> elements, but requires extra space of about the same size as the list\nbeing sorted.</p>\n<p>This merge sort is stable: Equal elements end up in the same order\nas they started in.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"list":{"name":"list","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"start":{"name":"start","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"end":{"name":"end","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"compare":{"name":"compare","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"a":{"name":"a","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"b":{"name":"b","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"reverse":{"name":"reverse","qualifiedName":"collection/dart-pkg-collection.reverse","comment":"<p>Reverses a list, or a part of a list, in-place.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"list":{"name":"list","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"start":{"name":"start","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"end":{"name":"end","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"shuffle":{"name":"shuffle","qualifiedName":"collection/dart-pkg-collection.shuffle","comment":"<p>Shuffles a list randomly.</p>\n<p>A sub-range of a list can be shuffled by providing <a>collection/dart-pkg-collection.shuffle.start</a> and <a>collection/dart-pkg-collection.shuffle.end</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"list":{"name":"list","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"start":{"name":"start","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"end":{"name":"end","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"DeepCollectionEquality","qualifiedName":"collection/dart-pkg-collection.DeepCollectionEquality","preview":"<p>Deep equality on collections.</p>"},{"name":"DefaultEquality","qualifiedName":"collection/dart-pkg-collection.DefaultEquality","preview":"<p>Equality of objects that compares only the natural equality of the objects.</p>"},{"name":"DelegatingIterable","qualifiedName":"collection/dart-pkg-collection.DelegatingIterable","preview":"<p>Creates an <a>collection/dart-core.Iterable</a> that delegates all operations to a base iterable.</p>"},{"name":"DelegatingList","qualifiedName":"collection/dart-pkg-collection.DelegatingList","preview":"<p>Creates a <a>collection/dart-core.List</a> that delegates all operations to a base list.</p>"},{"name":"DelegatingMap","qualifiedName":"collection/dart-pkg-collection.DelegatingMap","preview":"<p>Creates a <a>collection/dart-core.Map</a> that delegates all operations to a base map.</p>"},{"name":"DelegatingQueue","qualifiedName":"collection/dart-pkg-collection.DelegatingQueue","preview":"<p>Creates a <a>collection/dart-pkg-collection.Queue</a> that delegates all operations to a base queue.</p>"},{"name":"DelegatingSet","qualifiedName":"collection/dart-pkg-collection.DelegatingSet","preview":"<p>Creates a <a>collection/dart-core.Set</a> that delegates all operations to a base set.</p>"},{"name":"Equality","qualifiedName":"collection/dart-pkg-collection.Equality","preview":"<p>A generic equality relation on objects.</p>"},{"name":"HeapPriorityQueue","qualifiedName":"collection/dart-pkg-collection.HeapPriorityQueue","preview":"<p>Heap based priority queue.</p>"},{"name":"IdentityEquality","qualifiedName":"collection/dart-pkg-collection.IdentityEquality","preview":"<p>Equality of objects that compares only the identity of the objects.</p>"},{"name":"IterableEquality","qualifiedName":"collection/dart-pkg-collection.IterableEquality","preview":"<p>Equality on iterables.</p>"},{"name":"IterableZip","qualifiedName":"collection/dart-pkg-collection.IterableZip","preview":"<p>Iterable that iterates over lists of values from other iterables.</p>"},{"name":"ListEquality","qualifiedName":"collection/dart-pkg-collection.ListEquality","preview":"<p>Equality on lists.</p>"},{"name":"MapEquality","qualifiedName":"collection/dart-pkg-collection.MapEquality","preview":"<p>Equality on maps.</p>"},{"name":"MapKeySet","qualifiedName":"collection/dart-pkg-collection.MapKeySet","preview":"<p>An unmodifiable <a>collection/dart-core.Set</a> view of the keys of a <a>collection/dart-core.Map</a>.</p>"},{"name":"MapValueSet","qualifiedName":"collection/dart-pkg-collection.MapValueSet","preview":"<p>Creates a modifiable <a>collection/dart-core.Set</a> view of the values of a <a>collection/dart-core.Map</a>.</p>"},{"name":"MultiEquality","qualifiedName":"collection/dart-pkg-collection.MultiEquality","preview":"<p>Combines several equalities into a single equality.</p>"},{"name":"NonGrowableListMixin","qualifiedName":"collection/dart-pkg-collection.NonGrowableListMixin","preview":"<p>Mixin class that implements a throwing version of all list operations that\nchange the List's length.</p>"},{"name":"NonGrowableListView","qualifiedName":"collection/dart-pkg-collection.NonGrowableListView","preview":"<p>A fixed-length list.</p>"},{"name":"PriorityQueue","qualifiedName":"collection/dart-pkg-collection.PriorityQueue","preview":"<p>A priority queue is a priority based work-list of elements.</p>"},{"name":"SetEquality","qualifiedName":"collection/dart-pkg-collection.SetEquality","preview":"<p>Equality of sets.</p>"},{"name":"UnmodifiableListView","qualifiedName":"collection/dart-pkg-collection.UnmodifiableListView","preview":"<p>An unmodifiable <a>collection/dart-core.List</a> view of another List.</p>"},{"name":"UnmodifiableMapMixin","qualifiedName":"collection/dart-pkg-collection.UnmodifiableMapMixin","preview":"<p>Mixin class that implements a throwing version of all map operations that\nchange the Map.</p>"},{"name":"UnmodifiableMapView","qualifiedName":"collection/dart-pkg-collection.UnmodifiableMapView","preview":"<p>An unmodifiable map.</p>"},{"name":"UnmodifiableSetMixin","qualifiedName":"collection/dart-pkg-collection.UnmodifiableSetMixin","preview":"<p>Mixin class that implements a throwing version of all set operations that\nchange the Set.</p>"},{"name":"UnmodifiableSetView","qualifiedName":"collection/dart-pkg-collection.UnmodifiableSetView","preview":"<p>An unmodifiable set.</p>"},{"name":"UnorderedIterableEquality","qualifiedName":"collection/dart-pkg-collection.UnorderedIterableEquality","preview":"<p>Equality of the elements of two iterables without considering order.</p>"}],"typedef":{},"error":[]},"packageName":"collection","packageIntro":"<p>Helper libraries for working with collections.</p>\n<p>The <code>collection</code> package contains a number of separate libraries\nwith utility functions and classes that makes working with collections easier.</p>\n<h2>Using</h2>\n<p>The <code>collection</code> package can be imported as separate libraries, or\nin totality:</p>\n<pre><code>import 'package:collection/algorithms.dart';\nimport 'package:collection/equality.dart';\nimport 'package:collection/iterable_zip.dart';\nimport 'package:collection/priority_queue.dart';\nimport 'package:collection/wrappers.dart';\n</code></pre>\n<p>or</p>\n<pre><code>import 'package:collection/collection.dart';\n</code></pre>\n<h2>Algorithms</h2>\n<p>The algorithms library contains functions that operate on lists.</p>\n<p>It contains ways to shuffle a <code>List</code>, do binary search on a sorted <code>List</code>, and\nvarious sorting algorithms.</p>\n<h2>Equality</h2>\n<p>The equality library gives a way to specify equality of elements and\ncollections.</p>\n<p>Collections in Dart have no inherent equality. Two sets are not equal, even\nif they contain exactly the same objects as elements.</p>\n<p>The equality library provides a way to say define such an equality. In this\ncase, for example, <code>const SetEquality(const IdentityEquality())</code> is an equality\nthat considers two sets equal exactly if they contain identical elements.</p>\n<p>The library provides ways to define equalities on <code>Iterable</code>s, <code>List</code>s, <code>Set</code>s,\nand <code>Map</code>s, as well as combinations of these, such as:</p>\n<pre><code>const MapEquality(const IdentityEquality(), const ListEquality());\n</code></pre>\n<p>This equality considers maps equal if they have identical keys, and the\ncorresponding values are lists with equal (<code>operator==</code>) values.</p>\n<h2>Iterable Zip</h2>\n<p>Utilities for \"zipping\" a list of iterables into an iterable of lists.</p>\n<h2>Priority Queue</h2>\n<p>An interface and implemention of a priority queue.</p>\n<h2>Wrappers</h2>\n<p>The wrappers library contains classes that \"wrap\" a collection.</p>\n<p>A wrapper class contains an object of the same type, and it forwards all\nmethods to the wrapped object.</p>\n<p>Wrapper classes can be used in various ways, for example to restrict the type\nof an object to that of a supertype, or to change the behavior of selected\nfunctions on an existing object.</p>"}