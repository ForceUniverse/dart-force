{"name":"dart-pkg-collection-equality","qualifiedName":"collection/dart-pkg-collection-equality","comment":"<p>Defines equality relations on collections.</p>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{}},"classes":{"class":[{"name":"DeepCollectionEquality","qualifiedName":"collection/dart-pkg-collection-equality.DeepCollectionEquality","preview":"<p>Deep equality on collections.</p>"},{"name":"DefaultEquality","qualifiedName":"collection/dart-pkg-collection-equality.DefaultEquality","preview":"<p>Equality of objects that compares only the natural equality of the objects.</p>"},{"name":"Equality","qualifiedName":"collection/dart-pkg-collection-equality.Equality","preview":"<p>A generic equality relation on objects.</p>"},{"name":"IdentityEquality","qualifiedName":"collection/dart-pkg-collection-equality.IdentityEquality","preview":"<p>Equality of objects that compares only the identity of the objects.</p>"},{"name":"IterableEquality","qualifiedName":"collection/dart-pkg-collection-equality.IterableEquality","preview":"<p>Equality on iterables.</p>"},{"name":"ListEquality","qualifiedName":"collection/dart-pkg-collection-equality.ListEquality","preview":"<p>Equality on lists.</p>"},{"name":"MapEquality","qualifiedName":"collection/dart-pkg-collection-equality.MapEquality","preview":"<p>Equality on maps.</p>"},{"name":"MultiEquality","qualifiedName":"collection/dart-pkg-collection-equality.MultiEquality","preview":"<p>Combines several equalities into a single equality.</p>"},{"name":"SetEquality","qualifiedName":"collection/dart-pkg-collection-equality.SetEquality","preview":"<p>Equality of sets.</p>"},{"name":"UnorderedIterableEquality","qualifiedName":"collection/dart-pkg-collection-equality.UnorderedIterableEquality","preview":"<p>Equality of the elements of two iterables without considering order.</p>"}],"typedef":{},"error":[]},"packageName":"collection","packageIntro":"<p>Helper libraries for working with collections.</p>\n<p>The <code>collection</code> package contains a number of separate libraries\nwith utility functions and classes that makes working with collections easier.</p>\n<h2>Using</h2>\n<p>The <code>collection</code> package can be imported as separate libraries, or\nin totality:</p>\n<pre><code>import 'package:collection/algorithms.dart';\nimport 'package:collection/equality.dart';\nimport 'package:collection/iterable_zip.dart';\nimport 'package:collection/priority_queue.dart';\nimport 'package:collection/wrappers.dart';\n</code></pre>\n<p>or</p>\n<pre><code>import 'package:collection/collection.dart';\n</code></pre>\n<h2>Algorithms</h2>\n<p>The algorithms library contains functions that operate on lists.</p>\n<p>It contains ways to shuffle a <code>List</code>, do binary search on a sorted <code>List</code>, and\nvarious sorting algorithms.</p>\n<h2>Equality</h2>\n<p>The equality library gives a way to specify equality of elements and\ncollections.</p>\n<p>Collections in Dart have no inherent equality. Two sets are not equal, even\nif they contain exactly the same objects as elements.</p>\n<p>The equality library provides a way to say define such an equality. In this\ncase, for example, <code>const SetEquality(const IdentityEquality())</code> is an equality\nthat considers two sets equal exactly if they contain identical elements.</p>\n<p>The library provides ways to define equalities on <code>Iterable</code>s, <code>List</code>s, <code>Set</code>s,\nand <code>Map</code>s, as well as combinations of these, such as:</p>\n<pre><code>const MapEquality(const IdentityEquality(), const ListEquality());\n</code></pre>\n<p>This equality considers maps equal if they have identical keys, and the\ncorresponding values are lists with equal (<code>operator==</code>) values.</p>\n<h2>Iterable Zip</h2>\n<p>Utilities for \"zipping\" a list of iterables into an iterable of lists.</p>\n<h2>Priority Queue</h2>\n<p>An interface and implemention of a priority queue.</p>\n<h2>Wrappers</h2>\n<p>The wrappers library contains classes that \"wrap\" a collection.</p>\n<p>A wrapper class contains an object of the same type, and it forwards all\nmethods to the wrapped object.</p>\n<p>Wrapper classes can be used in various ways, for example to restrict the type\nof an object to that of a supertype, or to change the behavior of selected\nfunctions on an existing object.</p>"}