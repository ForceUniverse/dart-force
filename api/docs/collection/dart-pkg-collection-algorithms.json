{"name":"dart-pkg-collection-algorithms","qualifiedName":"collection/dart-pkg-collection-algorithms","comment":"<p>Operations on collections.</p>","variables":{},"functions":{"setters":{},"getters":{},"constructors":{},"operators":{},"methods":{"binarySearch":{"name":"binarySearch","qualifiedName":"collection/dart-pkg-collection-algorithms.binarySearch","comment":"<p>Returns a position of the <a>collection/dart-pkg-collection-algorithms.binarySearch.key</a> in <a>collection/dart-pkg-collection-algorithms.binarySearch.sortedList</a>, if it is there.</p>\n<p>If the list isn't sorted according to the <a>collection/dart-pkg-collection-algorithms.binarySearch.compare</a> function, the result\nis unpredictable.</p>\n<p>If <a>collection/dart-pkg-collection-algorithms.binarySearch.compare</a> is omitted, it defaults to calling <a>collection/dart-core.Comparable.compareTo</a> on\nthe objects.</p>\n<p>Returns -1 if <a>collection/dart-pkg-collection-algorithms.binarySearch.key</a> is not in the list by default.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"sortedList":{"name":"sortedList","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"key":{"name":"key","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"compare":{"name":"compare","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"a":{"name":"a","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"b":{"name":"b","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"insertionSort":{"name":"insertionSort","qualifiedName":"collection/dart-pkg-collection-algorithms.insertionSort","comment":"<p>Sort a list using insertion sort.</p>\n<p>Insertion sort is a simple sorting algorithm. For <code>n</code> elements it does on\nthe order of <code>n * log(n)</code> comparisons but up to <code>n</code> squared moves. The\nsorting is performed in-place, without using extra memory.</p>\n<p>For short lists the many moves have less impact than the simple algorithm,\nand it is often the favored sorting algorithm for short lists.</p>\n<p>This insertion sort is stable: Equal elements end up in the same order\nas they started in.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"list":{"name":"list","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"compare":{"name":"compare","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"a":{"name":"a","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"b":{"name":"b","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}}}},"start":{"name":"start","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"end":{"name":"end","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"mergeSort":{"name":"mergeSort","qualifiedName":"collection/dart-pkg-collection-algorithms.mergeSort","comment":"<p>Sorts a list, or a range of a list, using the merge sort algorithm.</p>\n<p>Merge-sorting works by splitting the job into two parts, sorting each\nrecursively, and then merging the two sorted parts.</p>\n<p>This takes on the order of <code>n * log(n)</code> comparisons and moves to sort\n<code>n</code> elements, but requires extra space of about the same size as the list\nbeing sorted.</p>\n<p>This merge sort is stable: Equal elements end up in the same order\nas they started in.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"list":{"name":"list","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"start":{"name":"start","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"end":{"name":"end","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]},"compare":{"name":"compare","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"a":{"name":"a","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]},"b":{"name":"b","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"reverse":{"name":"reverse","qualifiedName":"collection/dart-pkg-collection-algorithms.reverse","comment":"<p>Reverses a list, or a part of a list, in-place.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"list":{"name":"list","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"start":{"name":"start","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"end":{"name":"end","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]},"shuffle":{"name":"shuffle","qualifiedName":"collection/dart-pkg-collection-algorithms.shuffle","comment":"<p>Shuffles a list randomly.</p>\n<p>A sub-range of a list can be shuffled by providing <a>collection/dart-pkg-collection-algorithms.shuffle.start</a> and <a>collection/dart-pkg-collection-algorithms.shuffle.end</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"list":{"name":"list","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.List","inner":[]}],"value":null,"annotations":[]},"start":{"name":"start","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"0","annotations":[]},"end":{"name":"end","optional":true,"named":false,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"null","annotations":[]}},"annotations":[]}}},"classes":{"class":[],"typedef":{},"error":[]},"packageName":"collection","packageIntro":"<p>Helper libraries for working with collections.</p>\n<p>The <code>collection</code> package contains a number of separate libraries\nwith utility functions and classes that makes working with collections easier.</p>\n<h2>Using</h2>\n<p>The <code>collection</code> package can be imported as separate libraries, or\nin totality:</p>\n<pre><code>import 'package:collection/algorithms.dart';\nimport 'package:collection/equality.dart';\nimport 'package:collection/iterable_zip.dart';\nimport 'package:collection/priority_queue.dart';\nimport 'package:collection/wrappers.dart';\n</code></pre>\n<p>or</p>\n<pre><code>import 'package:collection/collection.dart';\n</code></pre>\n<h2>Algorithms</h2>\n<p>The algorithms library contains functions that operate on lists.</p>\n<p>It contains ways to shuffle a <code>List</code>, do binary search on a sorted <code>List</code>, and\nvarious sorting algorithms.</p>\n<h2>Equality</h2>\n<p>The equality library gives a way to specify equality of elements and\ncollections.</p>\n<p>Collections in Dart have no inherent equality. Two sets are not equal, even\nif they contain exactly the same objects as elements.</p>\n<p>The equality library provides a way to say define such an equality. In this\ncase, for example, <code>const SetEquality(const IdentityEquality())</code> is an equality\nthat considers two sets equal exactly if they contain identical elements.</p>\n<p>The library provides ways to define equalities on <code>Iterable</code>s, <code>List</code>s, <code>Set</code>s,\nand <code>Map</code>s, as well as combinations of these, such as:</p>\n<pre><code>const MapEquality(const IdentityEquality(), const ListEquality());\n</code></pre>\n<p>This equality considers maps equal if they have identical keys, and the\ncorresponding values are lists with equal (<code>operator==</code>) values.</p>\n<h2>Iterable Zip</h2>\n<p>Utilities for \"zipping\" a list of iterables into an iterable of lists.</p>\n<h2>Priority Queue</h2>\n<p>An interface and implemention of a priority queue.</p>\n<h2>Wrappers</h2>\n<p>The wrappers library contains classes that \"wrap\" a collection.</p>\n<p>A wrapper class contains an object of the same type, and it forwards all\nmethods to the wrapped object.</p>\n<p>Wrapper classes can be used in various ways, for example to restrict the type\nof an object to that of a supertype, or to change the behavior of selected\nfunctions on an existing object.</p>"}