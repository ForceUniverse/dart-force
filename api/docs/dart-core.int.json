{"name":"int","qualifiedName":"dart-core.int","comment":"<p>An arbitrarily large integer.</p>\n<p><strong>Note:</strong> When compiling to JavaScript, integers are\nimplemented as JavaScript numbers. When compiling to JavaScript,\nintegers are therefore restricted to 53 significant bits because\nall JavaScript numbers are double-precision floating point\nvalues. The behavior of the operators and methods in the <a>dart-core.int</a>\nclass therefore sometimes differs between the Dart VM and Dart code\ncompiled to JavaScript.</p>\n<p>It is a compile-time error for a class to attempt to extend or implement int.</p>","isAbstract":true,"superclass":"dart-core.num","implements":[],"subclass":[],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{"bitLength":{"name":"bitLength","qualifiedName":"dart-core.int.bitLength","comment":"<p>Returns the minimum number of bits required to store this integer.</p>\n<p>The number of bits excludes the sign bit, which gives the natural length\nfor non-negative (unsigned) values.  Negative values are complemented to\nreturn the bit position of the first bit that differs from the sign bit.</p>\n<p>To find the the number of bits needed to store the value as a signed value,\nadd one, i.e. use <code>x.bitLength + 1</code>.</p>\n<pre><code> x.bitLength == (-x-1).bitLength\n\n 3.bitLength == 2;     // 00000011\n 2.bitLength == 2;     // 00000010\n 1.bitLength == 1;     // 00000001\n 0.bitLength == 0;     // 00000000\n (-1).bitLength == 0;  // 11111111\n (-2).bitLength == 1;  // 11111110\n (-3).bitLength == 2;  // 11111101\n (-4).bitLength == 2;  // 11111100\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"isEven":{"name":"isEven","qualifiedName":"dart-core.int.isEven","comment":"<p>Returns true if and only if this integer is even.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isOdd":{"name":"isOdd","qualifiedName":"dart-core.int.isOdd","comment":"<p>Returns true if and only if this integer is odd.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"sign":{"name":"sign","qualifiedName":"dart-core.int.sign","comment":"<p>Returns the sign of this integer.</p>\n<p>Returns 0 for zero, -1 for values less than zero and\n+1 for values greater than zero.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{"fromEnvironment":{"name":"fromEnvironment","qualifiedName":"dart-core.int.int-fromEnvironment","comment":"<p>Returns the integer value of the given environment declaration <a>dart-core.int.int-fromEnvironment.name</a>.</p>\n<p>The result is the same as would be returned by:</p>\n<pre><code>int.parse(const String.fromEnvironment(name, defaultValue: \"\"),\n          (_) =&gt; defaultValue)\n</code></pre>\n<p>Example:</p>\n<pre><code>const int.fromEnvironment(\"defaultPort\", defaultValue: 80)\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"name":{"name":"name","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"defaultValue":{"name":"defaultValue","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"operators":{"&":{"name":"&","qualifiedName":"dart-core.int.&","comment":"<p>Bit-wise and operator.</p>\n<p>Treating both <code>this</code> and <a>dart-core.int.&.other</a> as sufficiently large two's component\nintegers, the result is a number with only the bits set that are set in\nboth <code>this</code> and <a>dart-core.int.&.other</a></p>\n<p>Of both operands are negative, the result is negative, otherwise\nthe result is non-negative.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"<<":{"name":"<<","qualifiedName":"dart-core.int.<<","comment":"<p>Shift the bits of this integer to the left by <a>dart-core.int.<<.shiftAmount</a>.</p>\n<p>Shifting to the left makes the number larger, effectively multiplying\nthe number by <code>pow(2, shiftIndex)</code>.</p>\n<p>There is no limit on the size of the result. It may be relevant to\nlimit intermediate values by using the \"and\" operator with a suitable\nmask.</p>\n<p>It is an error of <a>dart-core.int.<<.shiftAmount</a> is negative.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"shiftAmount":{"name":"shiftAmount","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},">>":{"name":">>","qualifiedName":"dart-core.int.>>","comment":"<p>Shift the bits of this integer to the right by <a>dart-core.int.>>.shiftAmount</a>.</p>\n<p>Shifting to the right makes the number smaller and drops the least\nsignificant bits, effectively doing an integer division by\n<code>pow(2, shiftIndex)</code>.</p>\n<p>It is an error of <a>dart-core.int.>>.shiftAmount</a> is negative.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"shiftAmount":{"name":"shiftAmount","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"^":{"name":"^","qualifiedName":"dart-core.int.^","comment":"<p>Bit-wise exclusive-or operator.</p>\n<p>Treating both <code>this</code> and <a>dart-core.int.^.other</a> as sufficiently large two's component\nintegers, the result is a number with the bits set that are set in one,\nbut not both, of <code>this</code> and <a>dart-core.int.^.other</a></p>\n<p>If the operands have the same sign, the result is non-negative,\notherwise the result is negative.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"unary-":{"name":"unary-","qualifiedName":"dart-core.int.unary-","comment":"<p>Return the negative value of this integer.</p>\n<p>The result of negating an integer always has the opposite sign, except\nfor zero, which is its own negation.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"|":{"name":"|","qualifiedName":"dart-core.int.|","comment":"<p>Bit-wise or operator.</p>\n<p>Treating both <code>this</code> and <a>dart-core.int.|.other</a> as sufficiently large two's component\nintegers, the result is a number with the bits set that are set in either\nof <code>this</code> and <a>dart-core.int.|.other</a></p>\n<p>If both operands are non-negative, the result is non-negative,\notherwise the result us negative.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"~":{"name":"~","qualifiedName":"dart-core.int.~","comment":"<p>The bit-wise negate operator.</p>\n<p>Treating <code>this</code> as a sufficiently large two's component integer,\nthe result is a number with the opposite bits set.</p>\n<p>This maps any integer <code>x</code> to <code>-x - 1</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]}},"methods":{"abs":{"name":"abs","qualifiedName":"dart-core.int.abs","comment":"<p>Returns the absolute value of this integer.</p>\n<p>For any integer <code>x</code>, the result is the same as <code>x &lt; 0 ? -x : x</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"ceil":{"name":"ceil","qualifiedName":"dart-core.int.ceil","comment":"<p>Returns <code>this</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"ceilToDouble":{"name":"ceilToDouble","qualifiedName":"dart-core.int.ceilToDouble","comment":"<p>Returns <code>this.toDouble()</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]},"floor":{"name":"floor","qualifiedName":"dart-core.int.floor","comment":"<p>Returns <code>this</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"floorToDouble":{"name":"floorToDouble","qualifiedName":"dart-core.int.floorToDouble","comment":"<p>Returns <code>this.toDouble()</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]},"parse":{"name":"parse","qualifiedName":"dart-core.int.parse","comment":"<p>Parse <a>dart-core.int.parse.source</a> as an integer literal and return its value.</p>\n<p>The <a>dart-core.int.parse.radix</a> must be in the range 2..36. The digits used are\nfirst the decimal digits 0..9, and then the letters 'a'..'z'.\nAccepts capital letters as well.</p>\n<p>If no <a>dart-core.int.parse.radix</a> is given then it defaults to 10, unless the string starts\nwith \"0x\", \"-0x\" or \"+0x\", in which case the radix is set to 16 and the\n\"0x\" is ignored.</p>\n<p>The <a>dart-core.int.parse.source</a> must be a non-empty sequence of base-<a>dart-core.int.parse.radix</a> digits,\noptionally prefixed with a minus or plus sign ('-' or '+').</p>\n<p>It must always be the case for an int <code>n</code> and radix <code>r</code> that\n<code>n == parseRadix(n.toRadixString(r), r)</code>.</p>\n<p>If the <a>dart-core.int.parse.source</a> is not a valid integer literal, optionally prefixed by a\nsign, the <a>dart-core.int.parse.onError</a> is called with the <a>dart-core.int.parse.source</a> as argument, and its return\nvalue is used instead. If no <a>dart-core.int.parse.onError</a> is provided, a <a>dart-core.FormatException</a>\nis thrown.</p>\n<p>The <a>dart-core.int.parse.onError</a> function is only invoked if <a>dart-core.int.parse.source</a> is a <a>dart-core.String</a>. It is\nnot invoked if the <a>dart-core.int.parse.source</a> is, for example, <code>null</code>.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"source":{"name":"source","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"radix":{"name":"radix","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]},"onError":{"name":"onError","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.Function","inner":[]}],"value":null,"annotations":[],"functionDeclaration":{"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"source":{"name":"source","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}}}}},"annotations":[]},"round":{"name":"round","qualifiedName":"dart-core.int.round","comment":"<p>Returns <code>this</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"roundToDouble":{"name":"roundToDouble","qualifiedName":"dart-core.int.roundToDouble","comment":"<p>Returns <code>this.toDouble()</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]},"toRadixString":{"name":"toRadixString","qualifiedName":"dart-core.int.toRadixString","comment":"<p>Converts this to a string representation in the given <a>dart-core.int.toRadixString.radix</a>.</p>\n<p>In the string representation, lower-case letters are used for digits above\n'9'.</p>\n<p>The <a>dart-core.int.toRadixString.radix</a> argument must be an integer in the range 2 to 36.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"radix":{"name":"radix","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toSigned":{"name":"toSigned","qualifiedName":"dart-core.int.toSigned","comment":"<p>Returns the least significant <a>dart-core.int.toSigned.width</a> bits of this integer, extending the\nhighest retained bit to the sign.  This is the same as truncating the value\nto fit in <a>dart-core.int.toSigned.width</a> bits using an signed 2-s complement representation.  The\nreturned value has the same bit value in all positions higher than <a>dart-core.int.toSigned.width</a>.</p>\n<pre><code>                               V--sign bit-V\n16.toSigned(5) == -16   //  00010000 -&gt; 11110000\n239.toSigned(5) == 15   //  11101111 -&gt; 00001111\n                               ^           ^\n</code></pre>\n<p>This operation can be used to simulate arithmetic from low level languages.\nFor example, to increment an 8 bit signed quantity:</p>\n<pre><code>q = (q + 1).toSigned(8);\n</code></pre>\n<p><code>q</code> will count from <code>0</code> up to <code>127</code>, wrap to <code>-128</code> and count back up to\n<code>127</code>.</p>\n<p>If the input value fits in <a>dart-core.int.toSigned.width</a> bits without truncation, the result is\nthe same as the input.  The minimum width needed to avoid truncation of <code>x</code>\nis <code>x.bitLength + 1</code>, i.e.</p>\n<pre><code>x == x.toSigned(x.bitLength + 1);\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"width":{"name":"width","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-core.int.toString","comment":"<p>Returns a String-representation of this integer.</p>\n<p>The returned string is parsable by <a>dart-core.int.parse</a>.\nFor any <code>int</code> <code>i</code>, it is guaranteed that\n<code>i == int.parse(i.toString())</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"toUnsigned":{"name":"toUnsigned","qualifiedName":"dart-core.int.toUnsigned","comment":"<p>Returns the least significant <a>dart-core.int.toUnsigned.width</a> bits of this integer as a\nnon-negative number (i.e. unsigned representation).  The returned value has\nzeros in all bit positions higher than <a>dart-core.int.toUnsigned.width</a>.</p>\n<pre><code>(-1).toUnsigned(5) == 32   // 11111111  -&gt;  00011111\n</code></pre>\n<p>This operation can be used to simulate arithmetic from low level languages.\nFor example, to increment an 8 bit quantity:</p>\n<pre><code>q = (q + 1).toUnsigned(8);\n</code></pre>\n<p><code>q</code> will count from <code>0</code> up to <code>255</code> and then wrap around to <code>0</code>.</p>\n<p>If the input fits in <a>dart-core.int.toUnsigned.width</a> bits without truncation, the result is the\nsame as the input.  The minimum width needed to avoid truncation of <code>x</code> is\ngiven by <code>x.bitLength</code>, i.e.</p>\n<pre><code>x == x.toUnsigned(x.bitLength);\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"width":{"name":"width","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"truncate":{"name":"truncate","qualifiedName":"dart-core.int.truncate","comment":"<p>Returns <code>this</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"truncateToDouble":{"name":"truncateToDouble","qualifiedName":"dart-core.int.truncateToDouble","comment":"<p>Returns <code>this.toDouble()</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"dart-core.int.hashCode","comment":"<p>Returns a hash code for a numerical value.</p>\n<p>The hash code is compatible with equality. It returns the same value\nfor an <a>dart-core.int</a> and a <a>dart-core.double</a> with the same numerical value, and therefore\nthe same value for the doubles zero and minus zero.</p>\n<p>No guarantees are made about the hash code of NaN.</p>","commentFrom":"","inheritedFrom":"dart-core.num.hashCode","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"isFinite":{"name":"isFinite","qualifiedName":"dart-core.int.isFinite","comment":"<p>True if the number is finite; otherwise, false.</p>\n<p>The only non-finite numbers are NaN, positive infinitity and\nnegative infinity.</p>","commentFrom":"","inheritedFrom":"dart-core.num.isFinite","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isInfinite":{"name":"isInfinite","qualifiedName":"dart-core.int.isInfinite","comment":"<p>True if the number is positive infinity or negative infinity; otherwise,\nfalse.</p>","commentFrom":"","inheritedFrom":"dart-core.num.isInfinite","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isNaN":{"name":"isNaN","qualifiedName":"dart-core.int.isNaN","comment":"<p>True if the number is the double Not-a-Number value; otherwise, false.</p>","commentFrom":"","inheritedFrom":"dart-core.num.isNaN","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isNegative":{"name":"isNegative","qualifiedName":"dart-core.int.isNegative","comment":"<p>True if the number is negative; otherwise, false.</p>\n<p>Negative numbers are those less than zero, and the double <code>-0.0</code>.</p>","commentFrom":"","inheritedFrom":"dart-core.num.isNegative","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-core.int.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]},"sign":{"name":"sign","qualifiedName":"dart-core.int.sign","comment":"<p>Returns minus one, zero or plus one depending on the sign and\nnumerical value of the number.</p>\n<p>Returns minus one if the number is less than zero,\nplus one if the number is greater than zero,\nand zero if the number is equal to zero.</p>\n<p>Returns NaN if the number is the double NaN value.</p>\n<p>Returns a number of the same type as this number.\nFor doubles, <code>-0.0.sign == -0.0</code>.</p>\n<p>The result satisfies:</p>\n<pre><code>n == n.sign * n.abs()\n</code></pre>\n<p>for all numbers <code>n</code> (except NaN, because NaN isn't <code>==</code> to itself).</p>","commentFrom":"","inheritedFrom":"dart-core.num.sign","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"%":{"name":"%","qualifiedName":"dart-core.int.%","comment":"<p>Euclidean modulo operator.</p>\n<p>Returns the remainder of the euclidean division. The euclidean division of\ntwo integers <code>a</code> and <code>b</code> yields two integers <code>q</code> and <code>r</code> such that\n<code>a == b * q + r</code> and <code>0 &lt;= r &lt; b.abs()</code>.</p>\n<p>The euclidean division is only defined for integers, but can be easily\nextended to work with doubles. In that case <code>r</code> may have a non-integer\nvalue, but it still verifies <code>0 &lt;= r &lt; |b|</code>.</p>\n<p>The sign of the returned value <code>r</code> is always positive.</p>\n<p>See <a>dart-core.int.remainder</a> for the remainder of the truncating division.</p>","commentFrom":"","inheritedFrom":"dart-core.num.%","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"*":{"name":"*","qualifiedName":"dart-core.int.*","comment":"<p>Multiplication operator.</p>","commentFrom":"","inheritedFrom":"dart-core.num.*","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"+":{"name":"+","qualifiedName":"dart-core.int.+","comment":"<p>Addition operator.</p>","commentFrom":"","inheritedFrom":"dart-core.num.+","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"-":{"name":"-","qualifiedName":"dart-core.int.-","comment":"<p>Subtraction operator.</p>","commentFrom":"","inheritedFrom":"dart-core.num.-","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"/":{"name":"/","qualifiedName":"dart-core.int./","comment":"<p>Division operator.</p>","commentFrom":"","inheritedFrom":"dart-core.num./","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"<":{"name":"<","qualifiedName":"dart-core.int.<","comment":"<p>Relational less than operator.</p>","commentFrom":"","inheritedFrom":"dart-core.num.<","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"<=":{"name":"<=","qualifiedName":"dart-core.int.<=","comment":"<p>Relational less than or equal operator.</p>","commentFrom":"","inheritedFrom":"dart-core.num.<=","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"==":{"name":"==","qualifiedName":"dart-core.int.==","comment":"<p>Test whether this value is numerically equal to <code>other</code>.</p>\n<p>If both operands are doubles, they are equal if they have the same\nrepresentation, except that:\n  * zero and minus zero (0.0 and -0.0) are considered equal. They</p>\n<pre><code>both have the numerical value zero.\n</code></pre><ul><li>\n<p>NaN is not equal to anything, including NaN. If either operand is\nNaN, the result is always false.</p></li></ul>\n<p>If one operand is a double and the other is an int, they are equal if\nthe double has an integer value (finite with no fractional part) and\n<code>identical(doubleValue.toInt(), intValue)</code>.</p>\n<p>If both operands are integers, they are equal if they have the same value.</p>\n<p>Returns false if <code>other</code> is not a <a>dart-core.num</a>.</p>\n<p>Notice that the behavior for NaN is non-reflexive. This means that\nequality of double values is not a proper equality relation, as is\notherwise required of <code>operator==</code>. Using NaN in, e.g., a <a>dart-collection.HashSet</a>\nwill fail to work. The behavior is the standard IEEE-754 equality of\ndoubles.</p>\n<p>If you can avoid NaN values, the remaining doubles do have a proper eqality\nrelation, and can be used safely.</p>\n<p>Use <a>dart-core.int.compareTo</a> for a comparison that distinguishes zero and minus zero,\nand that considers NaN values as equal.</p>","commentFrom":"","inheritedFrom":"dart-core.num.==","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Object","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},">":{"name":">","qualifiedName":"dart-core.int.>","comment":"<p>Relational greater than operator.</p>","commentFrom":"","inheritedFrom":"dart-core.num.>","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},">=":{"name":">=","qualifiedName":"dart-core.int.>=","comment":"<p>Relational greater than or equal operator.</p>","commentFrom":"","inheritedFrom":"dart-core.num.>=","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"unary-":{"name":"unary-","qualifiedName":"dart-core.int.unary-","comment":"<p>Negate operator.</p>","commentFrom":"","inheritedFrom":"dart-core.num.unary-","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{},"annotations":[]},"~/":{"name":"~/","qualifiedName":"dart-core.int.~/","comment":"<p>Truncating division operator.</p>\n<p>If either operand is a <a>dart-core.double</a> then the result of the truncating division\n<code>a ~/ b</code> is equivalent to <code>(a / b).truncate().toInt()</code>.</p>\n<p>If both operands are <a>dart-core.int</a>s then <code>a ~/ b</code> performs the truncating\ninteger division.</p>","commentFrom":"","inheritedFrom":"dart-core.num.~/","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"abs":{"name":"abs","qualifiedName":"dart-core.int.abs","comment":"<p>Returns the absolute value of this <a>dart-core.num</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.num.abs","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{},"annotations":[]},"ceil":{"name":"ceil","qualifiedName":"dart-core.int.ceil","comment":"<p>Returns the least integer no smaller than <code>this</code>.</p>\n<p>If <code>this</code> is not finite (<code>NaN</code> or infinity), throws an <a>dart-core.UnsupportedError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.num.ceil","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"ceilToDouble":{"name":"ceilToDouble","qualifiedName":"dart-core.int.ceilToDouble","comment":"<p>Returns the least double integer value no smaller than <code>this</code>.</p>\n<p>If this is already an integer valued double, including <code>-0.0</code>, or it is a\nnon-finite double value, the value is returned unmodified.</p>\n<p>For the purpose of rounding, <code>-0.0</code> is considered to be below <code>0.0</code>.\nA number <code>d</code> in the range <code>-1.0 &lt; d &lt; 0.0</code> will return <code>-0.0</code>.</p>\n<p>The result is always a double.\nIf this is a numerically large integer, the result may be an infinite\ndouble.</p>","commentFrom":"","inheritedFrom":"dart-core.num.ceilToDouble","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]},"clamp":{"name":"clamp","qualifiedName":"dart-core.int.clamp","comment":"<p>Clamps this to be in the range <a>dart-core.int.clamp.lowerLimit</a>-<a>dart-core.int.clamp.upperLimit</a>. The comparison\nis done using <a>dart-core.int.compareTo</a> and therefore takes <code>-0.0</code> into account.\nIt also implies that <a>dart-core.double.NAN</a> is treated as the maximal double value.</p>","commentFrom":"","inheritedFrom":"dart-core.num.clamp","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"lowerLimit":{"name":"lowerLimit","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]},"upperLimit":{"name":"upperLimit","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"compareTo":{"name":"compareTo","qualifiedName":"dart-core.int.compareTo","comment":"<p>Compares this to <code>other</code>.</p>\n<p>Returns a negative number if <code>this</code> is less than <code>other</code>, zero if they are\nequal, and a positive number if <code>this</code> is greater than <code>other</code>.</p>\n<p>The orderding represented by this method is a total ordering of <a>dart-core.num</a>\nvalues. All distinct doubles are non-equal, as are all distinct integers,\nbut integers are equal to doubles if they have the same numerical\nvalue.</p>\n<p>For ordering, the double NaN value is considered equal to itself, and\ngreater than any numeric value (unlike its behavior in <code>operator==</code>).</p>\n<p>The double value -0.0 is considered less than 0.0 (and the integer 0), but\ngreater than any non-zero negative value.</p>\n<p>Positive infinity is greater than any finite value (any value apart from\nitself and NaN), and negative infinity is less than any other value.</p>\n<p>All other values are compared using their numeric value.</p>","commentFrom":"","inheritedFrom":"dart-core.num.compareTo","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"floor":{"name":"floor","qualifiedName":"dart-core.int.floor","comment":"<p>Returns the greatest integer no greater than <code>this</code>.</p>\n<p>If <code>this</code> is not finite (<code>NaN</code> or infinity), throws an <a>dart-core.UnsupportedError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.num.floor","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"floorToDouble":{"name":"floorToDouble","qualifiedName":"dart-core.int.floorToDouble","comment":"<p>Returns the greatest double integer value no greater than <code>this</code>.</p>\n<p>If this is already an integer valued double, including <code>-0.0</code>, or it is a\nnon-finite double value, the value is returned unmodified.</p>\n<p>For the purpose of rounding, <code>-0.0</code> is considered to be below <code>0.0</code>.\nA number <code>d</code> in the range <code>0.0 &lt; d &lt; 1.0</code> will return <code>0.0</code>.</p>\n<p>The result is always a double.\nIf this is a numerically large integer, the result may be an infinite\ndouble.</p>","commentFrom":"","inheritedFrom":"dart-core.num.floorToDouble","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]},"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-core.int.noSuchMethod","comment":"<p><a>dart-core.int.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-core.int.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-core.int.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-core.int.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"remainder":{"name":"remainder","qualifiedName":"dart-core.int.remainder","comment":"<p>Returns the remainder of the truncating division of <code>this</code> by <a>dart-core.int.remainder.other</a>.</p>\n<p>The result <code>r</code> of this operation satisfies:\n<code>this == (this ~/ other) * other + r</code>.\nAs a consequence the remainder <code>r</code> has the same sign as the divider <code>this</code>.</p>","commentFrom":"","inheritedFrom":"dart-core.num.remainder","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.num","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.num","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"round":{"name":"round","qualifiedName":"dart-core.int.round","comment":"<p>Returns the integer closest to <code>this</code>.</p>\n<p>Rounds away from zero when there is no closest integer:\n <code>(3.5).round() == 4</code> and <code>(-3.5).round() == -4</code>.</p>\n<p>If <code>this</code> is not finite (<code>NaN</code> or infinity), throws an <a>dart-core.UnsupportedError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.num.round","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"roundToDouble":{"name":"roundToDouble","qualifiedName":"dart-core.int.roundToDouble","comment":"<p>Returns the double integer value closest to <code>this</code>.</p>\n<p>Rounds away from zero when there is no closest integer:\n <code>(3.5).roundToDouble() == 4</code> and <code>(-3.5).roundToDouble() == -4</code>.</p>\n<p>If this is already an integer valued double, including <code>-0.0</code>, or it is a\nnon-finite double value, the value is returned unmodified.</p>\n<p>For the purpose of rounding, <code>-0.0</code> is considered to be below <code>0.0</code>,\nand <code>-0.0</code> is therefore considered closer to negative numbers than <code>0.0</code>.\nThis means that for a value, <code>d</code> in the range <code>-0.5 &lt; d &lt; 0.0</code>,\nthe result is <code>-0.0</code>.</p>\n<p>The result is always a double.\nIf this is a numerically large integer, the result may be an infinite\ndouble.</p>","commentFrom":"","inheritedFrom":"dart-core.num.roundToDouble","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]},"toDouble":{"name":"toDouble","qualifiedName":"dart-core.int.toDouble","comment":"<p>Return this <a>dart-core.num</a> as a <a>dart-core.double</a>.</p>\n<p>If the number is not representable as a <a>dart-core.double</a>, an\napproximation is returned. For numerically large integers, the\napproximation may be infinite.</p>","commentFrom":"","inheritedFrom":"dart-core.num.toDouble","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]},"toInt":{"name":"toInt","qualifiedName":"dart-core.int.toInt","comment":"<p>Truncates this <a>dart-core.num</a> to an integer and returns the result as an <a>dart-core.int</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.num.toInt","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-core.int.toString","comment":"<p>Returns the shortest string that correctly represent the input number.</p>\n<p>All <a>dart-core.double</a>s in the range <code>10^-6</code> (inclusive) to <code>10^21</code> (exclusive)\nare converted to their decimal representation with at least one digit\nafter the decimal point. For all other doubles,\nexcept for special values like <code>NaN</code> or <code>Infinity</code>, this method returns an\nexponential representation (see <a>dart-core.int.toStringAsExponential</a>).</p>\n<p>Returns <code>\"NaN\"</code> for <a>dart-core.double.NAN</a>, <code>\"Infinity\"</code> for <a>dart-core.double.INFINITY</a>, and\n<code>\"-Infinity\"</code> for double.MINUS_INFINITY.</p>\n<p>An <a>dart-core.int</a> is converted to a decimal representation with no decimal point.</p>\n<p>Examples:</p>\n<pre><code>(0.000001).toString();  // \"0.000001\"\n(0.0000001).toString(); // \"1e-7\"\n(111111111111111111111.0).toString();  // \"111111111111111110000.0\"\n(100000000000000000000.0).toString();  // \"100000000000000000000.0\"\n(1000000000000000000000.0).toString(); // \"1e+21\"\n(1111111111111111111111.0).toString(); // \"1.1111111111111111e+21\"\n1.toString(); // \"1\"\n111111111111111111111.toString();  // \"111111111111111110000\"\n100000000000000000000.toString();  // \"100000000000000000000\"\n1000000000000000000000.toString(); // \"1000000000000000000000\"\n1111111111111111111111.toString(); // \"1111111111111111111111\"\n1.234e5.toString();   // 123400\n1234.5e6.toString();  // 1234500000\n12.345e67.toString(); // 1.2345e+68\n</code></pre>\n<p>Note: the conversion may round the output if the returned string\nis accurate enough to uniquely identify the input-number.\nFor example the most precise representation of the <a>dart-core.double</a> <code>9e59</code> equals\n<code>\"899999999999999918767229449717619953810131273674690656206848\"</code>, but\nthis method returns the shorter (but still uniquely identifying) <code>\"9e59\"</code>.</p>","commentFrom":"","inheritedFrom":"dart-core.num.toString","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"toStringAsExponential":{"name":"toStringAsExponential","qualifiedName":"dart-core.int.toStringAsExponential","comment":"<p>Returns an exponential string-representation of <code>this</code>.</p>\n<p>Converts <code>this</code> to a <a>dart-core.double</a> before computing the string representation.</p>\n<p>If <a>dart-core.int.toStringAsExponential.fractionDigits</a> is given then it must be an integer satisfying:\n<code>0 &lt;= fractionDigits &lt;= 20</code>. In this case the string contains exactly\n<a>dart-core.int.toStringAsExponential.fractionDigits</a> after the decimal point. Otherwise, without the parameter,\nthe returned string uses the shortest number of digits that accurately\nrepresent this.</p>\n<p>If <a>dart-core.int.toStringAsExponential.fractionDigits</a> equals 0 then the decimal point is omitted.\nExamples:</p>\n<pre><code>1.toStringAsExponential();       // 1e+0\n1.toStringAsExponential(3);      // 1.000e+0\n123456.toStringAsExponential();  // 1.23456e+5\n123456.toStringAsExponential(3); // 1.235e+5\n123.toStringAsExponential(0);    // 1e+2\n</code></pre>","commentFrom":"","inheritedFrom":"dart-core.num.toStringAsExponential","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"fractionDigits":{"name":"fractionDigits","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toStringAsFixed":{"name":"toStringAsFixed","qualifiedName":"dart-core.int.toStringAsFixed","comment":"<p>Returns a decimal-point string-representation of <code>this</code>.</p>\n<p>Converts <code>this</code> to a <a>dart-core.double</a> before computing the string representation.</p>\n<p>If the absolute value of <code>this</code> is greater or equal to <code>10^21</code> then this\nmethods returns an exponential representation computed by\n<code>this.toStringAsExponential()</code>. Otherwise the result\nis the closest string representation with exactly <a>dart-core.int.toStringAsFixed.fractionDigits</a> digits\nafter the decimal point. If <a>dart-core.int.toStringAsFixed.fractionDigits</a> equals 0 then the decimal\npoint is omitted.</p>\n<p>The parameter <a>dart-core.int.toStringAsFixed.fractionDigits</a> must be an integer satisfying:\n<code>0 &lt;= fractionDigits &lt;= 20</code>.</p>\n<p>Examples:</p>\n<pre><code>1.toStringAsFixed(3);  // 1.000\n(4321.12345678).toStringAsFixed(3);  // 4321.123\n(4321.12345678).toStringAsFixed(5);  // 4321.12346\n123456789012345678901.toStringAsFixed(3);  // 123456789012345683968.000\n1000000000000000000000.toStringAsFixed(3); // 1e+21\n5.25.toStringAsFixed(0); // 5\n</code></pre>","commentFrom":"","inheritedFrom":"dart-core.num.toStringAsFixed","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"fractionDigits":{"name":"fractionDigits","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toStringAsPrecision":{"name":"toStringAsPrecision","qualifiedName":"dart-core.int.toStringAsPrecision","comment":"<p>Converts <code>this</code> to a double and returns a string representation with\nexactly <a>dart-core.int.toStringAsPrecision.precision</a> significant digits.</p>\n<p>The parameter <a>dart-core.int.toStringAsPrecision.precision</a> must be an integer satisfying:\n<code>1 &lt;= precision &lt;= 21</code>.</p>\n<p>Examples:</p>\n<pre><code>1.toStringAsPrecision(2);       // 1.0\n1e15.toStringAsPrecision(3);    // 1.00+15\n1234567.toStringAsPrecision(3); // 1.23e+6\n1234567.toStringAsPrecision(9); // 1234567.00\n12345678901234567890.toStringAsPrecision(20); // 12345678901234567168\n12345678901234567890.toStringAsPrecision(14); // 1.2345678901235e+19\n0.00000012345.toPrecision(15); // 1.23450000000000e-7\n0.0000012345.toPrecision(15);  // 0.00000123450000000000\n</code></pre>","commentFrom":"","inheritedFrom":"dart-core.num.toStringAsPrecision","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"precision":{"name":"precision","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.int","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"truncate":{"name":"truncate","qualifiedName":"dart-core.int.truncate","comment":"<p>Returns the integer obtained by discarding any fractional\ndigits from <code>this</code>.</p>\n<p>If <code>this</code> is not finite (<code>NaN</code> or infinity), throws an <a>dart-core.UnsupportedError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.num.truncate","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"truncateToDouble":{"name":"truncateToDouble","qualifiedName":"dart-core.int.truncateToDouble","comment":"<p>Returns the double integer value obtained by discarding any fractional\ndigits from the double value of <code>this</code>.</p>\n<p>If this is already an integer valued double, including <code>-0.0</code>, or it is a\nnon-finite double value, the value is returned unmodified.</p>\n<p>For the purpose of rounding, <code>-0.0</code> is considered to be below <code>0.0</code>.\nA number <code>d</code> in the range <code>-1.0 &lt; d &lt; 0.0</code> will return <code>-0.0</code>, and\nin the range <code>0.0 &lt; d &lt; 1.0</code> it will return 0.0.</p>\n<p>The result is always a double.\nIf this is a numerically large integer, the result may be an infinite\ndouble.</p>","commentFrom":"","inheritedFrom":"dart-core.num.truncateToDouble","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.double","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}