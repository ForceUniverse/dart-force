{"name":"path","qualifiedName":"path/path","comment":"<p>A comprehensive, cross-platform path manipulation library.</p>\n<h2>Installing</h2>\n<p>Use <a href=\"http://pub.dartlang.org\">pub</a> to install this package. Add the following to your\n<code>pubspec.yaml</code> file.</p>\n<pre><code>dependencies:\n  path: any\n</code></pre>\n<p>Then run <code>pub install</code>.</p>\n<p>For more information, see the <a href=\"http://pub.dartlang.org/packages/path\">path package on pub.dartlang.org</a>.</p>\n<h2>Usage</h2>\n<p>The path library was designed to be imported with a prefix, though you don't\nhave to if you don't want to:</p>\n<pre><code>import 'package:path/path.dart' as path;\n</code></pre>\n<p>The most common way to use the library is through the top-level functions.\nThese manipulate path strings based on your current working directory and\nthe path style (POSIX, Windows, or URLs) of the host platform. For example:</p>\n<pre><code>path.join(\"directory\", \"file.txt\");\n</code></pre>\n<p>This calls the top-level <a>path/path.join</a> function to join \"directory\" and \"file.txt\"\nusing the current platform's directory separator.</p>\n<p>If you want to work with paths for a specific platform regardless of the\nunderlying platform that the program is running on, you can create a\n<a>path/path.Context</a> and give it an explicit <a>path/path.Style</a>:</p>\n<pre><code>var context = new path.Context(style: Style.windows);\ncontext.join(\"directory\", \"file.txt\");\n</code></pre>\n<p>This will join \"directory\" and \"file.txt\" using the Windows path separator,\neven when the program is run on a POSIX machine.</p>","variables":{"posix":{"name":"posix","qualifiedName":"path/path.posix","comment":"<p>A default context for manipulating POSIX paths.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"url":{"name":"url","qualifiedName":"path/path.url","comment":"<p>A default context for manipulating URLs.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]},"windows":{"name":"windows","qualifiedName":"path/path.windows","comment":"<p>A default context for manipulating Windows paths.</p>","final":true,"static":false,"constant":false,"type":[{"outer":"dynamic","inner":[]}],"annotations":[]}},"functions":{"setters":{},"getters":{"current":{"name":"current","qualifiedName":"path/path.current","comment":"<p>Gets the path to the current working directory.</p>\n<p>In the browser, this means the current URL, without the last file segment.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"separator":{"name":"separator","qualifiedName":"path/path.separator","comment":"<p>Gets the path separator for the current platform. This is <code>\\</code> on Windows\nand <code>/</code> on other platforms (including the browser).</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"style":{"name":"style","qualifiedName":"path/path.style","comment":"<p>Returns the <a>path/path.Style</a> of the current context.</p>\n<p>This is the style that all top-level path functions will use.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"path/path.Style","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{},"methods":{"absolute":{"name":"absolute","qualifiedName":"path/path.absolute","comment":"<p>Creates a new path by appending the given path parts to <a>path/path.current</a>.\nEquivalent to join() with <a>path/path.current</a> as the first argument. Example:</p>\n<pre><code>path.absolute('path', 'to/foo'); // -&gt; '/your/current/dir/path/to/foo'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"part1":{"name":"part1","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part2":{"name":"part2","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part3":{"name":"part3","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part4":{"name":"part4","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part5":{"name":"part5","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part6":{"name":"part6","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part7":{"name":"part7","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"basename":{"name":"basename","qualifiedName":"path/path.basename","comment":"<p>Gets the part of <a>path/path.basename.path</a> after the last separator.</p>\n<pre><code>path.basename('path/to/foo.dart'); // -&gt; 'foo.dart'\npath.basename('path/to');          // -&gt; 'to'\n</code></pre>\n<p>Trailing separators are ignored.</p>\n<pre><code>path.basename('path/to/'); // -&gt; 'to'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"basenameWithoutExtension":{"name":"basenameWithoutExtension","qualifiedName":"path/path.basenameWithoutExtension","comment":"<p>Gets the part of <a>path/path.basenameWithoutExtension.path</a> after the last separator, and without any trailing\nfile extension.</p>\n<pre><code>path.basenameWithoutExtension('path/to/foo.dart'); // -&gt; 'foo'\n</code></pre>\n<p>Trailing separators are ignored.</p>\n<pre><code>path.basenameWithoutExtension('path/to/foo.dart/'); // -&gt; 'foo'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"dirname":{"name":"dirname","qualifiedName":"path/path.dirname","comment":"<p>Gets the part of <a>path/path.dirname.path</a> before the last separator.</p>\n<pre><code>path.dirname('path/to/foo.dart'); // -&gt; 'path/to'\npath.dirname('path/to');          // -&gt; 'path'\n</code></pre>\n<p>Trailing separators are ignored.</p>\n<pre><code>path.dirname('path/to/'); // -&gt; 'path'\n</code></pre>\n<p>If an absolute path contains no directories, only a root, then the root\nis returned.</p>\n<pre><code>path.dirname('/');  // -&gt; '/' (posix)\npath.dirname('c:\\');  // -&gt; 'c:\\' (windows)\n</code></pre>\n<p>If a relative path has no directories, then '.' is returned.</p>\n<pre><code>path.dirname('foo');  // -&gt; '.'\npath.dirname('');  // -&gt; '.'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"extension":{"name":"extension","qualifiedName":"path/path.extension","comment":"<p>Gets the file extension of <a>path/path.extension.path</a>: the portion of <a>path/path.basename</a> from the last\n<code>.</code> to the end (including the <code>.</code> itself).</p>\n<pre><code>path.extension('path/to/foo.dart');    // -&gt; '.dart'\npath.extension('path/to/foo');         // -&gt; ''\npath.extension('path.to/foo');         // -&gt; ''\npath.extension('path/to/foo.dart.js'); // -&gt; '.js'\n</code></pre>\n<p>If the file name starts with a <code>.</code>, then that is not considered the\nextension:</p>\n<pre><code>path.extension('~/.bashrc');    // -&gt; ''\npath.extension('~/.notes.txt'); // -&gt; '.txt'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"fromUri":{"name":"fromUri","qualifiedName":"path/path.fromUri","comment":"<p>Returns the path represented by <a>path/path.fromUri.uri</a>, which may be a <a>dart-core.String</a> or a <a>dart-core.Uri</a>.</p>\n<p>For POSIX and Windows styles, <a>path/path.fromUri.uri</a> must be a <code>file:</code> URI. For the URL\nstyle, this will just convert <a>path/path.fromUri.uri</a> to a string.</p>\n<pre><code>// POSIX\ncontext.fromUri('file:///path/to/foo')\n  // -&gt; '/path/to/foo'\n\n// Windows\ncontext.fromUri('file:///C:/path/to/foo')\n  // -&gt; r'C:\\path\\to\\foo'\n\n// URL\ncontext.fromUri('http://dartlang.org/path/to/foo')\n  // -&gt; 'http://dartlang.org/path/to/foo'\n</code></pre>\n<p>If <a>path/path.fromUri.uri</a> is relative, a relative path will be returned.</p>\n<pre><code>path.fromUri('path/to/foo'); // -&gt; 'path/to/foo'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"uri":{"name":"uri","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isAbsolute":{"name":"isAbsolute","qualifiedName":"path/path.isAbsolute","comment":"<p>Returns <code>true</code> if <a>path/path.isAbsolute.path</a> is an absolute path and <code>false</code> if it is a\nrelative path.</p>\n<p>On POSIX systems, absolute paths start with a <code>/</code> (forward slash). On\nWindows, an absolute path starts with <code>\\\\</code>, or a drive letter followed by\n<code>:/</code> or <code>:\\</code>. For URLs, absolute paths either start with a protocol and\noptional hostname (e.g. <code>http://dartlang.org</code>, <code>file://</code>) or with a <code>/</code>.</p>\n<p>URLs that start with <code>/</code> are known as \"root-relative\", since they're\nrelative to the root of the current URL. Since root-relative paths are still\nabsolute in every other sense, <a>path/path.isAbsolute</a> will return true for them. They\ncan be detected using <a>path/path.isRootRelative</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isRelative":{"name":"isRelative","qualifiedName":"path/path.isRelative","comment":"<p>Returns <code>true</code> if <a>path/path.isRelative.path</a> is a relative path and <code>false</code> if it is absolute.\nOn POSIX systems, absolute paths start with a <code>/</code> (forward slash). On\nWindows, an absolute path starts with <code>\\\\</code>, or a drive letter followed by\n<code>:/</code> or <code>:\\</code>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isRootRelative":{"name":"isRootRelative","qualifiedName":"path/path.isRootRelative","comment":"<p>Returns <code>true</code> if <a>path/path.isRootRelative.path</a> is a root-relative path and <code>false</code> if it's not.</p>\n<p>URLs that start with <code>/</code> are known as \"root-relative\", since they're\nrelative to the root of the current URL. Since root-relative paths are still\nabsolute in every other sense, <a>path/path.isAbsolute</a> will return true for them. They\ncan be detected using <a>path/path.isRootRelative</a>.</p>\n<p>No POSIX and Windows paths are root-relative.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isWithin":{"name":"isWithin","qualifiedName":"path/path.isWithin","comment":"<p>Returns <code>true</code> if <a>path/path.isWithin.child</a> is a path beneath <code>parent</code>, and <code>false</code> otherwise.</p>\n<pre><code>path.isWithin('/root/path', '/root/path/a'); // -&gt; true\npath.isWithin('/root/path', '/root/other'); // -&gt; false\npath.isWithin('/root/path', '/root/path') // -&gt; false\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"parent":{"name":"parent","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"child":{"name":"child","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"join":{"name":"join","qualifiedName":"path/path.join","comment":"<p>Joins the given path parts into a single path using the current platform's\n<a>path/path.separator</a>. Example:</p>\n<pre><code>path.join('path', 'to', 'foo'); // -&gt; 'path/to/foo'\n</code></pre>\n<p>If any part ends in a path separator, then a redundant separator will not\nbe added:</p>\n<pre><code>path.join('path/', 'to', 'foo'); // -&gt; 'path/to/foo\n</code></pre>\n<p>If a part is an absolute path, then anything before that will be ignored:</p>\n<pre><code>path.join('path', '/to', 'foo'); // -&gt; '/to/foo'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"part1":{"name":"part1","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part2":{"name":"part2","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part3":{"name":"part3","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part4":{"name":"part4","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part5":{"name":"part5","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part6":{"name":"part6","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part7":{"name":"part7","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"part8":{"name":"part8","optional":true,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"joinAll":{"name":"joinAll","qualifiedName":"path/path.joinAll","comment":"<p>Joins the given path parts into a single path using the current platform's\n<a>path/path.separator</a>. Example:</p>\n<pre><code>path.joinAll(['path', 'to', 'foo']); // -&gt; 'path/to/foo'\n</code></pre>\n<p>If any part ends in a path separator, then a redundant separator will not\nbe added:</p>\n<pre><code>path.joinAll(['path/', 'to', 'foo']); // -&gt; 'path/to/foo\n</code></pre>\n<p>If a part is an absolute path, then anything before that will be ignored:</p>\n<pre><code>path.joinAll(['path', '/to', 'foo']); // -&gt; '/to/foo'\n</code></pre>\n<p>For a fixed number of parts, <a>path/path.join</a> is usually terser.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"parts":{"name":"parts","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Iterable","inner":[{"outer":"dart-core.String","inner":[]}]}],"value":null,"annotations":[]}},"annotations":[]},"normalize":{"name":"normalize","qualifiedName":"path/path.normalize","comment":"<p>Normalizes <a>path/path.normalize.path</a>, simplifying it by handling <code>..</code>, and <code>.</code>, and\nremoving redundant path separators whenever possible.</p>\n<pre><code>path.normalize('path/./to/..//file.text'); // -&gt; 'path/file.txt'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"prettyUri":{"name":"prettyUri","qualifiedName":"path/path.prettyUri","comment":"<p>Returns a terse, human-readable representation of <a>path/path.prettyUri.uri</a>.</p>\n<p><a>path/path.prettyUri.uri</a> can be a <a>dart-core.String</a> or a <a>dart-core.Uri</a>. If it can be made relative to the\ncurrent working directory, that's done. Otherwise, it's returned as-is. This\ngracefully handles non-<code>file:</code> URIs for <a>path/path.Style.posix</a> and <a>path/path.Style.windows</a>.</p>\n<p>The returned value is meant for human consumption, and may be either URI-\nor path-formatted.</p>\n<pre><code>// POSIX at \"/root/path\"\npath.prettyUri('file:///root/path/a/b.dart'); // -&gt; 'a/b.dart'\npath.prettyUri('http://dartlang.org/'); // -&gt; 'http://dartlang.org'\n\n// Windows at \"C:\\root\\path\"\npath.prettyUri('file:///C:/root/path/a/b.dart'); // -&gt; r'a\\b.dart'\npath.prettyUri('http://dartlang.org/'); // -&gt; 'http://dartlang.org'\n\n// URL at \"http://dartlang.org/root/path\"\npath.prettyUri('http://dartlang.org/root/path/a/b.dart');\n    // -&gt; r'a/b.dart'\npath.prettyUri('file:///root/path'); // -&gt; 'file:///root/path'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"uri":{"name":"uri","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"relative":{"name":"relative","qualifiedName":"path/path.relative","comment":"<p>Attempts to convert <a>path/path.relative.path</a> to an equivalent relative path from the current\ndirectory.</p>\n<pre><code>// Given current directory is /root/path:\npath.relative('/root/path/a/b.dart'); // -&gt; 'a/b.dart'\npath.relative('/root/other.dart'); // -&gt; '../other.dart'\n</code></pre>\n<p>If the <a>path/path.relative.from</a> argument is passed, <a>path/path.relative.path</a> is made relative to that instead.</p>\n<pre><code>path.relative('/root/path/a/b.dart',\n    from: '/root/path'); // -&gt; 'a/b.dart'\npath.relative('/root/other.dart',\n    from: '/root/path'); // -&gt; '../other.dart'\n</code></pre>\n<p>If <a>path/path.relative.path</a> and/or <a>path/path.relative.from</a> are relative paths, they are assumed to be relative\nto the current directory.</p>\n<p>Since there is no relative path from one drive letter to another on Windows,\nor from one hostname to another for URLs, this will return an absolute path\nin those cases.</p>\n<pre><code>// Windows\npath.relative(r'D:\\other', from: r'C:\\home'); // -&gt; 'D:\\other'\n\n// URL\npath.relative('http://dartlang.org', from: 'http://pub.dartlang.org');\n  // -&gt; 'http://dartlang.org'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"from":{"name":"from","optional":true,"named":true,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"rootPrefix":{"name":"rootPrefix","qualifiedName":"path/path.rootPrefix","comment":"<p>Returns the root of <a>path/path.rootPrefix.path</a>, if it's absolute, or the empty string if it's\nrelative.</p>\n<pre><code>// Unix\npath.rootPrefix('path/to/foo'); // -&gt; ''\npath.rootPrefix('/path/to/foo'); // -&gt; '/'\n\n// Windows\npath.rootPrefix(r'path\\to\\foo'); // -&gt; ''\npath.rootPrefix(r'C:\\path\\to\\foo'); // -&gt; r'C:\\'\n\n// URL\npath.rootPrefix('path/to/foo'); // -&gt; ''\npath.rootPrefix('http://dartlang.org/path/to/foo');\n  // -&gt; 'http://dartlang.org'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"split":{"name":"split","qualifiedName":"path/path.split","comment":"<p>Splits <a>path/path.split.path</a> into its components using the current platform's <a>path/path.separator</a>.</p>\n<pre><code>path.split('path/to/foo'); // -&gt; ['path', 'to', 'foo']\n</code></pre>\n<p>The path will <em>not</em> be normalized before splitting.</p>\n<pre><code>path.split('path/../foo'); // -&gt; ['path', '..', 'foo']\n</code></pre>\n<p>If <a>path/path.split.path</a> is absolute, the root directory will be the first element in the\narray. Example:</p>\n<pre><code>// Unix\npath.split('/path/to/foo'); // -&gt; ['/', 'path', 'to', 'foo']\n\n// Windows\npath.split(r'C:\\path\\to\\foo'); // -&gt; [r'C:\\', 'path', 'to', 'foo']\n\n// Browser\npath.split('http://dartlang.org/path/to/foo');\n  // -&gt; ['http://dartlang.org', 'path', 'to', 'foo']\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.List","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toUri":{"name":"toUri","qualifiedName":"path/path.toUri","comment":"<p>Returns the URI that represents <a>path/path.toUri.path</a>.</p>\n<p>For POSIX and Windows styles, this will return a <code>file:</code> URI. For the URL\nstyle, this will just convert <a>path/path.toUri.path</a> to a <a>dart-core.Uri</a>.</p>\n<pre><code>// POSIX\npath.toUri('/path/to/foo')\n  // -&gt; Uri.parse('file:///path/to/foo')\n\n// Windows\npath.toUri(r'C:\\path\\to\\foo')\n  // -&gt; Uri.parse('file:///C:/path/to/foo')\n\n// URL\npath.toUri('http://dartlang.org/path/to/foo')\n  // -&gt; Uri.parse('http://dartlang.org/path/to/foo')\n</code></pre>\n<p>If <a>path/path.toUri.path</a> is relative, a relative URI will be returned.</p>\n<pre><code>path.toUri('path/to/foo')\n  // -&gt; Uri.parse('path/to/foo')\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Uri","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"withoutExtension":{"name":"withoutExtension","qualifiedName":"path/path.withoutExtension","comment":"<p>Removes a trailing extension from the last part of <a>path/path.withoutExtension.path</a>.</p>\n<pre><code>withoutExtension('path/to/foo.dart'); // -&gt; 'path/to/foo'\n</code></pre>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}}},"classes":{"class":[{"name":"Context","qualifiedName":"path/path.Context","preview":"<p>An instantiable class for manipulating paths. Unlike the top-level\nfunctions, this lets you explicitly select what platform the paths will use.</p>"},{"name":"Style","qualifiedName":"path/path.Style","preview":"<p>An enum type describing a \"flavor\" of path.</p>"}],"typedef":{},"error":[{"name":"PathException","qualifiedName":"path/path.PathException","preview":"<p>An exception class that's thrown when a path operation is unable to be\ncomputed accurately.</p>"}]},"packageName":"path","packageIntro":"<p>A comprehensive, cross-platform path manipulation library for Dart.</p>\n<p>The path package provides common operations for manipulating paths:\njoining, splitting, normalizing, etc.</p>\n<p>We've tried very hard to make this library do the \"right\" thing on whatever\nplatform you run it on, including in the browser. When you use the top-level\nfunctions, it will assume the current platform's path style and work with\nthat. If you want to explicitly work with paths of a specific style, you can\nconstruct a <code>path.Context</code> for that style.</p>\n<h2>Using</h2>\n<p>The path library was designed to be imported with a prefix, though you don't\nhave to if you don't want to:</p>\n<pre><code>import 'package:path/path.dart' as path;\n</code></pre>\n<p>The most common way to use the library is through the top-level functions.\nThese manipulate path strings based on your current working directory and\nthe path style (POSIX, Windows, or URLs) of the host platform. For example:</p>\n<pre><code>path.join(\"directory\", \"file.txt\");\n</code></pre>\n<p>This calls the top-level join function to join \"directory\" and\n\"file.txt\" using the current platform's directory separator.</p>\n<p>If you want to work with paths for a specific platform regardless of the\nunderlying platform that the program is running on, you can create a\nContext and give it an explicit Style:</p>\n<pre><code>var context = new path.Context(style: Style.windows);\ncontext.join(\"directory\", \"file.txt\");\n</code></pre>\n<p>This will join \"directory\" and \"file.txt\" using the Windows path separator,\neven when the program is run on a POSIX machine.</p>\n<h2>FAQ</h2>\n<h3>Where can I use this?</h3>\n<p>Pathos runs on the Dart VM and in the browser under both dart2js and Dartium.\nUnder dart2js, it currently returns \".\" as the current working directory, while\nunder Dartium it returns the current URL.</p>\n<h3>Why doesn't this make paths first-class objects?</h3>\n<p>When you have path <em>objects</em>, then every API that takes a path has to decide if\nit accepts strings, path objects, or both.</p><ul><li>\n<p>Accepting strings is the most convenient, but then it seems weird to have\nthese path objects that aren't actually accepted by anything that needs a\npath. Once you've created a path, you have to always call <code>.toString()</code> on\nit before you can do anything useful with it.</p></li><li>\n<p>Requiring objects forces users to wrap path strings in these objects, which\nis tedious. It also means coupling that API to whatever library defines this\npath class. If there are multiple \"path\" libraries that each define their\nown path types, then any library that works with paths has to pick which one\nit uses.</p></li><li>\n<p>Taking both means you can't type your API. That defeats the purpose of\nhaving a path type: why have a type if your APIs can't annotate that they\nexpect it?</p></li></ul>\n<p>Given that, we've decided this library should simply treat paths as strings.</p>\n<h3>How cross-platform is this?</h3>\n<p>We believe this library handles most of the corner cases of Windows paths\n(POSIX paths are generally pretty straightforward):</p><ul><li>\n<p>It understands that <em>both</em> \"/\" and \"\\\" are valid path separators, not just\n\"\\\".</p></li><li>\n<p>It can accurately tell if a path is absolute based on drive-letters or UNC\nprefix.</p></li><li>\n<p>It understands that \"/foo\" is not an absolute path on Windows.</p></li><li>\n<p>It knows that \"C:\\foo\\one.txt\" and \"c:/foo\\two.txt\" are two files in the\nsame directory.</p></li></ul>\n<h3>What is a \"path\" in the browser?</h3>\n<p>If you use this package in a browser, then it considers the \"platform\" to be\nthe browser itself and uses URL strings to represent \"browser paths\".</p>"}