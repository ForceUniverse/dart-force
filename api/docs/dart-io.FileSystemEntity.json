{"name":"FileSystemEntity","qualifiedName":"dart-io.FileSystemEntity","comment":"<p>The common super class for <a>dart-io.File</a>, <a>dart-io.Directory</a>, and <a>dart-io.Link</a> objects.</p>\n<p><a>dart-io.FileSystemEntity</a> objects are returned from directory listing\noperations. To determine if a FileSystemEntity is a <a>dart-io.File</a>, a\n<a>dart-io.Directory</a>, or a <a>dart-io.Link</a> perform a type check:</p>\n<pre><code>if (entity is File) (entity as File).readAsStringSync();\n</code></pre>\n<p>You can also use the <a>dart-io.FileSystemEntity.type</a> or <a>dart-io.FileSystemEntity.typeSync</a> methods to determine\nthe type of a file system object.</p>\n<p>Most methods in this class occur in synchronous and asynchronous pairs,\nfor example, <a>dart-io.FileSystemEntity.exists</a> and <a>dart-io.FileSystemEntity.existsSync</a>.\nUnless you have a specific reason for using the synchronous version\nof a method, prefer the asynchronous version to avoid blocking your program.</p>\n<p>Here's the exists method in action:</p>\n<pre><code>entity.exists().then((isThere) {\n  isThere ? print('exists') : print('non-existent');\n});\n</code></pre>\n<h2>Other resources</h2>\n<p><a href=\"https://www.dartlang.org/dart-by-example/#files-directories-and-symlinks\">Dart by Example</a>\nprovides additional task-oriented code samples that show how to use \nvarious API from the <a>dart-io.Directory</a> class and the <a>dart-io.File</a> class,\nboth subclasses of FileSystemEntity.</p><ul><li>\n<p><a href=\"https://www.dartlang.org/docs/dart-up-and-running/contents/ch03.html#ch03-dartio---file-and-socket-io-for-command-line-apps\">I/O for Command-Line Apps</a>\na section from <em>A Tour of the Dart Libraries</em>\ncovers files and directories.</p></li><li>\n<p><a href=\"https://www.dartlang.org/docs/tutorials/cmdline/\">Write Command-Line Apps</a>,\na tutorial about writing command-line apps, includes information\nabout files and directories.</p></li></ul>","isAbstract":true,"superclass":"dart-core.Object","implements":[],"subclass":["dart-io.Directory","dart-io.File","dart-io.Link"],"variables":{},"inheritedVariables":{},"methods":{"setters":{},"getters":{"absolute":{"name":"absolute","qualifiedName":"dart-io.FileSystemEntity.absolute","comment":"<p>Returns a <a>dart-io.FileSystemEntity</a> whose path is the absolute path to this.\nThe type of the returned instance is the type of this.</p>\n<p>The absolute path is computed by prefixing\na relative path with the current working directory, and returning\nan absolute path unchanged.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.FileSystemEntity","inner":[]}],"parameters":{},"annotations":[]},"isAbsolute":{"name":"isAbsolute","qualifiedName":"dart-io.FileSystemEntity.isAbsolute","comment":"<p>Returns a <a>dart-core.bool</a> indicating whether this object's path is absolute.</p>\n<p>On Windows, a path is absolute if it starts with \\\\ or a drive letter\nbetween a and z (upper or lower case) followed by :\\ or :/.\nOn non-Windows, a path is absolute if it starts with /.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"isWatchSupported":{"name":"isWatchSupported","qualifiedName":"dart-io.FileSystemEntity.isWatchSupported","comment":"<p>Test if <a>dart-io.FileSystemEntity.watch</a> is supported on the current system.</p>\n<p>Mac OS 10.6 and below is not supported.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"parent":{"name":"parent","qualifiedName":"dart-io.FileSystemEntity.parent","comment":"<p>The directory containing this.  If this is a root\ndirectory, returns this.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-io.Directory","inner":[]}],"parameters":{},"annotations":[]},"path":{"name":"path","qualifiedName":"dart-io.FileSystemEntity.path","comment":"","commentFrom":"dart-io.FileSystemEntity.path","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{},"methods":{"delete":{"name":"delete","qualifiedName":"dart-io.FileSystemEntity.delete","comment":"<p>Deletes this <a>dart-io.FileSystemEntity</a>.</p>\n<p>If the <a>dart-io.FileSystemEntity</a> is a directory, and if <a>dart-io.FileSystemEntity.delete.recursive</a> is false,\nthe directory must be empty. Otherwise, if <a>dart-io.FileSystemEntity.delete.recursive</a> is true, the\ndirectory and all sub-directories and files in the directories are\ndeleted. Links are not followed when deleting recursively. Only the link\nis deleted, not its target.</p>\n<p>If <a>dart-io.FileSystemEntity.delete.recursive</a> is true, the <a>dart-io.FileSystemEntity</a> is deleted even if the type\nof the <a>dart-io.FileSystemEntity</a> doesn't match the content of the file system.\nThis behavior allows <a>dart-io.FileSystemEntity.delete</a> to be used to unconditionally delete any file\nsystem object.</p>\n<p>Returns a <code>Future&lt;FileSystemEntity&gt;</code> that completes with this\n<a>dart-io.FileSystemEntity</a> when the deletion is done. If the <a>dart-io.FileSystemEntity</a>\ncannot be deleted, the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileSystemEntity","inner":[]}]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"deleteSync":{"name":"deleteSync","qualifiedName":"dart-io.FileSystemEntity.deleteSync","comment":"<p>Synchronously deletes this <a>dart-io.FileSystemEntity</a>.</p>\n<p>If the <a>dart-io.FileSystemEntity</a> is a directory, and if <a>dart-io.FileSystemEntity.deleteSync.recursive</a> is false,\nthe directory must be empty. Otherwise, if <a>dart-io.FileSystemEntity.deleteSync.recursive</a> is true, the\ndirectory and all sub-directories and files in the directories are\ndeleted. Links are not followed when deleting recursively. Only the link\nis deleted, not its target.</p>\n<p>If <a>dart-io.FileSystemEntity.deleteSync.recursive</a> is true, the <a>dart-io.FileSystemEntity</a> is deleted even if the type\nof the <a>dart-io.FileSystemEntity</a> doesn't match the content of the file system.\nThis behavior allows <a>dart-io.FileSystemEntity.deleteSync</a> to be used to unconditionally delete any\nfile system object.</p>\n<p>Throws an exception if the <a>dart-io.FileSystemEntity</a> cannot be deleted.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"void","inner":[]}],"parameters":{"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]},"exists":{"name":"exists","qualifiedName":"dart-io.FileSystemEntity.exists","comment":"<p>Checks whether the file system entity with this path exists. Returns\na <code>Future&lt;bool&gt;</code> that completes with the result.</p>\n<p>Since FileSystemEntity is abstract, every FileSystemEntity object\nis actually an instance of one of the subclasses <a>dart-io.File</a>,\n<a>dart-io.Directory</a>, and <a>dart-io.Link</a>.  Calling <a>dart-io.FileSystemEntity.exists</a> on an instance of one\nof these subclasses checks whether the object exists in the file\nsystem object exists and is of the correct type (file, directory,\nor link).  To check whether a path points to an object on the\nfile system, regardless of the object's type, use the <a>dart-io.FileSystemEntity.type</a>\nstatic method.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.bool","inner":[]}]}],"parameters":{},"annotations":[]},"existsSync":{"name":"existsSync","qualifiedName":"dart-io.FileSystemEntity.existsSync","comment":"<p>Synchronously checks whether the file system entity with this path\nexists.</p>\n<p>Since FileSystemEntity is abstract, every FileSystemEntity object\nis actually an instance of one of the subclasses <a>dart-io.File</a>,\n<a>dart-io.Directory</a>, and <a>dart-io.Link</a>.  Calling <a>dart-io.FileSystemEntity.existsSync</a> on an instance of\none of these subclasses checks whether the object exists in the\nfile system object exists and is of the correct type (file,\ndirectory, or link).  To check whether a path points to an object\non the file system, regardless of the object's type, use the\n<a>dart-io.FileSystemEntity.typeSync</a> static method.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{},"annotations":[]},"identical":{"name":"identical","qualifiedName":"dart-io.FileSystemEntity.identical","comment":"<p>Checks whether two paths refer to the same object in the\nfile system. Returns a <code>Future&lt;bool&gt;</code> that completes with the result.</p>\n<p>Comparing a link to its target returns false, as does comparing two links\nthat point to the same target.  To check the target of a link, use\nLink.target explicitly to fetch it.  Directory links appearing\ninside a path are followed, though, to find the file system object.</p>\n<p>Completes the returned Future with an error if one of the paths points\nto an object that does not exist.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.bool","inner":[]}]}],"parameters":{"path1":{"name":"path1","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"path2":{"name":"path2","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"identicalSync":{"name":"identicalSync","qualifiedName":"dart-io.FileSystemEntity.identicalSync","comment":"<p>Synchronously checks whether two paths refer to the same object in the\nfile system.</p>\n<p>Comparing a link to its target returns false, as does comparing two links\nthat point to the same target.  To check the target of a link, use\nLink.target explicitly to fetch it.  Directory links appearing\ninside a path are followed, though, to find the file system object.</p>\n<p>Throws an error if one of the paths points to an object that does not\nexist.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"path1":{"name":"path1","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"path2":{"name":"path2","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isDirectory":{"name":"isDirectory","qualifiedName":"dart-io.FileSystemEntity.isDirectory","comment":"<p>Checks if type(path) returns FileSystemEntityType.DIRECTORY.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.bool","inner":[]}]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isDirectorySync":{"name":"isDirectorySync","qualifiedName":"dart-io.FileSystemEntity.isDirectorySync","comment":"<p>Synchronously checks if typeSync(path) returns\nFileSystemEntityType.DIRECTORY.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isFile":{"name":"isFile","qualifiedName":"dart-io.FileSystemEntity.isFile","comment":"<p>Checks if type(path) returns FileSystemEntityType.FILE.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.bool","inner":[]}]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isFileSync":{"name":"isFileSync","qualifiedName":"dart-io.FileSystemEntity.isFileSync","comment":"<p>Synchronously checks if typeSync(path) returns\nFileSystemEntityType.FILE.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isLink":{"name":"isLink","qualifiedName":"dart-io.FileSystemEntity.isLink","comment":"<p>Checks if type(path, followLinks: false) returns\nFileSystemEntityType.LINK.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.bool","inner":[]}]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"isLinkSync":{"name":"isLinkSync","qualifiedName":"dart-io.FileSystemEntity.isLinkSync","comment":"<p>Synchronously checks if typeSync(path, followLinks: false) returns\nFileSystemEntityType.LINK.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"parentOf":{"name":"parentOf","qualifiedName":"dart-io.FileSystemEntity.parentOf","comment":"<p>Removes the final path component of a path, using the platform's\npath separator to split the path.  Will not remove the root component\nof a Windows path, like \"C:\\\" or \"\\\\server_name\\\".\nIgnores trailing path separators, and leaves no trailing path separators.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"rename":{"name":"rename","qualifiedName":"dart-io.FileSystemEntity.rename","comment":"<p>Renames this file system entity. Returns a <code>Future&lt;FileSystemEntity&gt;</code>\nthat completes with a <a>dart-io.FileSystemEntity</a> instance for the renamed\nfile system entity.</p>\n<p>If <a>dart-io.FileSystemEntity.rename.newPath</a> identifies an existing entity of the same type, that entity\nis replaced. If <a>dart-io.FileSystemEntity.rename.newPath</a> identifies an existing entity of a different\ntype, the operation fails and the future completes with an exception.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileSystemEntity","inner":[]}]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"renameSync":{"name":"renameSync","qualifiedName":"dart-io.FileSystemEntity.renameSync","comment":"<p>Synchronously renames this file system entity. Returns a <a>dart-io.FileSystemEntity</a>\ninstance for the renamed entity.</p>\n<p>If <a>dart-io.FileSystemEntity.renameSync.newPath</a> identifies an existing entity of the same type, that entity\nis replaced. If <a>dart-io.FileSystemEntity.renameSync.newPath</a> identifies an existing entity of a different\ntype, the operation fails and an exception is thrown.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.FileSystemEntity","inner":[]}],"parameters":{"newPath":{"name":"newPath","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"resolveSymbolicLinks":{"name":"resolveSymbolicLinks","qualifiedName":"dart-io.FileSystemEntity.resolveSymbolicLinks","comment":"<p>Resolves the path of a file system object relative to the\ncurrent working directory, resolving all symbolic links on\nthe path and resolving all '..' and '.' path segments.\n<a>dart-io.FileSystemEntity.resolveSymbolicLinks</a> returns a <code>Future&lt;String&gt;</code></p>\n<p><a>dart-io.FileSystemEntity.resolveSymbolicLinks</a> uses the operating system's native filesystem api\nto resolve the path, using the realpath function on linux and\nMac OS, and the GetFinalPathNameByHandle function on Windows.\nIf the path does not point to an existing file system object,\n<a>dart-io.FileSystemEntity.resolveSymbolicLinks</a> completes the returned Future with an FileSystemException.</p>\n<p>On Windows, symbolic links are resolved to their target before applying\na '..' that follows, and on other platforms, the '..' is applied to the\nsymbolic link without resolving it.  The second behavior can be emulated\non Windows by processing any '..' segments before calling\n<a>dart-io.FileSystemEntity.resolveSymbolicLinks</a>.  One way of doing this is with the URI class:\n:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();,\nsince resolve removes '..' segments.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-core.String","inner":[]}]}],"parameters":{},"annotations":[]},"resolveSymbolicLinksSync":{"name":"resolveSymbolicLinksSync","qualifiedName":"dart-io.FileSystemEntity.resolveSymbolicLinksSync","comment":"<p>Resolves the path of a file system object relative to the\ncurrent working directory, resolving all symbolic links on\nthe path and resolving all '..' and '.' path segments.</p>\n<p><a>dart-io.FileSystemEntity.resolveSymbolicLinksSync</a> uses the operating system's native\nfilesystem api to resolve the path, using the realpath function\non linux and Mac OS, and the GetFinalPathNameByHandle function on Windows.\nIf the path does not point to an existing file system object,\n<a>dart-io.FileSystemEntity.resolveSymbolicLinksSync</a> throws a FileSystemException.</p>\n<p>On Windows, symbolic links are resolved to their target before applying\na '..' that follows, and on other platforms, the '..' is applied to the\nsymbolic link without resolving it.  The second behavior can be emulated\non Windows by processing any '..' segments before calling\n<a>dart-io.FileSystemEntity.resolveSymbolicLinks</a>.  One way of doing this is with the URI class:\n:new Uri.parse('.').resolveUri(new Uri.file(input)).toFilePath();,\nsince resolve removes '..' segments.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]},"stat":{"name":"stat","qualifiedName":"dart-io.FileSystemEntity.stat","comment":"<p>Calls the operating system's stat() function on the <a>dart-io.FileSystemEntity.path</a> of this\n<a>dart-io.FileSystemEntity</a>.  Identical to <code>FileStat.stat(this.path)</code>.</p>\n<p>Returns a <code>Future&lt;FileStat&gt;</code> object containing the data returned by\nstat().</p>\n<p>If the call fails, completes the future with a <a>dart-io.FileStat</a> object\nwith .type set to\nFileSystemEntityType.NOT_FOUND and the other fields invalid.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileStat","inner":[]}]}],"parameters":{},"annotations":[]},"statSync":{"name":"statSync","qualifiedName":"dart-io.FileSystemEntity.statSync","comment":"<p>Synchronously calls the operating system's stat() function on the\n<a>dart-io.FileSystemEntity.path</a> of this <a>dart-io.FileSystemEntity</a>.\nIdentical to <code>FileStat.statSync(this.path)</code>.</p>\n<p>Returns a <a>dart-io.FileStat</a> object containing the data returned by stat().</p>\n<p>If the call fails, returns a <a>dart-io.FileStat</a> object with .type set to\nFileSystemEntityType.NOT_FOUND and the other fields invalid.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":true,"constant":false,"return":[{"outer":"dart-io.FileStat","inner":[]}],"parameters":{},"annotations":[]},"type":{"name":"type","qualifiedName":"dart-io.FileSystemEntity.type","comment":"<p>Finds the type of file system object that a path points to. Returns\na <code>Future&lt;FileSystemEntityType&gt;</code> that completes with the result.</p>\n<p><a>dart-io.FileSystemEntityType</a> has the constant instances FILE, DIRECTORY,\nLINK, and NOT<em>FOUND.  <a>dart-io.FileSystemEntity.type</a> will return LINK only if the optional\nnamed argument <a>dart-io.FileSystemEntity.type.followLinks</a> is false, and <a>dart-io.FileSystemEntity.type.path</a> points to a link.\nIf the path does not point to a file system object, or any other error\noccurs in looking up the path, NOT</em>FOUND is returned.  The only\nerror or exception that may be put on the returned future is ArgumentError,\ncaused by passing the wrong type of arguments to the function.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Future","inner":[{"outer":"dart-io.FileSystemEntityType","inner":[]}]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"followLinks":{"name":"followLinks","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]}},"annotations":[]},"typeSync":{"name":"typeSync","qualifiedName":"dart-io.FileSystemEntity.typeSync","comment":"<p>Synchronously finds the type of file system object that a path points to.\nReturns a <a>dart-io.FileSystemEntityType</a>.</p>\n<p><a>dart-io.FileSystemEntityType</a> has the constant instances FILE, DIRECTORY,\nLINK, and NOT<em>FOUND.  <a>dart-io.FileSystemEntity.type</a> will return LINK only if the optional\nnamed argument <a>dart-io.FileSystemEntity.typeSync.followLinks</a> is false, and <a>dart-io.FileSystemEntity.typeSync.path</a> points to a link.\nIf the path does not point to a file system object, or any other error\noccurs in looking up the path, NOT</em>FOUND is returned.  The only\nerror or exception that may be thrown is ArgumentError,\ncaused by passing the wrong type of arguments to the function.</p>","commentFrom":"","inheritedFrom":"","static":true,"abstract":false,"constant":false,"return":[{"outer":"dart-io.FileSystemEntityType","inner":[]}],"parameters":{"path":{"name":"path","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.String","inner":[]}],"value":null,"annotations":[]},"followLinks":{"name":"followLinks","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"true","annotations":[]}},"annotations":[]},"watch":{"name":"watch","qualifiedName":"dart-io.FileSystemEntity.watch","comment":"<p>Start watching the <a>dart-io.FileSystemEntity</a> for changes.</p>\n<p>The implementation uses platform-dependent event-based APIs for receiving\nfile-system notifications, thus behavior depends on the platform.</p><ul><li>\n<p><code>Windows</code>: Uses <code>ReadDirectoryChangesW</code>. The implementation only\nsupports watching directories. Recursive watching is supported.</p></li><li>\n<p><code>Linux</code>: Uses <code>inotify</code>. The implementation supports watching both\nfiles and directories. Recursive watching is not supported.\nNote: When watching files directly, delete events might not happen\nas expected.</p></li><li>\n<p><code>Mac OS</code>: Uses <code>FSEvents</code>. The implementation supports watching both\nfiles and directories. Recursive watching is supported.</p></li></ul>\n<p>The system will start listening for events once the returned <a>dart-async.Stream</a> is\nbeing listened to, not when the call to <a>dart-io.FileSystemEntity.watch</a> is issued.</p>\n<p>The returned value is an endless broadcast <a>dart-async.Stream</a>, that only stops when\none of the following happends:</p><ul><li>\n<p>The <a>dart-async.Stream</a> is canceled, e.g. by calling <code>cancel</code> on the\n <a>dart-async.StreamSubscription</a>.</p></li><li>The <a>dart-io.FileSystemEntity</a> being watches, is deleted.</li></ul>\n<p>Use <code>events</code> to specify what events to listen for. The constants in\n<a>dart-io.FileSystemEvent</a> can be or'ed together to mix events. Default is\n<a>dart-io.FileSystemEvent.ALL</a>.</p>","commentFrom":"","inheritedFrom":"","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-async.Stream","inner":[{"outer":"dart-io.FileSystemEvent","inner":[]}]}],"parameters":{"events":{"name":"events","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.int","inner":[]}],"value":"15","annotations":[]},"recursive":{"name":"recursive","optional":true,"named":true,"default":true,"type":[{"outer":"dart-core.bool","inner":[]}],"value":"false","annotations":[]}},"annotations":[]}}},"inheritedMethods":{"setters":{},"getters":{"hashCode":{"name":"hashCode","qualifiedName":"dart-io.FileSystemEntity.hashCode","comment":"<p>Get a hash code for this object.</p>\n<p>All objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator <code>==</code>. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.</p>\n<p>If a subclass overrides <a>dart-io.FileSystemEntity.hashCode</a> it should override the\nequality operator as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.hashCode","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.int","inner":[]}],"parameters":{},"annotations":[]},"runtimeType":{"name":"runtimeType","qualifiedName":"dart-io.FileSystemEntity.runtimeType","comment":"<p>A representation of the runtime type of the object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.runtimeType","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.Type","inner":[]}],"parameters":{},"annotations":[]}},"constructors":{},"operators":{"==":{"name":"==","qualifiedName":"dart-io.FileSystemEntity.==","comment":"<p>The equality operator.</p>\n<p>The default behavior for all <a>dart-core.Object</a>s is to return true if and\nonly if <code>this</code> and <a>dart-io.FileSystemEntity.==.other</a> are the same object.</p>\n<p>Override this method to specify a different equality relation on\na class. The overriding method must still be an equivalence relation.\nThat is, it must be:</p><ul><li>\n<p>Total: It must return a boolean for all arguments. It should never throw\n   or return <code>null</code>.</p></li><li>\n<p>Reflexive: For all objects <code>o</code>, <code>o == o</code> must be true.</p></li><li>\n<p>Symmetric: For all objects <code>o1</code> and <code>o2</code>, <code>o1 == o2</code> and <code>o2 == o1</code> must\n   either both be true, or both be false.</p></li><li>\n<p>Transitive: For all objects <code>o1</code>, <code>o2</code>, and <code>o3</code>, if <code>o1 == o2</code> and\n   <code>o2 == o3</code> are true, then <code>o1 == o3</code> must be true.</p></li></ul>\n<p>The method should also be consistent over time, so equality of two objects\nshould not change over time, or at least only change if one of the objects\nwas modified.</p>\n<p>If a subclass overrides the equality operator it should override\nthe <a>dart-io.FileSystemEntity.hashCode</a> method as well to maintain consistency.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.==","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.bool","inner":[]}],"parameters":{"other":{"name":"other","optional":false,"named":false,"default":false,"type":[{"outer":"dynamic","inner":[]}],"value":null,"annotations":[]}},"annotations":[]}},"methods":{"noSuchMethod":{"name":"noSuchMethod","qualifiedName":"dart-io.FileSystemEntity.noSuchMethod","comment":"<p><a>dart-io.FileSystemEntity.noSuchMethod</a> is invoked when users invoke a non-existent method\non an object. The name of the method and the arguments of the\ninvocation are passed to <a>dart-io.FileSystemEntity.noSuchMethod</a> in an <a>dart-core.Invocation</a>.\nIf <a>dart-io.FileSystemEntity.noSuchMethod</a> returns a value, that value becomes the result of\nthe original invocation.</p>\n<p>The default behavior of <a>dart-io.FileSystemEntity.noSuchMethod</a> is to throw a\n<a>dart-core.NoSuchMethodError</a>.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.noSuchMethod","static":false,"abstract":false,"constant":false,"return":[{"outer":"dynamic","inner":[]}],"parameters":{"invocation":{"name":"invocation","optional":false,"named":false,"default":false,"type":[{"outer":"dart-core.Invocation","inner":[]}],"value":null,"annotations":[]}},"annotations":[]},"toString":{"name":"toString","qualifiedName":"dart-io.FileSystemEntity.toString","comment":"<p>Returns a string representation of this object.</p>","commentFrom":"","inheritedFrom":"dart-core.Object.toString","static":false,"abstract":false,"constant":false,"return":[{"outer":"dart-core.String","inner":[]}],"parameters":{},"annotations":[]}}},"annotations":[],"generics":{}}